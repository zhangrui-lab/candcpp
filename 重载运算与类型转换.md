#### 函数调用运算符

* 如果类重载了函数调用运算符，则我们可以像使用函数一样使用该类的对象。因为这样的类同时也能存储状态，所以与普通函数相比它们更加灵活。

  ```c++
  struct absInt {
      int operator()(int val) const {
          return val < 0 ? -val : val;
      }
  };
  ```

* **函数调用运算符必须是成员函数。一个类可以定义多个不同版本的调用运算 符，相互之间应该在参数数量或类型上有所区别。**

* 如果类定义了调用运算符，则该类的对象称作**函数对象(function object)**.因为可以 调用这种对象，所以我们说这些对象的“行为像函数一样"

* 含有状态的函数对象类

  * 和其他类一样，函数对象类除了 operator(), 之外也可以包含其他成员。函数对象类 通常含有一些数据成员，这些成员被用于**定制调用运算符中的操作**。

  * 举个例子，我们将定义一个打印string实参内容的类。默认情况下，我们的类会将内容写入到cout中，每个string之间以空格隔开。同时也允许类的用户提供其他可写入的流及其他分隔符。我们将该类定义如下：

    ```c++
    class PrintString {
    public:
        PrintString(ostream &o = cout, char c = ' '): os(o), sep(c) {}
        void operator()(const string&s) { os << s << sep; }
    private:
        ostream &os;
        char sep;
    };
    ```

* **函数对象常常作为泛型算法的实参。**

  ```c++
      vector<string> users = {"jack", "tom", "jordorn", "zhangsan"};
  //    for_each(users.cbegin(), users.cend(), [](const string&str) {cout << str << '\t';});
      for_each(users.cbegin(), users.cend(), PrintString(cout, '\n'));
  ```

##### lambda是函数对象

* **当我们编 写了一个lambda后，编译器将该表达式翻译成一个未命名类的未命名对象。在lambda表达式产生的类中含有一个重载的函数调用运算符**

*  默认情况下lambda不能改变它捕获的变量。因此在默认情况下，由lambda产生的类当中 的函数调用运算符是一个const成员函数。如果lambda被声明为可变的，则调用运算符 就不是const的了。

* 表示lambda及相应捕获行为的类

  * 一个lambda表达式通过引用捕获变量时，**将由程序负责确保 lambda 执行时引用所引的对象确实存在**。因此，编译器可以直接使用该引用而无须在lambda 产生的类中将其存储为数据成员。
  * 相反，**通过值捕获的变量被拷贝到 lambda 中**。因此，这种 lambda 产生的类必须为每个值捕获的变量建立对应的数据成员，同时创建构造函数， 令其使用捕获的变量的值来初始化数据成员。

* 举个例子，有一 个lambda,它的作用是找到第一个长度不小于给定值的string对象：

  ```c++
  size_t sz = 7;
  vector<string> users = {"jack", "tom", "jordorn", "zhangsan"};
  auto it = find_if(users.cbegin(), users.cend(), [sz](const string& str){ return str.size() > sz; });
  ```

  该lambda表达式产生的类将形如：

  ```c++
  class SizeComp {
  public:
      SizeComp(std::size_t s):size(s) {}
      bool operator()(const string&str) { return str.size() > size; }
  private:
      std::size_t size;
  };
  ```

##### 标准库定义的函数对象

* 标准库定义了一组表示算术运算符、关系运算符和逻辑运算符的类，每个类分别定义了一个执行命名操作的调用运算符。

  * 例如，plus类定义了一个函数调用运算符用于对一对运算对象执行+的操作；modulus类定义了一个调用运算符执行二元的号操作； equal_to类执行==,等等。这些类都被定义成模板的形式，我们可以为其指定具体的应用类型，这里的类型即调用运算符的形参类型。例如，plus\<string\>令string加法运算符作用于string对象；plus\<int\>的运算对象是 int； plus\<Sales_data\>对 Sales_data 对象执行加 法运算，以此类推

* 在算法中使用标准库函数对象

  * 表示运算符的函数对象类常用来替换算法中的默认运算符。如我们所知，在默认情况 下排序算法使用operator〈将序列按照升序排列。如果要执行降序排列的话，我们可以 传入一个greater类型的对象。该类将产生一个调用运算符并负责执行待排序类型的大 于运算。例如，如果svec是一个vector\<string\>

    ```c++
    //传入一个临时的函数对象用于执行两个string对象的>比较运算
    sort(svec.begin(), svec.end(), greater<string>());
    //则上面的语句将按照降序对svec进行排序。第三个实参是greater<string>类型的一 个未命名的对象
    ```

  * 需要特别注意的是，标准库规定其函数对象对于指针同样适用。我们之前曾经介绍过 比较两个无关指针将产生未定义的行为(参见3.5.3节，第107页)，然而我们可能会希望 通过比较指针的内存地址来sort指针的vector。直接这么做将产生未定义的行为，因 此我们可以使用一个标准库函数对象来实现该目的

    ```c++
    vector<string *> nameTable;	// 指针的 vector
    //错误：nameTable中的指针彼此之间没有关系，所以〈将产生未定义的行为
    sort(nameTable.begin(), nameTable.end(), [](string *a, string *b) ( return a < b; });
    //正确：标准库规定指针的less是定义良好的
    sort(nameTable.begin(), nameTable.end(), less<string*>());
    ```

##### 可调用对象与function

* **C++语言中有几种可调用的对象：函数、函数指针、lambda表达式、bind创建的对象以及重载了函数调用运算符的类。**

* **和其他对象一样，可调用的对象也有类型**。例如，每个lambda有它自己唯一的(未 命名)类类型；函数及函数指针的类型则由其返回值类型和实参类型决定，等等。

* 然而，**两个不同类型的可调用对象却可能共享同一种调用形式(call signature)。调用形式指明了调用返回的类型以及传递给调用的实参类型。**一种调用形式对应- 个函数类型，例如：`int(int, int)` 是一个函数类型，它接受两个int、返回一个int。

  * **不同类型可能具有相同的调用形式**
  * **对于几个可调用对象共享同一种调用形式的情况，有时我们会希望把它们看成具有相同的类型**。

* 考虑下列不同类型的可调用对象：

  ```c++
  // 普通函数
  int add(int i, int j) { return i + j; }
  
  // lambda,其产生一个未命名的函数对象类
  auto mod = [](int i, int j) ( return i % j; };
  
  //函数对象类
  struct divide {
      int operator () (int denominator, int divisor) {
          return denominator / divisor;
      }
  }；
  ```

  上面这些可调用对象分别对其参数执行了不同的算术运算，尽管它们的类型各不相同，但是共享同一种调用形式： `int (int, int)`

  我们可能希望使用这些可调用对象构建一个简单的桌面计算器。为了实现这一目的， 需要**定义一个函数表(function table)用于存储指向这些可调用对象的“指针”。当程序需要执行某个特定的操作时，从表中查找该调用的函数。**

  在C++语言中，函数表很容易通过map来实现。对于此例来说，我们使用一个表示 运算符符号的string对象作为关键字；使用实现运算符的函数作为值。当我们需要求给定运算符的值时，先通过运算符索引map,然后调用找到的那个元素。

  假定我们的所有函数都相互独立，并且只处理关于int的二元运算，则map可以定 义成如下的形式：

  ```
  //构建从运算符到函数指针的映射关系，其中函数接受两个int、返回一个:int map<stringz int (*) (int,int)> binops;
  ```

  我们可以按照下面的形式将add的指针添加到binops中：

  ```
  //正确：add是一个指向正确类型函数的指针
  binops. insert ({”+ ”，add}); // {”+ ”，add}是一个 pair 
  ```

  但是我们不能将mod或者divide存入binops：

  ```c++
  binops . insert (( n%H, mod}) ;	// 错误：mod 不是一个函数指针
  ```

  问题在于mod是个 lambda 表达式，而每个 lambda 有它自己的类类型，该类型与存储在 binops中的值的类型不匹配。

* 标准库 function 类型

  * 我们可以使用一个名为function的新的标准库类型解决上述问题，function定 义在functional头文件中。

    | 名称                      | function 的操作                                              |
    | ------------------------- | ------------------------------------------------------------ |
    | function<T\> f;           | f是一个用来存储可调用对象的空function,这些可调用对象的调用形式应该与函数类型T相同(即T是retType(args)) |
    | function<T\> f (nullptr); | 显式地构造一个空function                                     |
    | function<T\> f (obj);     | 在f中存储可调用对象obj的副本                                 |
    | f                         | 将f作为条件：当f含有一个可调用对象时为真；否则为假           |
    | f(args)                   | 调用f中的对象，参数是args                                    |
    | result_type               | 该function类型的可调用对象返回的类型                         |
    | argument_type             | 当T有一个或两个实参时定义的类型。如果T只有一个实参，则argument_type是该类型的同义词；如果T有两个实参，则first_argument_type 和 second_argument_type 分别代表两个实参的类型 |
    | first_argument_type       |                                                              |
    | second_argument_type      |                                                              |

* function是一个模板，和我们使用过的其他模板一样，当创建一个具体的 function类型时我们必须提供额外的信息。在此例中，所谓额外的信息是指该 function类型能够表示的对象的调用形式。参考其他模板，我们在一对尖括号内指定类型： `function<int (int, int)>` 在这里我们声明了一个function类型，它可以表示接受两个int,返回一个int的可调用对象。因此，我们可以用这个新声明的类型表示任意一种桌面计算器用到的类型

  ```c++
  int add(int a, int b) { return a + b; }
  auto mod = [](int a, int b) { return a % b;};
  struct divide {
      int operator()(int a, int b) { return a/b; }
  };
  
  
  int main() {
      // 我们的map中包含5个元素，尽管其中的可调用对象的类型各不相同，我们仍然能够把 所有这些类型都存储在同一个function<int (int , int) >类型中。
      map<string, function<int(int, int)>> funMap = {
              {"+", add},
              {"-", std::minus<int>()},
              {"/", divide()},
              {"*", [](int a, int b) { return a * b; }},
              {"%", mod}};
      cout << funMap["+"](10, 5) << endl; //15
      cout << funMap["-"](10, 5) << endl; // 5
      cout << funMap["*"](10, 5) << endl; // 50
      cout << funMap["/"](10, 5) << endl; // 2
      cout << funMap["%"](10, 5) << endl; // 0
  }
  ```

* 重载的函数与function
  * **我们不能(直接)将重载函数的名字存入function类型的对象中**。
    *  解决上述二义性问题的一条途径是存**储函数指针而非函数的名字**
    * 使用lambda来消除二义性
  * 新版本标准库中的function类与旧版本中的 unary_function 和 binary_function 没有关联，后两个已经被更通用的bind函数替代了

#### 载载、类型转换与运算符

* 我们能定义对于类类型的类型转换，通过定义**类型转换运算符**可以做到这一点。**转换构造函数和类型转换运算符共同定义了类类型转换(class-type conversions),这样的转换有时也被称作用户定义的类型转换(user-defined conversions)。**

##### 类型转换运算符

* 类型转换运算符(conversion operator)是类的一种特殊成员函数，它负责将一个类类 型的值转换成其他类型。类型转换函数的一般形式如下所示；

  ```c++
  operator type() const;
  ```

  其中 type 表示某种类型。**类型转换运算符可以面向任意类型(除了 void之外)进行定义， 只要该类型能作为函数的返回类型**。因此，我们不允许转换成数组或者函数类型，但允许转换成指针(包括数组指针及函数指针)或者引用类型。

* 类型转换运算符既**没有显式的返回类型**，也**没有形参**，而且**必须定义成类的成员函数**。 类型转换运算符通常**不应该改变待转换对象的内容**，因此，类型转换运算符一般**被定义成 const成员**。
* **一个类型转换函数必须是类的成员函数；它不能声明返回类型，形参列表也必 须为空。类型转换函数通常应该是const。**

* 定义含有类型转换运算符的类

  * 举个例子，我们定义一个比较简单的类，令其表示0到255之间的一个整数：

    ```c++
    class SmallInt {
    public:
        SmallInt(int i = 0):val(i) {
            if (i < 0 || i > 255)
                throw std::out_of_range("Bad SmallInt Value");
        }
        operator int() const { return val; }
    
    private:
        std::size_t val;
    };
    
    SmallInt sl = 3.13;
    cout << sl + 3 <<  endl;
    ```

* 提示：避免过度使用类型转换函数

  * 和使用重载运算符的经验一样，明智地使用类型转换运算符也能极大地简化类设计者的工作，同时使得使用类更加容易。然而，**如果在类类型和转换类型之间不存在明显的映射关系，则这样的类型转换可能具有误导性**。
  * 例如，假设某个类表示Date,我们也许会为它添加一个从Date到int的转换， 然而，类型转换函数的返回值应该是什么？ 一种可能的解释是，函数返回一个十进制数， 依次表示年、月、日，例如，July 30, 1989可能转换为int值19890730。同时还存在另外一种合理的解释，即类型转换运算符返回的int表示的是从某个时间节点（比如 January 1, 1970 ）开始经过的天数。显然这两种理解都合情合理，毕竟从形式上看它们产生的效果都是越靠后的日期对应的整数值越大，而且两种转换都有实际的用处。问题在于Date类型的对象和int类型的值之间不存在明确的一对一映射关系。因 此在此例中，不定义该类型转换运算符也许会更好。**作为替代的手段，类可以定义一个或多个普通的成员函数以从各种不同形式中提取所需的信息。**

* 类型转换运算符可能产生意外结果

  * 在实践中，类很少提供类型转换运算符。在大多数情况下，如果类型转换自动发生， 用户可能会感觉比较意外，而不是感觉受到了帮助。然而这条经验法则存在一种例外情况：**对于类来说，定义向bool的类型转换还是比较普遍的现象。**

  * 在C++标准的早期版本中，如果类想定义一个向bool的类型转换，则它常常遇到一 个问题：因为**bool是一种算术类型，所以类类型的对象转换成bool后就能被用在任何需要算术类型的上下文中**。这样的类型转换可能引发意想不到的结果，特别是当istream 含有向bool的类型转换时，下面的代码仍将编译通过：

    ```c++
    int i = 42;
    cin <<  i; //如果向bool的类型转换不是显式的，则该代码在编译器看来将是合法的！
    ```

    这段程序试图将输出运算符作用于输入流。因为istream本身并没有定义 << ,所以本来代码应该产生错误。然而，该代码能使用istream的bool类型转换运算符将cin转换 成bool,而这个bool值接着会被提升成int并用作内置的左移运算符的左侧运算对象。 这样一来，提升后的bool值（1或0）最终会被左移42个位置。这一结果显然与我们的 预期大相径庭。

* 显式的类型转换运算符

* 为了防止这样的异常情况发生，C++11新标准引入了显式的类型转换运算符(explicit conversion operator)：

  ```c++
  class Smalllnt {
  public:
      //编译器不会自动执行这一类型转换 
      explicit operator int() const { return val; } //其他成员与之前的版本一致
  }；
  ```

  和显式的构造函数一样，**编译器（通常）也不会将一个显式的类型转换运算符用于隐式类型转换**：

  ```
  Smalllnt si = 3;	//正确：Smalllnt的构造函数不是显式的
  si + 3;	//错误：此处需要隐式的类型转换，但类的运算符是显式的
  static_cast<int> （si） + 3;	//正确：显式地请求类型转换
  ```

  当类型转换运算符是显式的时，我们也能执行类型转换，不过必须通过显式的强制类型转换才可以。

* 该规定存在一个例外，即**如果表达式被用作条件，则编译器会将显式的类型转换自动应用于它。换句话说，当表达式出现在下列位置时，显式的类型转换将被隐式地执行**：
  * if ，while及do语句的条件部分
  *  for语句头的条件表达式
  * 逻辑非运算符（！）、逻辑或运算符（||）、逻辑与运算符（&&）的运算对象
  * 条件运算符（？：）的条件表达式。
* 转换为bool
  * 在标准库的早期版本中，IO 类型定义了向void*的转换规则，以求避免上面提到的 问题。在C++11新标准下，IO标准库通过定义一个向bool的显式类型转换实现同样的目的。
  * 无论我们什么时候在条件中使用流对象，都会使用为IO类型定义的operator bool。例如：`while （std::cin >> value）` while语句的条件执行输入运算符，它负责将数据读入到 value 并返回 cin。为了对条件求值，cin被operator bool类型转换函数隐式地执行了转换。如果cin 的条件状态是good ，则该函数返回为真：否则该函数返回为假。
* **向 bool 的类型转换通常用在条件部分，因此 operator bool 一般定义成 explicit 的**

##### 避免有二义性的类型转换	矽

* 如果类中包含一个或多个类型转换，则必须确保在类类型和目标类型之间只存在唯一 一种转换方式。否则的话，我们编写的代码将很可能会具有二义性。

* 在两种情况下可能产生多重转换路径。第一种情况是**两个类提供相同的类型转换**：例 如，当A类定义了一个接受B类对象的转换构造函数，同时B类定义了一个转换目标是A类的类型转换运算符时，我们就说它们提供了相同的类型转换。

* 第二种情况是**类定义了多个转换规则，而这些转换涉及的类型本身可以通过其他类型转换联系在一起**。最典型的例子是算术运算符，对某个给定的类来说，最好只定义最多一 个与算术类型有关的转换规则。

* **通常情况下，不要为类定义相同的类型转换，也不要在类中定义两个及两个以 上转换源或转换目标是算术类型的转换**

* 二义性与转换目标为内置类型的多重类型转换

  * 另外如果类定义了一组类型转换，它们的转换源(或者转换目标)类型本身可以通过其他类型转换联系在一起，则同样会产生二义性的问题。最简单也是最困扰我们的例子 是类当中定义了多个参数都是算术类型的构造函数，或者转换目标都是算术类型的类型转换运算符。

  * 例如，在下面的类中包含两个转换构造函数，它们的参数是两种不同的算术类型；同 时还包含两个类型转换运算符，它们的转换目标也恰好是两种不同的算术类型

    ```c++
    struct A {
        A(int = 0);	//最好不要创建两个转换源都是算术类型的类型转换
        A(double);
        operator int () const; //最好不要创建两个转换对象都是算术类型的类型转换 
        operator double() const;
        //其他成员
    }；
    void f2(long double);
    A a;
    f2 (a) ;	// 二义性错误：含义是 f (A: : operator int ())
    // 还是 f (A: : operator double () ) ?
    long Ig;
    A a2 (Ig) ;	// 二义性错误：含义是 A: : A (int)还是 A: : A (double) ?
    ```

    在对f2的调用中，哪个类型转换都无法精确匹配long double。然而这两个类型转换都可以使用，只要后面再执行一次生成long double的标准类型转换即可。因此，在上面的两个类型转换中哪个都不比另一个更好，调用将产生二义性。

    当我们试图用long初始化a2时也遇到了同样问题，哪个构造函数都无法精确匹配 long 类型。它们在使用构造函数前都要求先将实参进行类型转换：

    •先执行long到double的标准类型转换，再执行A (double)

    •先执行long到int的标准类型转换，再执行A(int)

    编译器没办法区分这两种转换序列的好坏，因此该调用将产生二义性。调用f2及初始化a2的过程之所以会产生二义性，根本原因是**它们所需的标准类型转换级别一致**。当我们**使用用户定义的类型转换时，如果转换过程包含标准类型转换，则标准类型转换的级别将决定编译器选择最佳匹配的过程**

* **当我们使用两个用户定义的类型转换时，如果转换函数之前或之后存在标准类型转换，则标准类型转换将决定最佳匹配到底是哪个**
* 提示：类型转换与运算符
  * 要想正确地设计类的重载运算符、转换构造函数及类型转换函数，必须加倍小心。 尤其是当类同时定义了类型转换运算符及重载运算符时特别容易产生二义性。以下的经 验规则可能对你有所帮助：
    * **不要令两个类执行相同的类型转换**：如果Foo类有一个接受Bar类对象的构造函数,则不要在Bar类中再定义转换目标是Foo类的类型转换运算符。
    * **避免转换目标是内置算术类型的类型转换。特别是当你已经定义了一个转换成算 术类型的类型转换时**，接下来
      1. 不要再定义接受算术类型的重载运算符。如果用户需要使用这样的运算符， 则类型转换操作将转换你的类型的对象，然后使用内置的运算符。
      2. 不要定义转换到多种算术类型的类型转换。让标准类型转换完成向其他算术类型转换的工作。
  * **一言以蔽之：除了显式地向bool类型的转换之外，我们应该尽量避免定义类型转换函数并尽可能地限制那些“显然正确”的非显式构造函数。**

* 重载函数与转换构造函数

  * **当我们调用重载的函数时，从多个类型转换中进行选择将变得更加复杂。如果两个或多个类型转换都提供了同一种可行匹配，则这些类型转换一样好。**

    ```c++
    struct C {
        C(int);
        //其他成员
    };
    struct D {
        D(int);
        //其他成员
    }；
    void manip(const C&);
    void manip(const D&);
    manip (10); // 二义性错误：含义是 manip(C(10))还是 manip(D(10))
    ```

    其中C和D都包含接受int的构造函数，两个构造函数各自匹配manip的一个版本。因 此调用将具有二义性：它的含义可能是把int转换成C,然后调用manip的第一个版本； 也可能是把int转换成D,然后调用manip的第二个版本。

* **如果在调用重载函数时我们需要使用构造函数或者强制类型转换来改变实参的类型，则这通常意味着程序的设计存在不足**
* 重载函数与用户定义的类型转换
  * **当调用重载函数时，如果两个(或多个)用户定义的类型转换都提供了可行匹配，则我们认为这些类型转换一样好。在这个过程中，我们不会考虑任何可能出现的标准类型转换的级别。只有当重载函数能通过同一个类型转换函数得到匹配时，我们才会考虑其中出现的标准类型转换。**
* **在调用重载函数时，如果需要额外的标准类型转换，则该转换的级别只有当所有可行函数都请求同一个用户定义的类型转换时才有用"如果所需的用户定义的类型转换不止一个，则该调用具有二义性**

* 函数匹配与重载运算符

* 重载的运算符也是重载的函数。因此，通用的函数匹配规则同样适用于判断在给定的表达式中到底应该使用内置运算符还是重载的运算符。不过当运算符函数出现在表达式中时，候选函数集的规模要比我们使用调用运算符调用函数时更大。如果a是一种类类型，则表达式`a sym b`可能是

  ```c++
  a.operatorsym (b) ; // a 有一个 operatorsym 成员函数
  operatorsym(a, b) ; //	是一个普通函数
  ```

  和普通函数调用不同，我们不能通过调用的形式来区分当前调用的是成员函数还是非成员函数。

  当我们使用重载运算符作用于类类型的运算对象时，候选函数中包含**该运算符的普通非成员版本和内置版本**。除此之外，如果左侧运算对象是类类型，则定义在**该类中的运算符的重载版本**也包含在候选函数内。

  **当我们调用一个命名的函数时，具有该名字的成员函数和非成员函数不会彼此重载， 这是因为我们用来调用命名函数的语法形式对于成员函数和非成员函数来说是不相同的。 当我们通过类类型的对象(或者该对象的指针及引用)进行函数调用时，只考虑该类的成员函数。**而当我们在表达式中使用重载的运算符时，**无法判断正在使用的是成员函数还是非成员函数，因此二者都应该在考虑的范围内。**表达式中运算符的候选函数集既应该包括成员函数，也应该包括非成员函数、

* 举个例子，我们为Smalllnt类定义一个加法运算符：

  ```c++
  class Smalllnt {
  friend Smalllnt operators(const Smalllnt&, const Smalllnt&);
  
  public:
      Smalllnt (int = 0) ;	//转换源为int的类型转换
      operator int() const {return val;}  // 转换目标为 int 的类型转换
  private:
      std::size_t val;
  };
  
  Smalllnt si, s2;
  Smalllnt s3 = si + s2;	// 彳吏用重载的operator+
  int i = s3 + 0;	// 二义性错误
  ```

* **如果我们对同一个类既提供了转换目标是算术类型的类型转换，也提供了重载  的运算符，则将会遇到重载运算符与内置运算符的二义性问题。**

#### 小节

* 一个重载的运算符必须是某个类的成员或者至少拥有一个类类型的运算对象。
* 重载运算符的运算对象数量、结合律、优先级与对应的用于内置类型的运算符完全一致。
* 当运算符被定义为类的成员时，类对象的隐式this指针绑定到第一个运算对象。赋值、下标、 函数调用和箭头运算符必须作为类的成员。
* 如果类重载了函数调用运算符operator (),则该类的对象被称作“函数对象。 这样的对象常用在标准函数中.lambda表达式是一种简便的定义函数对象类的方式。
* 在类中可以定义转换源或转换目的是该类型本身的类型转换，这样的类型转换将自动执行。只接受单独一个实参的非显式构造函数定义了从实参类型到类类型的类型转换；而非显式的类型转换运算符则定义了从类类型到其他类型的转换。

