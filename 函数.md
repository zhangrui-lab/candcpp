* **函数是一个命名了的代码块**，我们通过调用函数执行相应的代码。函数可以有0个或多个参数，而且(通常)会产生一个结果。可以重载函数，也就是说，同一个名字可以对 应几个不同的函数。

#### 函数基础

* 一个典型的函数(function)定义包括以下部分**：返回类型(return type)、函数名字、 由0个或多个形参(parameter)组成的列表以及函数体**。其中，形参以逗号隔开，形参的 列表位于一对圆括号之内。函数执行的操作在语句块中说明， 该语句块称为函数体(function body)。
* **调用运算符(call operator)**来执行函数。调用运算符的形式是一对圆括号， 它作用于一个表达式，该表达式是函数或者指向函数的指针；圆括号之内是一个用逗号隔开的实参(argument)列表，我们用实参初始化函数的形参。调用表达式的类型就是函数的返回类型。
* 调用函数
  * 函数的调用完成两项工作：一是**用实参初始化函数对应的形参**，二是**将控制权转移给被调用函数**。此时，主调函数(calling function)的执行被暂时中断，被调函数(called function) 开始执行。
  * **当遇到一条return语句时函数结束执行过程**。和函数调用一样，return语句也完成两项工作：一是**返回return语句中的值**(如果有的话)，二是**将控制权从被调函数转移回主调函数**。函数的返回值用于初始化调用表达式的结果，之后继续完成调用所在的表达式的剩余部分。
* 形参和实参
  * 实参是形参的初始值。第一个实参初始化第一个形参，第二个实参初始化第二个形参， 以此类推。尽管实参与形参存在对应关系，但是并没有规定实参的求值顺序。编译器能以任意可行的顺序对实参求值。
  * **实参的类型必须与对应的形参类型匹配**
  * 函数有几个形参，我们就必 须提供相同数量的实参。因为函数的调用规定实参数量应与形参数量一致，所以形参一定 会被初始化。
* 函数的形参列表
  * 函数的形参列表可以为空，但是不能省略。要想定义一个不带形参的函数，最常用的办法是**书写一个空的形参列表**。不过为了与C语言兼容，也可以**使用关键字void表示函数没有形参**
  * 形参列表中的形参通常用逗号隔开，其中每个形参都是含有一个声明符的声明。即使 两个形参的类型一样，也必须把两个类型都写出来
  * 任意两个形参都不能同名，而且函数最外层作用域中的局部变量也不能使用与函数形参一 样的名字。
  * **形参名是可选的**，但是由于我们无法使用未命名的形参，所以形参一般都应该有个名 字。偶尔，函数确实有个别形参不会被用到，则此类形参通常不命名以表示在函数体内不 会使用它。不管怎样，是否设置未命名的形参并不影响调用时提供的实参数量。**即使某个形参不被函数使用，也必须为它提供一个实参。**
* 函数返回类型
  * 大多数类型都能用作函数的返回类型。一种特殊的返回类型是void,它表示函数不 返回任何值。函数的返回类型不能是数组类型或函数类型，但可以是指向数组或函数的指针。

#### 局部对象

* 在C++语言中，名字有作用域，对象有生命周期(lifetime)
  * **名字的作用域是程序文本的一部分，名字在其中可见。**
  * **对象的生命周期是程序执行过程中该对象存在的一段时间。**

* 函数体是一个语句块。**块构成一个新的作用域**，我们可以在其中定义变量。形参和函数体内部定义的变量统称为局部变量(local variable)o它们对函数而言是“局部”的，仅在函数的作用域内可见，同时局部变量还会隐藏(hide)在外层作用域中同名的其他所有声明。
* **在所有函数体之外定义的对象存在于程序的整个执行过程中。此类对象在程序启动时被创建，直到程序结束才会销毁。局部变量的生命周期依赖于定义的方式。**
* 自动对象
  * 对于普通局部变量对应的对象来说，**当函数的控制路径经过变量定义语句时创建该对象，当到达定义所在的块末尾时销毁它**。我们**把只存在于块执行期间的对象称为自动对象 (automatic object)** , 当块的执行结束后，块中创建的自动对象的值就变成未定义的了。
  * 形参是一种自动对象。函数开始时为形参申请存储空间，因为形参定义在函数体作用 域之内，所以一旦函数终止，形参也就被销毁。
  * 我们**用传递给函数的实参初始化形参对应的自动对象**。对于局部变量对应的自动对象 来说，则分为两种情况：如果变量定义本身含有初始值，就用这个初始值进行初始化；否 则，如果变量定义本身不含初始值，执行默认初始化。这意味着内置类型的未初始化局部变量将产生未定义的值。

* 局部静态对象
  * 某些时候，有必要**令局部变量的生命周期贯穿函数调用及之后的时间**。可以将局部变量定义成static类型从而获得这样的对象**。局部静态对象(local static object)在程序的执行路径第一次经过对象定义语句时初始化，并且直到程序终止才被销毁**，在此期间即使对象所在的函数结朿执行也不会对它有影响。
* 如果局部静态变量没有显式的初始值，它将执行值初始化，**内置类型的局部静态变量初始化为0**。

#### 函数声明

* 和其他名字一样，函数的名字也必须在使用之前声明。类似于变量，**函数只能定义一次，但可以声明多次**。
* **如果一个函数永远也不会被我们用到，那么它可以只有声明没有定义。**
* 因为函数的声明不包含函数体，所以也就无须形参的名字。事实上，在函数的声明中 经常省略形参的名字。尽管如此，写上形参的名字还是有用处的，它可以帮助使用者更好地理解函数的功能
* **函数的三要素（返回类型、函数名、形参类型）描述了函数的接口，说明了调用该函数所需的全部信息。函数声明也称作函数原型（function prototype）**
* 在头文件中进行函数声明
  * 我们建议变量在头文件中声明，在源文件中定义。与之类似，函数也应该在头文件中声明而在源文件中定义。
  * 看起来把函数的声明直接放在使用该函数的源文件中是合法的，也比较容易被人接受；但是这么做可能会很烦琐而且容易出错。相反，**如果把函数声明放在头文件中，就能 确保同一函数的所有声明保持一致。而且一旦我们想改变函数的接口，只需改变一条声明 即可。**
  * **定义函数的源文件应该把含有函数声明的头文件包含进来，编译器负责验证函数的定义和声明是否匹配。**

* 分离式编译
  * 随着程序越来越复杂，我们希望把程序的各个部分分别存储在不同文件中。分离式编译允许我们把程序分割到几个文件中去，每个文件独 立编译。
  * 编译和链接多个源文件
    * 要生成可执行文件(executable file),必须告诉编译 器我们用到的代码在哪里。
    * 如果我们修改了其中一个源文件，那么只需重新编译那个改动了的文件。大多数编译 器提供了分离式编译每个文件的机制,这一过程通常会产生一个后缀名是.obj( Windows) 或.o (UNIX)的文件，后缀名的含义是该文件包含对象代码(object code)。接下来编译器负责把对象文件链接在一起形成可执行文件。

* 参数传递
  * 如前所述，每次调用函数时都会重新创建它的形参，并用传入的实参对形参进行初始化。
  * 形参初始化的机理与变量初始化一样。
  * 和其他变量一样，**形参的类型决定了形参和实参交互的方式**。如果形参是引用类型，它将绑定到对应的实参上；否则，将实参的值拷贝后赋给形参。
  * 当形参是引用类型时，我们说它对应的实参被引用传递(passed by reference)或者函数被传引用调用(called by reference)o和其他引用一样，引用形参也是它绑定的对象的别名；也就是说，引用形参是它对应的实参的别名。
  * 当实参的值被拷贝给形参时，形参和实参是两个相互独立的对象。我们说这样的实参被值传递(passed by value)或者函数被传值调用(called by value)。

* 传值参数
  
  * 当初始化一个非引用类型的变量时，初始值被拷贝给变量。此时，对变量的改动不会影响初始值传值参数的机理完全一样，函数对形参做的所有操作都不会影响实参。
* 指针形参
  
  * 指针的行为和其他非引用类型一样。**当执行指针拷贝操作时，拷贝的是指针的值。拷贝之后，两个指针是不同的指针。**因为指针使我们可以间接地访问它所指的对象，所以通 过指针可以修改它所指对象的值。（**形参指针只能改变实参所指向的对象的值， 无法影响实参本身**）
* 引用参数
  
* 对于引用的操作实际上是作用在引用所引的对象上。引用形参的行为与之类似。通过**使用引用形参，允许函数改变一个或多个实参的值。**
  
* 使用引用避免拷贝

  * **拷贝大的类类型对象或者容器对象比较低效，甚至有的类类型根本就不支持拷贝操作**。当某种类型不支持拷贝操作时，函数只能通过引用形参或指针的方式访问该类型的对象。
    * 举个例子，我们准备编写一个函数比较两个string对象的长度。因为string对象 可能会非常长，所以应该尽量避免直接拷贝它们，这时使用引用形参是比较明智的选择。 又因为比较长度无须改变string对象的内容，所以把形参定义成对常量的引用
  * **如果函数无须改变引用形参的值，最好将其声明为常量引用。**

* 使用引用形参返回额外信息

  * 一个函数只能返回一个值，然而有时函数需要同时返回多个值，引用形参为我们一次 返回多个结果提供了有效的途径。举个例子，我们定义一个名为find_char的函数，它 返回在string对象中某个指定字符第一次出现的位置。同时，我们也籍望函数能返回该字符出现的总次数。该如何定义函数使得它能够既返回位置也返回出现次数呢？ 一种方法是定义一个新的数据类型，让它包含位置和数量两个成员。还有另一种更简单的方法，我们可以给函数 传入一个额外的引用实参，令其保存字符出现的次数

* const形参和实参

  * 和其他初始化过程一样，当用实参初始化形参时会忽略掉顶层const.  换句话说，形参的顶层const被忽略掉了。**当形参有顶层const时，传给它常量对象或者非常量对象都是可以的**

* 合尽量使用常量引用

  * **把函数不会改变的形参定义成(普通的)引用是一种比较常见的错误**，这么做**带给函数的调用者一种误导**，即函数可以修改它的实参的值。此外，**使用引用而非常量引用也会 极大地限制函数所能接受的实参类型**。就像刚刚看到的，我们不能把const对象、字面 值或者需要类型转换的对象传递给普通的引用形参。

* 数组形参

  * 数组的两个特殊性质对我们定义和使用作用在数组上的函数有影响，这两个性质分别是：**不允许拷贝数组**以及**使用数组时(通常)会将其转换成指针**。因为不能拷贝数组，所以我们无法以值传递的方式使用数组参数。因为数组会被转换成指针，所以当我们为函数传递一个数组时，实际上传递的是指向数组首元素的指针。**尽管不能以值传递的方式传递数组，但是我们可以把形参写成类似数组的形式**

    ```
    //尽管形式不同，但这三个print函数是等价的
    //每个函数都有一个const int*类型的形参
    void print(const int*)；
    void print (const int [] ) ；	//可以看出来，函数的意图是作用于一个数组
    void print (const int [10] ) ；	//这里的维度表示我们期望数组含有多少元素，实际
    //不一定
    ```

* **因为数组是以指针的形式传递给函数的，所以一开始函数并不知道数组的确切尺寸，调用者应该为此提供一些额外的信息**。管理指针形参有三种常用的技术。

  * **使用标记指定数组长度**
    * 管理数组实参的第一种方法是**要求数组本身包含一个结束标记**，使用这种方法的典型示例是C风格字符串。C风格字符串存储在字符数组中，并且在最后一个字符后面跟着一个空字符。函数在处理C风格字符串时遇到空字符停止
    * 这种方法**适用于那些有明显结束标记且该标记不会与普通数据混淆的情况**，但是对于像 int这样所有取值都是合法值的数据就不太有效了。
  * 使用标准库规范
    * 管理数组实参的第二种技术是**传递指向数组首元素和尾后元素的指针**，这种方法受到 了标准库技术的启发
    * 为了调用这个函数，我们需要传入两个指针：**一个指向要输出的首元素，另一个指向尾元素的下一位置**
  * **显式传递一个表示数组大小的形参**
    * 专门定义一个表示数组大小的形参，在C程序和过去的 C++程序中常常使用这种方法

  ```c++
  void printArr(const int *p, int len) {
      for (int i = 0; i < len; ++i)
          cout << *(p+i) << '\t';
  }
  void printArr(const int *begin, const int *end) {
      while (begin != end)
          cout << *begin++ << '\t';
  }
  void printArr(const char *str) {
      if (str)
          while (*str)
              cout << *str++;
  }
  ```

* 数组形参和const
  
  * **当函数不需要对数组元素执行写操作的时候，数组 形参应该是指向const的指针。只有当函数确实要改变元素值 的时候，才把形参定义成指向非常量的指针。**
* 数组引用形参
  
* C++语言允许将变量定义成数组的引用，基于同样的道理, 形参也可以是数组的引用。此时，引用形参绑定到对应的实参上，也就是绑定到数组上
  
* 传递多维数组
  * 和所有数组一样，当**将多维数组传递给函数时，真正传递的是指向数组首元素的指针 **
  * 因为我们处理的是数组的数组，所以首元素本身就是一个数组， 指针就是一个指向数组的指针。数组第二维(以及后面所有维度)的大小都是数组类型的一部分，不能省略
  * 我们也可以使用数组的语法定义函数，此时编**译器会一如既往地忽略掉第一个维**度， 所以最好不要把它包括在形参列表内
* 含有可变形参的函数
  * 有时我们无法提前预知应该向函数传递几个实参。例如，我们想要编写代码输出程序 产生的错误信息，此时最好用同一个函数实现该项功能，以便对所有错误的处理能够整齐 划一。然而，错误信息的种类不同，所以调用错误输岀函数时传递的实参也各不相同。
  * 如果所有的实参类型相同，可以传递一个名为initializer_list的标准库类型；
  * 如果实参的 类型不同，我们可以编写一种特殊的函数，也就是所谓的可变参数模板

----

* 省略符形参应该仅仅用于C和C++通用的类型.特别应该注意的是，大多数类类型的时象在传递给省略符形参时都无法正确拷贝 

* 省略符形参只能出现在形参列表的最后一个位置

  ```
  void foo(type, ...);
  void foo(...);
  //第一种形式指定了 foo 函数的部分形参的类型，对应于这些形参的实参将会执行正常的类型检査。省略符形参所对应的实参无须类型检查。在第一种形式中，形参声明后而的逗号是可选的。
  ```

* 返回类型和return语句

  * return语句终止当前正在执行的函数并将控制权返回到调用该函数的地方。 return语句有两种形式：

    ```
    return;  //无返回值函数
    return expression;
    ```

* 无返回值函数

  * 没有返冋值的return语句只能用在返回类型是void的函数中。返回void的函数不要求非得有return语句，因为在这类函数的最后一句后面会隐式地执行return。
  * 通常情况下，void函数如果想在它的中间位置提前退出，可以使用return语句。 return的这种用法有点类似于我们用break语句退出循环。
  * 一个返回类型是void的函数也能使用return语句的第二种形式，不过此时return 语句的 expression 必须是另一个返回void的函数。强行令void函数返回其他类型的表 达式将产生编译错误。

* 有返回值函数

  * return语句的第二种形式提供了函数的结果。只要函数的返回类型不是void,则 该函数内的每条return语句必须返回一个值。**return语句返回值的类型必须与函数的返回类型相同，或者能隐式地转换成函数的返回类型。**
  * 尽管C++无法确保结果的正确性，但是可以保证每个return语句的结果类型正确。 也许无法顾及所有情况，但是编译器仍然尽量确保具有返回值的函数只能通过一条有效的 return语句退出。
  * 在含有return语句的循环后面应该也有条return语句，如果没有的话该 程序就是错误的、很多编译器都无法发现此类错误

* 值是如何被返回的

  * 返回一个值的方式和初始化一个变量或形参的方式完全一样：**返冋的值用于初始化调用点的一个临时量，该临时量就是函数调用的结果。**
  * 必须注意当函数返回局部变量时的初始化规则。同其他引用类型一样，**如果函数返回引用，则该引用仅是它所引对象的一个别名。否则，意味着返回值将被拷贝到调用点。**

* 不要返回局部对象的引用或指针

  * 函数完成后，它所占用的存储空间也随之被释放掉。因此，**函数终止意味着局部变量的引用将指向不再有效的内存区域(函数内的字面量也会转变为一个局部临时变量)**
  * 要想确保返回值安全，我们不妨提问：引用所引的是在函数之前已经存在的哪 个对象？
  * 如前所述，返冋局部对象的引用是错误的：同样，返冋局部对象的指针也是错误的。**一旦函数完成，局部对象被释放，指针将指向一个不存在的对象**

* 返回类类型的函数和调用运算符

  * 和其他运算符一样，调用运算符也有优先级和结合律。调用运算符的优先级与点运算符和箭头运算符相同，并且也符合左结合律。因此，如果函数返回指针、引用或类的对象，我们就能使用函数调用的结果访问结果对象的成员。

* 引用返回左值

  * **函数的返冋类型决定函数调用是否是左值。调用一个返回引用的函数得到左值，其他返回类型得到右值。可以像使用其他左值那样来使用返回引用的函数的调用，特别是，我们能为返回类型是非常量引用的函数的结果赋值**

* 列表初始化返回值

  * 初始化返回值
  * C++11新标准规定，函数可以返回花括号包围的值的列表。**类似其他返回结果，此处的列表也用来对表示函数返回的临时量进行初始化**。如果列表为空，临时量执行值初始化；否则，返回的值由函数的返回类型决定。

* 主函数main的返回值

  * 之前介绍过，如果函数的返回类型不是void,那么它必须返回一个值。但是这条规则有个例外：我们允许main函数没有return语句直接结束。如果控制到达了 main函数的结尾处而且没有return语句，编译器将隐式地插入一条返回0的return语句。
  * **main函数的返回值可以看做是状态指示器。返回0表示执行成功，返回其他值表示执行失败，其中非0值的具体含义依机器而定。为了使返回值与机器无关，cstdlib头文件定义了两个预处理变量，我们可以使用这两个变量分别表示成功与失败(EXIT_FAILURE, EXIT_SUCCESS)**

* 递归

  * 如果一个函数调用了它自身，不管这种调用是直接的还是间接的，都称该函数为递归函数(recursive function)
  * **在递归函数中，一定有某条路径是不包含递归调用的；否则，函数将“永远”递归下 去，换句话说，函数将不断地调用它自身直到程序栈空间耗尽为止。我们有时候会说这种 函数含有递归循环(recursion loop)**

* 返回数组指针

  * 因为**数组不能被拷贝，所以函数不能返回数组**。不过，函数可以返回数组的指针或引用。虽然从语法上来说，要想定义一个返回数组的指针或引用的函数比较烦琐，但是有一些方法可以简化这一任务，其中最直接的方法是使用类型别名

* 声明一个返回数组指针的函数

  * 要想在声明func时不使用类型别名，我们必须牢记被定义的名字后面数组的维度

  * 如果我们想定义一个返回数组指针的函数，则数组的维度必须跟在函数 名字之后。然而，函数的形参列表也跟在函数名字后面且形参列表应该先于数组的维度。 因此，返回数组指针的函数形式如下所示：

    `Type (*function (parameter) [dimension}`类似于其他数组的声明，Type表示元素的类型，dimension表示数组的大小。 (\*function(parameter_list))两端的括号必须存在。 如果没有这对括号，函数的返回类型将是指针的数组。

* 使用尾置返回类型

  * 可在C++11新标准中还有一种可以简化上述func声明的方法，就是使用尾置返回类型(trailing return type)。任何函数的定义都能使用尾置返回，但是这种形式对于返回类型比较复杂的函数最有效，比如返回类型是数组的指针或者数组的引用。**尾置返冋类型跟在形参列表后面并以一个->符号开头。为了表示函数真正的返回类型跟在形参列表之后，我们在本应该出现返回类型的地方放置一个auto**

    ```
    auto t()->int(*)[nums]; //返回指向数组的指针
    ```

* 使用 decltype

  * 还有一种情况，如果我们**知道函数返回的指针将指向哪个数组**，就可以使用 decltype关键字声明返回类型。

  * 使用关键字decltype表示它的返回类型是个指针，有一个地方需要注意：**decltype并不负责把数组类型转换成对应的指针，所以 decltype的结果是个数组，要想表示func返冋指针还必须在函数声明时加一个* 符号。**

    ```
    int nums[] = {1,2,3};
    decltype(nums) *t() {
    	// 返回指向int数组的指针
    }
    ```

* 函数重载

  * **如果同一作用域内的几个函数名字相同但形参列表不同，我们称之为重载(overloaded)函数。**
  * 这些函数接受的形参类型不一样，但是执行的操作非常类似。当调用这些函数时，**编译器会根据传递的实参类型推断想要的是哪个函数**
  * **函数的名字仅仅是让编译器知道它调用的是哪个函数，而函数重载可以在一定程度上减轻程序员起名字、记名字的负担。**
  * main函数不能重载
  * **对于重载的函数来说，它们应该在形参数量或形参类型上有所不同。**
  * **不允许两个函数除了返回类型外其他所有的要素都相同**。假设有两个函数，它们的形参列表一样但是返回类型不同，则第二个函数的声明是错误的
  * **形参的名字仅仅起到帮助记忆的作用，有没有它并不影响形参列表的内容**。
  * **类型別名为已存在的类型提供另外一个名字，它并不是创建新类型**。

* 重载和const形参

  * **顶层 const 不影响传入函数的对象。一个拥有顶层const的形参无法和另一个没有顶层const的形参区分开来**
  * 另一方面，**如果形参是某种类型的指针或引用，则通过区分其指向的是常量对象还是非常量对象可以实现函数重载，此时的const是底层的**

* 建议：何时不应该我

  * 尽管函数重载能在一定程度上减轻我们为函数起名字、记名字的负担，但是最好只重载那些确实非常相似的操作。有些情况下，给函数起不同的名字能使得程序更易理解。

* 调用重载的函数

  * 定义了一组重载函数后，我们需要以合理的实参调用它们。**函数匹配(function matching)是指一个过程，在这个过程中我们把函数调用与一组重载函数中的某一个关联起来，函数匹配也叫做重载确定(overload resolution)。编译器首先将调用的实参与重载集合中每一个函数的形参进行比较，然后根据比较的结果决定到底调用哪个函数。**
  * 在很多(可能是大多数)情况下，程序员很容易判断某次调用是否合法，以及当调用合法时应该调用哪个函数。通常，重载集中的函数区别明显，它们要不然是参数的数量不 同，要不就是参数类型毫无关系。此时，确定调用哪个函数比较容易。但是在另外一些情况下要想选择函数就比较困难了，比如当两个重载函数参数数量相同且参数类型可以相互转换时

* 现在我们需要掌握的是，当调用重载函数时有三种可能的结果：

  * 编译器找到一个与实参**最佳匹配(best match)**的函数，并生成调用该函数的代码。
  * 找不到任何一个函数与调用的实参匹配，此时编译器发出**无匹配(nomatch)**的错误信息。
  * 有多于一个函数可以匹配，但是每一个都不是明显的最佳选择。此时也将发生错误, 称为**二义性调用(ambiguouscall)**

* 重载与作用域

  * 重载对作用域的一般性质并没有什么改变：如果我们在内层作用域中声明名字，它将隐藏外层作用域中声明的同名实体。在不同的作用域中无法重载函数名

* **在C++语言中，名字查找发生在类型检查之前。**

