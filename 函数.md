* 省略符形参应该仅仅用于C和C++通用的类型.特别应该注意的是，大多数类类型的时象在传递给省略符形参时都无法正确拷贝 

* 省略符形参只能出现在形参列表的最后一个位置

  ```
  void foo(type, ...);
  void foo(...);
  //第一种形式指定了 foo 函数的部分形参的类型，对应于这些形参的实参将会执行正常的类型检査。省略符形参所对应的实参无须类型检查。在第一种形式中，形参声明后而的逗号是可选的。
  ```

* 返回类型和return语句

  * return语句终止当前正在执行的函数并将控制权返回到调用该函数的地方。 return语句有两种形式：

    ```
    return;  //无返回值函数
    return expression;
    ```

* 无返回值函数
  * 没有返冋值的return语句只能用在返回类型是void的函数中。返回void的函数不要求非得有return语句，因为在这类函数的最后一句后面会隐式地执行return。
  * 通常情况下，void函数如果想在它的中间位置提前退出，可以使用return语句。 return的这种用法有点类似于我们用break语句退出循环。
  * 一个返回类型是void的函数也能使用return语句的第二种形式，不过此时return 语句的 expression 必须是另一个返回void的函数。强行令void函数返回其他类型的表 达式将产生编译错误。

* 有返回值函数
  * return语句的第二种形式提供了函数的结果。只要函数的返回类型不是void,则 该函数内的每条return语句必须返回一个值。**return语句返回值的类型必须与函数的返回类型相同，或者能隐式地转换成函数的返回类型。**
  * 尽管C++无法确保结果的正确性，但是可以保证每个return语句的结果类型正确。 也许无法顾及所有情况，但是编译器仍然尽量确保具有返回值的函数只能通过一条有效的 return语句退出。
  * 在含有return语句的循环后面应该也有条return语句，如果没有的话该 程序就是错误的、很多编译器都无法发现此类错误
* 值是如何被返回的
  * 返回一个值的方式和初始化一个变量或形参的方式完全一样：**返冋的值用于初始化调用点的一个临时量，该临时量就是函数调用的结果。**
  * 必须注意当函数返回局部变量时的初始化规则。同其他引用类型一样，**如果函数返回引用，则该引用仅是它所引对象的一个别名。否则，意味着返回值将被拷贝到调用点。**
* 不要返回局部对象的引用或指针
  * 函数完成后，它所占用的存储空间也随之被释放掉。因此，**函数终止意味着局部变量的引用将指向不再有效的内存区域(函数内的字面量也会转变为一个局部临时变量)**
  * 要想确保返回值安全，我们不妨提问：引用所引的是在函数之前已经存在的哪 个对象？
  * 如前所述，返冋局部对象的引用是错误的：同样，返冋局部对象的指针也是错误的。**一旦函数完成，局部对象被释放，指针将指向一个不存在的对象**
* 返回类类型的函数和调用运算符
  * 和其他运算符一样，调用运算符也有优先级和结合律。调用运算符的优先级与点运算符和箭头运算符相同，并且也符合左结合律。因此，如果函数返回指针、引用或类的对象，我们就能使用函数调用的结果访问结果对象的成员。

* 引用返回左值

  * **函数的返冋类型决定函数调用是否是左值。调用一个返回引用的函数得到左值，其他返回类型得到右值。可以像使用其他左值那样来使用返回引用的函数的调用，特别是，我们能为返回类型是非常量引用的函数的结果赋值**

* 列表初始化返回值

  * 初始化返回值
  * C++11新标准规定，函数可以返回花括号包围的值的列表。**类似其他返回结果，此处的列表也用来对表示函数返回的临时量进行初始化**。如果列表为空，临时量执行值初始化；否则，返回的值由函数的返回类型决定。

* 主函数main的返回值

  * 之前介绍过，如果函数的返回类型不是void,那么它必须返回一个值。但是这条规则有个例外：我们允许main函数没有return语句直接结束。如果控制到达了 main函数的结尾处而且没有return语句，编译器将隐式地插入一条返回0的return语句。
  * **main函数的返回值可以看做是状态指示器。返回0表示执行成功，返回其他值表示执行失败，其中非0值的具体含义依机器而定。为了使返回值与机器无关，cstdlib头文件定义了两个预处理变量，我们可以使用这两个变量分别表示成功与失败(EXIT_FAILURE, EXIT_SUCCESS)**

* 递归

  * 如果一个函数调用了它自身，不管这种调用是直接的还是间接的，都称该函数为递归函数(recursive function)
  * **在递归函数中，一定有某条路径是不包含递归调用的；否则，函数将“永远”递归下 去，换句话说，函数将不断地调用它自身直到程序栈空间耗尽为止。我们有时候会说这种 函数含有递归循环(recursion loop)**

* 返回数组指针

  * 因为**数组不能被拷贝，所以函数不能返回数组**。不过，函数可以返回数组的指针或引用。虽然从语法上来说，要想定义一个返回数组的指针或引用的函数比较烦琐，但是有一些方法可以简化这一任务，其中最直接的方法是使用类型别名

* 声明一个返回数组指针的函数

  * 要想在声明func时不使用类型别名，我们必须牢记被定义的名字后面数组的维度

  * 如果我们想定义一个返回数组指针的函数，则数组的维度必须跟在函数 名字之后。然而，函数的形参列表也跟在函数名字后面且形参列表应该先于数组的维度。 因此，返回数组指针的函数形式如下所示：

    `Type (*function (parameter) [dimension}`类似于其他数组的声明，Type表示元素的类型，dimension表示数组的大小。 (\*function(parameter_list))两端的括号必须存在。 如果没有这对括号，函数的返回类型将是指针的数组。

* 使用尾置返回类型

  * 可在C++11新标准中还有一种可以简化上述func声明的方法，就是使用尾置返回类型(trailing return type)。任何函数的定义都能使用尾置返回，但是这种形式对于返回类型比较复杂的函数最有效，比如返回类型是数组的指针或者数组的引用。**尾置返冋类型跟在形参列表后面并以一个->符号开头。为了表示函数真正的返回类型跟在形参列表之后，我们在本应该出现返回类型的地方放置一个auto**

    ```
    auto t()->int(*)[nums]; //返回指向数组的指针
    ```

* 使用 decltype

  * 还有一种情况，如果我们**知道函数返回的指针将指向哪个数组**，就可以使用 decltype关键字声明返回类型。

  * 使用关键字decltype表示它的返回类型是个指针，有一个地方需要注意：**decltype并不负责把数组类型转换成对应的指针，所以 decltype的结果是个数组，要想表示func返冋指针还必须在函数声明时加一个* 符号。**

    ```
    int nums[] = {1,2,3};
    decltype(nums) *t() {
    	// 返回指向int数组的指针
    }
    ```

* 函数重载

  * **如果同一作用域内的几个函数名字相同但形参列表不同，我们称之为重载(overloaded)函数。**
  * 这些函数接受的形参类型不一样，但是执行的操作非常类似。当调用这些函数时，**编译器会根据传递的实参类型推断想要的是哪个函数**
  * **函数的名字仅仅是让编译器知道它调用的是哪个函数，而函数重载可以在一定程度上减轻程序员起名字、记名字的负担。**
  * main函数不能重载
  * **对于重载的函数来说，它们应该在形参数量或形参类型上有所不同。**
  * **不允许两个函数除了返回类型外其他所有的要素都相同**。假设有两个函数，它们的形参列表一样但是返回类型不同，则第二个函数的声明是错误的
  * **形参的名字仅仅起到帮助记忆的作用，有没有它并不影响形参列表的内容**。
  * **类型別名为已存在的类型提供另外一个名字，它并不是创建新类型**。

* 重载和const形参

  * **顶层 const 不影响传入函数的对象。一个拥有顶层const的形参无法和另一个没有顶层const的形参区分开来**
  * 另一方面，**如果形参是某种类型的指针或引用，则通过区分其指向的是常量对象还是非常量对象可以实现函数重载，此时的const是底层的**

* 建议：何时不应该我

  * 尽管函数重载能在一定程度上减轻我们为函数起名字、记名字的负担，但是最好只重载那些确实非常相似的操作。有些情况下，给函数起不同的名字能使得程序更易理解。

* 调用重载的函数

  * 定义了一组重载函数后，我们需要以合理的实参调用它们。**函数匹配(function matching)是指一个过程，在这个过程中我们把函数调用与一组重载函数中的某一个关联起来，函数匹配也叫做重载确定(overload resolution)。编译器首先将调用的实参与重载集合中每一个函数的形参进行比较，然后根据比较的结果决定到底调用哪个函数。**
  * 在很多(可能是大多数)情况下，程序员很容易判断某次调用是否合法，以及当调用合法时应该调用哪个函数。通常，重载集中的函数区别明显，它们要不然是参数的数量不 同，要不就是参数类型毫无关系。此时，确定调用哪个函数比较容易。但是在另外一些情况下要想选择函数就比较困难了，比如当两个重载函数参数数量相同且参数类型可以相互转换时

* 现在我们需要掌握的是，当调用重载函数时有三种可能的结果：

  * 编译器找到一个与实参**最佳匹配(best match)**的函数，并生成调用该函数的代码。
  * 找不到任何一个函数与调用的实参匹配，此时编译器发出**无匹配(nomatch)**的错误信息。
  * 有多于一个函数可以匹配，但是每一个都不是明显的最佳选择。此时也将发生错误, 称为**二义性调用(ambiguouscall)**

* 重载与作用域

  * 重载对作用域的一般性质并没有什么改变：如果我们在内层作用域中声明名字，它将隐藏外层作用域中声明的同名实体。在不同的作用域中无法重载函数名

* **在C++语言中，名字查找发生在类型检查之前。**