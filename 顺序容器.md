* ** 一个容器就是一些特定类型对象的集合。**
* 所有容器类都共享公共的接口，不同容器按不同方式对其进行扩展。这个公共接口使容器的学习更加容易——我们基于某种容器所学习的内容也都适用于其他容器。每种容器都提供了不同的性能和功能的权衡。
* **顺序容器(sequential container)为程序员提供了控制元素存储和访问顺序的能力**。这种顺序不依赖于元素的值，而是与元素加入容器 时的位置相对应。与之相对的，有序和无序关联容器，则根据关键字的值来存储元素。

#### 顺序容器概述

* 所有顺序容器都提供了快速顺序访问元素的能力。 但是，这些容器在以下方面都有不同的性能折中：
  * 向容器添加或从容器中删除元素的代价
  * 非顺序访问容器中元素的代价

* 固定大小的array外，其他容器都提**供高效、灵活的内存管理**。我们可以添加和删除元素，扩张和收缩容器的大小。容器保存元素的策略对容器操作的效率有着固有的， 有时是重大的影响。在某些情况下，存储策略还会影响特定容器是否支持特定操作。
  * 例如，string和vector将元素保存在连续的内存空间中。由于元素是连续存储的，由元素的下标来计算其地址是非常快速的。但是，在这两种容器的中间位置添加或删除元素就会非常耗时：在一次插入或删除操作后，需要移动插入/删除位置之后的所有元素， 来保持连续存储。而且，添加一个元素有时可能还需要分配额外的存储空间。在这种情况 下，每个元素都必须移动到新的存储空间中。
  * list和forward_list两个容器的设计目的是令容器任何位置的添加和删除操作都很快速。作为代价，这两个容器不支持元素的随机访问：为了访问一个元素，我们只能遍历整个容器。而且，与vector、deque和array相比，这两个容器的额外内存开销也很大。
  * deque是一个更为复杂的数据结构。与string和vector类似，deque支持快速的随机访问。与string和vector 一样在deque的中间位置添加或删除元素的代价 （可能）很高。但是，在deque的两端添加或删除元素都是很快的，与list或 forward_list添加删除元素的速度相当。
  * forward_list和array是新C++标准增加的类型。与内置数组相比，array是一种更安全、更易使用的数组类型。与内置数组类似，array对象的大小是固定的。因此，array不支持添加和删除元素以及改变容器大小的操作。forward_list的设计目标是达到与最好的手写的单向链表数据结构相当的性能。因此，forward_list没有size 操作，因为保存或计算其大小就会比手写链表多出额外的开销。对其仙容器而言，size 保证是一个快速的常量时间的操作
* 确定使用哪种顺序容器
  * 除非你有很好的理由选择其他容器，否则应使用vector
  * 如果你的程序有很多小的元素，且空间的额外开销很重要，则不要使用list或forward_list （空间利用率较低）
  * 如果程序要求随机访问元素，应使用vector或deque
  * 如果程序要求在容器的中间插入或删除元素，应使用丄ist或forward_list
  * 如果程序需要在头尾位置插入或删除元素，但不会在中间位置进行插入或删除操作，则使用deque
  * 如果程序只有在读取输入时才需要在容器中间位置插入元素，随后需要随机访问元素，则
    * 首先，确定是否真的需要在容器中间位置添加元素。当处理输入数据时，通常可以很容易地向vector追加数据，然后再调用标准库的sort函数（来重排容器中的元素，从而避免在中间位置添加元素。
    * 如果必须在中间位置插入元素，考虑在输入阶段使用list, 一旦输入完成，将 list中的内容拷贝到一个vector中
  * 如果你不确定应该使用哪种容器，那么可以在程序中只使用vector和list 公共的操作：**使用迭代器，不使用下标操作，避免随机访问。**这样，在必要时选择使用vector或list都很方便

#### 容器库概览

* 容器类型上的操作形成了一种层次：
  * 某些操作是所有容器类型都提供的。
  * 另外一些操作仅针对顺序容器、关联容器或无序容器。
  * 还有一些操作只适用于一小部分容器。

* 一般来说，每个容器都定义在一个头文件中，文件名与类型名相同。即，deque定义 在头文件deque中，list定义在头文件list中，以此类推。容器均定义为模板类。例如对vector,我们必须提供额外信息来生成特定的容器类型。 对大多数，但不是所有容器，我们还需要额外提供元素类型信息
* 对容器可以保存的元素类型的限制
  
  * 顺序容器几乎可以保存任意类型的元素。特别是，我们可以定义一个容器，其元素的类型是另一个容器。这种容器的定义与任何其他容器类型完全一样：在尖括号中指定元素类型
* 迭代器
  
* 与容器一样，迭代器有着公共的接口：如果一个迭代器提供某个操作，那么所有提供相同操作的迭代器对这个操作的实现方式都是相同的。例如，标准容器类型上的所有迭代 器都允许我们访问容器中的元素，而所有迭代器都是通过解引用运算符来实现这个操作 的。类似的，标准库容器的所有迭代器都定义了递增运算符，从当前元素移动到下一个元素。
  
* 迭代器范围
  * 迭代器范围的概念是标准库的基础。
  * **一个迭代器范围（iterator range）由一对迭代器表示**，**两个迭代器分别指向同一个容器中的元素或者是尾元素之后的位置（one past the last element)**。这两个迭代器通常被称 为begin和end,或者是first和 last （可能有些误导），它们标记了容器中元素的一 个范围。
  * 虽然第二个迭代器常常被称为last,但这种叫法有些误导，因为第二个迭代器从来都不会指向范围中的最后一个元素，而是指向尾元素之后的位置。迭代器范围中的元素包含 first 所表示的元素以及从 first 开始直至 last （但不包含last）之间的所有元素。（ [begin， end) ）
  * 表示范围自begin开始，于end之前结束。**迭代器begin和end必须指向相同的容器**。 end可以与begin指向相同的位置，但不能指向begin之前的位置。

* 对构成范围的迭代器的要求

  * **它们指向同一个容器中的元素，或者是容器最后一个元素之后的位置，且我们可以通过反复递增begin来到达end**。换句话说，end不在begin之前。
  * 编译器不会强制这些要求。确保程序符合这些约定是程序员的责任

* 使用左闭合范围蕴含的编程假定

  * 标准库使用左闭合范围是因为这种范围有三种方便的性质。假定begin和end构成 一个合法的迭代器范围，则

  1. 如果begin与end相等，则范围为空

  2. 如果begin与end不等，则范围至少包含一个元素，且begin指向该范围中的 第一个元素
  3. 我们可以对begin递增若干次，使得 begin=end
  4. 这些性质意味着我们可以像下面的代码一样用一个循环来处理一个元素范围，而这是安全的：

  ```c++
  auto s = iv.begin(), e = iv.end();
  while (s != e)
      cout << *s++ << endl;
  ```

* 容器类型成员
  * 每个容器都定义了多个类型，我们已经使用过其中三种： size_type 、iterator 和 const_iterator 。
  * 除了已经使用过的迭代器类型，大多数容器还提供反向迭代器。简单地说，**反向迭代器就是一种反向遍历容器的迭代器，与正向迭代器相比，各种操作的含义也都发生了颠倒**。
  * **通过类型别名，我们可以在不了解容器中元素类型的情况下使用它**。如果需要元素类型，可以使用容器的value_type。如果需要元素类型的一个引 用，可以使用reference或const_reference。这些元素相关的类型别名在泛型编程中非常有用
* begin 和 end 成员
  * begin和end操作生成**指向容器中第一个元素**和**尾元素之后位置的迭代器**。这两个迭代器最常见的用途是形成一个包含容器中所有元素的迭代器范围。
  * 当不需要写访问时，应使用cbegin和cend。
* 容器定义和初始化
  * 每个容器类型都定义了一个默认构造函数。除array之 外，其他容器的默认构造函数都会创建一个指定类型的空容器，且都可以接受指定容器大小和元素初始值的参数。
  * **只有顺序容器（不包括array）的构造函数才能接受大小参数**
* 将一个容器初始化为另一个容器的拷贝
  * 将一个新容器创建为另一个容器的拷贝的方法有两种：可以**直接拷贝整个容器**，或者（array除外）**拷贝由一个迭代器对指定的元素范围**。
  * 为了创建一个容器为另一个容器的拷贝，两个容器的类型及其元素类型必须匹配。不过，**当传递迭代器参数来拷贝一个范围时，就不要求容器类型是相同的了。而且，新容器 和原容器中的元素类型也可以不同，只要能将要拷贝的元素转换为要初始化的容器的元素类型即可。**
  * 接受两个迭代器参数的构造函数用这两个迭代器表示我们想要拷贝的一个元素范围。 与以往一样，两个迭代器分别标记想要拷贝的第一个元素和尾元素之后的位置。**新容器的大小与范围中元素的数目相同。新容器中的每个元素都用范围中对应元素的值进行初始化。**
  * 由于两个迭代器表示一个范围，因此可以使用这种构造函数来拷贝一个容器中的子序列。
* 与顺序容器大小相关的构造函数
  * 除了与关联容器相同的构造函数外，顺序容器（array除外）还提供另一个构造函数, 它接受一个容器大小和一个（可选的）元素初始值。如果我们不提供元素初始值，则标准 库会创建一个值初始化器
  * 如果元素类型是内置类型或者是具有默认构造函数的类类型，可以只为构造函数提供一个容器大小参数。**如果元素类型没有默认构造函数，除了大小参数外，还必须指定一个显式的元素初始值。**
  * **只有顺序容器的构造函数才接受大小参数，关联容器并不支持。**
* 标准库array具有固定大小
  * 与内置数组一样，标准库array的大小也是类型的一部分。当定义一个array时， 除了指定元素类型，还要指定容器大小
  * **数组类型包括元素类型和大小**
  * 与其他容器不同，**一个默认构造的array是非空的**：它包含了与其大小一样多的元素。这些元素都被默认初始化，就像一个内置数组中的元素那样。如果我们对array进行**列表初始化**，初始值的数目必须等于或小于array的大小。 如果初始值数目小于array的大小，则它们被用来初始化array中靠前的元素，所有剩 余元素都会进行**值初始化**。在这两种情况下，如果元素类型是一个类类型，那么该类必须有一个默认构造函数，以使值初始化能够进行. 值得注意的是，**虽然我们不能对内置数组类型进行拷贝或对象赋值操作但array并无此限制**. 与其他容器一样,array也要求初始值的类型必须与要创建的容器类型相同。此外,array 还要求元素类型和大小也都一样，因为大小是array类型的一部分。
* 赋值和swap
  * **赋值运算符将其左边容器中的 全部元素替换为右边容器中元素的拷贝**
  * 与内置数组不同，标准库array类型允许赋值。赋值号左右两边的运算对象必须具有相同的类型和大小
* 容器大小操作
  
  * 除了一个例外，每个容器类型都有三个与大小相关的操作。成员函数size返回容器中元素的数目；empty当size为0时返回布尔值true,否则 返回false； max_size返回一个大于或等于该类型容器所能容纳的最大元素数的值。**forward_list支持max_size和empty,但不支持size**
* 关系运算符
  
  * 每个容器类型都支持相等运算符（==和!=）；除了无序关联容器外的所有容器都支持关系运算符（＞、＞=、＜、＜=）。关系运算符左右两边的运算对象必须是相同类型的容器， 且必须保存相同类型的元素。
* 比较两个容器实际上是进行元素的逐对比较。这些运算符的工作方式与string的关系运算类似：
  * 如果两个容器具有相同大小且所有元素都两两对应相等，则这两个容器相等；否则两个容器不等。
  * 如果两个容器大小不同，但较小容器中每个元素都等于较大容器中的对应元素，则较小容器小于较大容器。
  * 如果两个容器都不是另一个容器的前缀子序列，则它们的比较结果取决于第一个不相等的元素的比较结果。
* **容器的关系运算符使用元素的关系运算符完成比较**
  * 只有当其元素类型也定义了相应的比较运算符时，我们才可以使用关系运算符来比较两个容器。
  * 容器的相等运算符实际上是使用元素的==运算符实现比较的，而其他关系运算符是使用元素的 < 运算符。如果元素类型不支持所需运算符，那么保存这种元素的容器就不能使用相应的关系运算。

#### 顺序容器操作

* 顺序容器和关联容器的不同之处在于两者组织元素的方式。这些不同之处直接关系到了元素如何存储、访问、添加以及删除。

* 向顺序容器添加元素
  * 除array外，所有标准库容器都提供灵活的内存管理。在运行时可以动态添加或删除元素来改变容器大小。
  * 当我们使用这些操作时，必须记得**不同容器使用不同的策略来分配元素空间**，而这些策略直接影响性能。在一个vector或string的尾部之外的任何位置，或是一个deque 的首尾之外的任何位置添加元素，都需要移动元素。而且，向一个vector或string添加元素可能引起整个对象存储空间的重新分配。重新分配一个对象的存储空间需要分配新 的内存，并将元素从旧的空间移动到新的空间中。
* **向一个vector , string或deque插入元素会使所有指向容器的迭代器、引用和指针失效**

* 关键概念：**容器元素是拷贝**
  * 当我们用一个对象来初始化容器时，或将一个对象插入到容器中时，实际上放入到容器中的是对象值的一个拷贝，而不是对象本身。就像我们将一个对象传递给非引用参数一样，容器中的元素与提供值的对象之间没有任何关联。 随后对容器中元素的任何改变都不会影响到原始对象，反之亦然。

* **emplace函数的参数根据元素类型而变化，参数必须与元素类型的构造函数相匹配**

* 访问元素
  * 包括array在内的每个顺序容器都有一个front成员函数，而除forward_list 之外的所有顺序容器都有一个back成员函数。这两个操作分别返回首元素和尾元素的引用
  * 两种不同方式来获取c中的首元素和尾元素的引用。直接的方法是调用front 和back。而间接的方法是通过解引用begin返回的迭代器来获得首元素的引用，以及通过递减然后解引用end返回的迭代器来获得尾元素的引用。
  * **迭代器end指向的是容器尾元素之后的(不存在的)元素。为了获取尾元素，必须首先递减此迭代器。另一个重要之处是，在调用front和back （或解引用begin和end返回的迭代器）之前，要确保容器非空。**
  * at 和下标操作只适用于string、vector， deque 和 array。 
  * **对一个空容器调用front和back,就像使用一个越界的下标一样，是一 种严重的程序设计错误。**
* 访问成员函数返回的是引用
  * **在容器中访问元素的成员函数（即，front、back、下标和at）返回的都是引用**。 如果容器是一个const对象，则返回值是const的引用。如果容器不是const的，则 返回值是普通引用，我们可以用来改变元素的值
* 下标操作和安全的随机访问
  * 提供快速随机访问的容器（string、vector、deque和array）也都提供下标运算符。就像我们已经看到的那样，下标运算符接受一个下标参数，返冋容器中该位置的元素的引用。**给定下标必须"在范围内”（即，大于等于0,且小 于容器的大小）。保证下标有效是程序员的责任，下标运算符并不检査下标是否在合法范 围内。使用越界的下标是一种严重的程序设计错误，而且编译器并不检査这种错误。**
  * 如果我们希望确保下标是合法的，可以使用at成员函数。at成员函数类似下标运算符，但如果下标越界，at会抛出一个。out_of_range  异常
* 删除元素
  * 与添加元素的多种方式类似，(非array)容器也有多种删除元素的方式。
  * **这些操作会改变容器的大小，所以不适用于array.**
  * **forward_list有特殊版本的erase。 forward_list 不支持 pop_back; vector 和 string 不支持 pop_front**
  * 删除deque中除首尾位置之外的任何元素都会使所有迭代器、引用和指针失效. **指向vector或string中删除点之后位置的迭代器、引用和指针都会失效**
  * **删除元素的成员函数并不检查其参数。在删除元素之前，程序员必须确保它(们)是存在的。**
  * **与元素访问成员函数类似，不能弟一个空容器执行弹岀操作。**
  * 这些操作返回void. 如果你需要弹出的元素的值，就必须在执行弹出操作之前保存它
  * 从容器内部删除一个元素
    * 成员函数erase从容器中指定位置删除元素。我们可以删除由一个迭代器指定的单个元素，也可以删除由一对迭代器指定的范围内的所有元素。两种形式的erase都返回指向删除的(最后一个)元素之后位置的迭代器。即，若j是i之后的元素，那么erase (i) 将返回指向j的迭代器。

* 特殊的forward_list操作
  * 当添加或删除一个元素时，删除或添加的元素之前的那个元素的后继会发生改变。为 了添加或删除一个元素，我们需要访问其前驱，以便改变前驱的链接。但是， **forward_list是单向链表。在一个单向链表中，没有简单的方法来获取一个元素的前驱。出于表个原因，在一个forward_list中添加或删除元素的操作是通过改变给定元素之后的元素来完成的**。这样，可以访问到被添加或删除操作所影响的元素。
  * 由于这些操作与其他容器上的操作的实现方式不同，forward_list并未定义 insert, emplace 和 erase, 而是定义了名为 insert_after、emplace_after 和 erase_after的操作。例如，在我们的例子中，为了删除elem, 应该用指向 elem的迭代器调用erase_after.为了支持这些操作，forward_list也定义了before_begin,它返回一个**首前（off-the-beginning）迭代器**。这个迭代器允许我们在链表首元素之前并不存在的元素"之后”添加或删除元素（亦即在链表首元素之前添加删除元素）。
  * **当在forward_list中添加或删除元素时，我们必须关注两个迭代器	个指向我们要处理的元素，另一个指向其前驱。**

* 改变容器大小
  * 我们可以用resize来增大或缩小容器，与往常一样，array不支 持resize。**如果当前大小大于所要求的大小，容器后部的元素会被删除；如果当前大小小于新大小，会将新元素添加到容器后部**
  * resize操作接受一个可选的元素值参数，用来初始化添加到容器中的元素。如果调用者未提供此参数，新元素进行值初始化。如果容器保存的是类类型元素，且resize向容器添加新元素，则我们必须提供初始值，或者元素类型必须提供 一个默认构造函数。
  * 如果resize缩小容器，则指向被删除元素的迭代器、引用和指针都会失效；对vectors string或deque进行resize可能导致迭代器、指针 和引用失效
* 容器操作可能使迭代器失效
  * 向容器中添加元素和从容器中删除元素的操作可能会使指向容器元素的指针、引用或 迭代器失效。一个失效的指针、引用或迭代器将不再表示任何元素。使用失效的指针、引用或迭代器是一种严重的程序设计错误，很可能引起与使用未初始化指针一样的问题
  * 在向容器添加元素后：
    * 如果容器是vector或string,且存储空间被重新分配，则指向容器的迭代器、 指针和引用都会失效。如果存储空间未重新分配，指向插入位置之前的元素的迭代 器、指针和引用仍有效，但指向插入位置之后元素的迭代器、指针和引用将会失效。
    * 对于deque,插入到除首尾位置之外的任何位置都会导致迭代器、指针和引用失效。如果在首尾位置添加元素，迭代器会失效，但指向存在的元素的引用和指针不会失效。
    * 对于list和forward_list,指向容器的迭代器（包括尾后迭代器和首前迭代器）、指针和引用仍有效。
  * 当我们从一个容器中删除元素后，指向被删除元素的迭代器、指针和引用会失效，这 应该不会令人惊讶。毕竟，这些元素都已经被销毁了。当我们删除一个元素后：
    * 对于list和forward_list,指向容器其他位置的迭代器（包括尾后迭代器和 首前迭代器）、引用和指针仍有效。
    * 对于deque,如果在首尾之外的任何位置删除元素，那么指向被删除元素外其他 元素的迭代器、引用或指针也会失效。如果是删除deque的尾元素，则尾后迭代器也会失效，但其他迭代器、引用和指针不受影响；如果是删除首元素，这些也不 会受影响。
    * 对于vector和string,指向被删元素之前元素的迭代器、引用和指针仍有效。 注意：当我们删除元素时，尾后迭代器总是会失效。
  * **使用失效的迭代器、指针或引用是严重的运行时错误。**
* 建议：管理迭代器
  * 当你使用迭代器（或指向容器元素的引用或指针）时，最小化要求迭代器必须保持有效 的程序片段是一个好的方法。
  * 由于向迭代器添加元素和从迭代器删除元素的代码可能会使迭代器失效，因此必须保证每次改变容器的操作之后都正确地重新定位迭代器。这个建议对vector 、string 和deque尤为重要。
* 编写改变容器的循环程序
  * 添加/删除vector、string或deque元素的循环程序必须考虑迭代器、引用和指针可能失效的问题。程序必须保证每个循环步中都更新迭代器、引用或指针。如果循环中调用的是insert或erase,那么更新迭代器很容易。这些操作都返回迭代器
* 不要保存end返回的迭代器
  * **当我们添加/删除vector或string的元素后，或在deque中首元素之外任何位置添加/删除元素后，原来end返回的迭代器总是会失效。**因此，添加或删除元素的循环程 序必须反复调用end,而不能在循环之前保存end返回的迭代器，一直当作容器末尾使 用。通常C++标准库的实现中end()操作都很快，部分就是因为这个原因。
  * **保存尾迭代器的值是一个坏主意**
* vector对象是如何增长的
  * 为了支持快速随机访问，vector将元素连续存储——每个元素紧挨着前一个元素存储。通常情况下，我们不必关心一个标准库类型是如何实现的，而只需关心它如何使用。 然而，对于vector和string,其部分实现渗透到了接口中。
  * 假定容器中兀素是连续存储的，且容器的大小是可变的，考虑向vector或string 中添加元素会发生什么：如果没有空间容纳新元素，容器不可能简单地将它添加到内存中 其他位置——因为元素必须连续存储。容器必须分配新的内存空间来保存已有元素和新元 素，将已有元素从旧位置移动到新空间中，然后添加新元素，释放旧存储空间。如果我们 每添加一个新元素，vector就执行一次这样的内存分配和释放操作，性能会慢到不可接受。
  * 为了避免这种代价，标准库实现者采用了可以减少容器空间重新分配次数的策略。当＜356^ 不得不获取新的内存空间时，vector和string的实现通常会分配比新的空间需求更大 的内存空间。容器预留这些空间作为备用，可用来保存更多的新元素。这样，就不需要每 次添加新元素都重新分配容器的内存空间了。
  * 这种分配策略比每次添加新元素时都重新分配容器内存空间的策略要高效得多。其实 际性能也表现得足够好——虽然vector在每次重新分配内存空间时都要移动所有元素， 但使用此策略后，其扩张操作通常比list和deque还要快。
* 管理容量的成员函数
  * vector和string类型提供了一些成员函数，允许我们与它的实现中内存分配部分互动。 capacity操作告诉我们容器在不扩张内存空间的情况下可以容纳多少个元素。reserve操作允许我们通知容器它应该准备保存多少个元素。
  * 只有当需要的内存空间超过当前容量时，reserve 调用才会改变vector的容量。如果需求大小大于当前容量，reserve 至少分配与需求一样大的内存空间(可能更大)。如果需求大小小于或等于当前容量，reserve什么也不做。特别是，当需求大小小 于当前容量时，容器不会退回内存空间。因此，在调用reserve之后，capacity将会 大于或等于传递给reserve的参数。这样，**调用reserve永远也不会减少容器占用的内存空间**。类似的，**resize成员函数只改变容器中元素的数目，而不是容器的容量**。我们同样不能使用resize来减少容器预留的内存空间。
  * 在新标准库中，我们可以调用shrink_to_fit来要求deque， vector或string 退回不需要的内存空间。此函数**指出我们不再需要任何多余的内存空间**。但是，具体的实现可以选择忽略此请求。也就是说，调用shrink_to_fit也并不保证一定退回内存空间。
* capacity和size
  * 理解capacity和size的区别非常重要。**容器的size是指它已经保存的元素的数 目；而capacity则是在不分配新的内存空间的前提下它最多可以保存多少元素。**
  * 实际上，只要没有 操作需求超出vector的容量，vector就不能重新分配内存空间。
  * **每个vector实现都可以选择自己的内存分配策略。但是必须遵守的一条原则 是：只有当迫不得已时才可以分配新的内存空间。**
  * 