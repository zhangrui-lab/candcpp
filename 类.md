* 我们**使用类定义自己的数据类型.通过定义新的类型来反映待解决问题中的各种概念**，可以使我们更容易编写、调试和修改程序。
* **数据抽象**能帮助我们将对象的具体实现与对象所能执行的操作分离开来。
* 类的基本思想是**数据抽象（data abstraction）**和**封装（encapsulation）**。数据抽象是一种依赖于**接口（interface）和实现（implementation）分离的编程（以及设计）技术**。类的接口包括用户所能执行的操作：类的实现则包括类的数据成员、负责接口实现的函数体以及定义类所需的各种私有函数。
* **封装实现了类的接口和实现的分离。封装后的类隐藏了它的实现细节，也就是说，类的用户只能使用接口而无法访问实现部分。**
* 类要想实现数据抽象和封装，需要首先定义一个**抽象数据类型（abstract data type）**。在抽象数据类型中，由**类的设计者负责考虑类的实现过程：使用该类的程序员则只需要抽象地思考类型做了什么，而无须了解类型的工作细节。**

#### 定义抽象数据类型

* **关键概念：不同的编程角色 **

  * 程序员们常把运行其程序的人称作用户（user）。类似的’类的设计者也是为其用户设计并实现一个类的人；显然，**类的用户是程序员，而非应用程序的最终使用者**。
  * 当我们提及"用户” 一词时，不同的语境决定了不同的含义。如果我们说用户代码或者类的用户，指的是使用类的程序员；如果我们说书店应用程序的用户，则意指运行该应用程序的书店经理。
  * C++程序员们无须刻意区分应用程序的用户以及类的用户。在一些简单的应用程序中，类的用户和类的设计者常常是同一个人。尽管如此，还是**最好把角色区分开来**。当我们**设计类的接口时，应该考虑如何才能使得类易于使用； 而当我们使用类时，不应该顾及类的实现机理。**
  * 要想开发一款成功的应用程序，其作者必须充分了解并实现用户的需求。同样，优秀的类设计者也应该密切关注那些有可能使用该类的程序员的需求。**作为一个设计良好的类，既要有直观且易于使用的接口也必须具备高效的实现过程。**

* 定义和声明成员函数的方式与普通函数差不多。成员函数的声明必须在类的内部，它的定义则既可以在类的内部也可以在类的外部。**作为接口组成部分的非成员函数，它们的定义和声明都在类的外部。**

* **定义在类内部的函数是隐式的inline函数**

* 定义成员函数

  * 尽管所有成员都必须在类的内部声明，但是成员函数体可以定义在类内也可以定义在类外。

* 引入this

  * 对成员函数的调用，我们使用了点运算符来访问对象的成员， 然后调用它。当我们调用成员函数时，实际上是在替某个对象调用它。**成员函数通过一个名为this的额外的隐式参数来访问调用它的那个对象**。当我们调 用一个成员函数时，用请求该函数的对象地址初始化this。**编译器负责把对象的地址传递给对象被调成员函数的隐式形参this.**
  * 在成员函数内部，我们可以直接使用调用该函数的对象的成员，而无须通过成员访问运算符来做到这一点，因为this所指的正是这个对象。**任何对类成员的直接访问都被看作this的隐式引用**
  * 对于我们来说，this形参是隐式定义的。实际上，任何自定义名为this的参数或 变量的行为都是非法的。
  * 因为this的目的总是指向“这个”对象，所以**this是一个常量指针**，我们不允许改变this中保存的地址。

* 引入const成员函数

  * 默认情况下, **this的类型是指向类类型非常量版本的常量指针**。尽管this是隐式的，但它仍然需要遵循初始化规则，意味着(在默认情况下)**我们不能把this绑定到一个常量对象上**。这一情况也就使得我们不能在一个常量对象上调用普通的成员函数。
  * **如果被调成员函数是一个普通函数而且this是一个普通的指针参数，则我们应该把this 声明成`const Class *const`**。毕竟，在被调成员函数的函数体内不会改变this所指的对象，所以把this疫置为指向常量的指针有助于提高函数的灵活性。然而，this是隐式的并且不会出现在参数列表中，所以在哪儿将this声明成指向 常量的指针就成为我们必须面对的问题。
  * C++语言的做法是允许把const关键字放在成员函数的参数列表之后，此时，紧跟在参数列表后面的const表示this是一个指向常量的指针。像这样使用const的成员函数被称作**常量成员函数(const member function)**。
  * **常量对象，以及常量对象的引用或指针都只能调用常量成员函数。**

* 类作用域和成员函数

  * **类本身就是一个作用域**。类的 成员函数的定义嵌套在类的作用域之内
  * 编译器分两步处理类：**首先编译成员的声明，然后才轮到成员函数体**(如果有的话)。因此，成员函数体可以随意使用类中的 其他成员而无须在意这些成员出现的次序。

* 在类的外部定义成员函数

  * 像其他函数一样，当我们**在类的外部定义成员函数时，成员函数的定义必须与它的声明匹配**。也就是说，返回类型、参数列表和函数名都得与类内部的声明保持一致。如果成员被声明成常量成员函数，那么它的定义也必须在参数列表后明确指定const属性。同时，**类外部定义的成员的名字必须包含它所属的类名**
  * ::, 作用域运算符来说明如下的事实:我们定义了的函数被声明在类Class的作用域内。一旦编译器看到这个函数名，就能理解剩余的代码是位于类的作用域的。

* 定义一个返回this对象的函数

  ```
  return *this;
  ```

* 定义类相关的非成员函数

  * **类的作者常常需要定义一些辅助函数。尽管这些函数定义的操作从概念上来说属于类的接口的组成部分，但它们实际上并不属于类本身。**
  * 定义非成员函数的方式与定义其他函数一样，通常把函数的声明和定义分离开来。如果**函数在概念上属于类但是不定义在类中，则它一般应与类声明(而非定义)在同一个头文件内**。在这种方式下，用户使用接口的任何部分都只需要引入一个文件。
  * 一般来说，如果非成员函数是类接口的组成部分，则这些函数的声明应该与类在同一个头文件内.

* **IO类属于不能被拷贝的类型，因此我们 只能通过引用来传递它们。而且，因为读取和写入的操作会改变流的内容**

* **默认情况下，拷贝类的对象其实拷 贝的是对象的数据成员。**

* 构造函数

  * **每个类都分别定义了它的对象被初始化的方式，类通过一个或几个特殊的成员函数来控制其对象的初始化过程，这些函数叫做构造函数（constructor）。构造函数的任务是初始化类对象的数据成员，无论何时只要类的对象被创建，就会执行构造函数。**

  * 构造函数的名字和类名相同。和其他函数不一样的是**，构造函数没有返回类型**；除此 之外类似于其他的函数，构造函数也有一个（可能为空的）参数列表和一个（可能为空的） 函数体。类可以包含多个构造函数，和其他重载函数差不多，不 同的构造函数之间必须在参数数量或参数类型上有所区别。

  * **不同于其他成员函数，构造函数不能被声明成const的。 当我们创建类的一个const对象时，直到构造函数完成初始化过程，对象才能真正取得其"常量”属性。因此，构造函数在const对象的构造过程中可以向其写值。**

  * 没有为对象提供初始值时，它们执行了默认初始化。类通过一个特殊的构造函数来控制默认初始化过程，这个函数叫做默认构造函数（default constructor）。默认构造函数无须任何实参。默认构造函数在很多方面都有其特殊性。其中之一是，**如果我们的类没有显式地定义构造函数，那么编译器就会为我们隐式地定义一个默认构造函数。**

  * 编译器创建的构造函数又被称为**合成的默认构造函数（synthesized default constructor）**。 对于大多数类来说，这个合成的默认构造函数将按照如下规则初始化类的数据成员：

    1. 如果存在**类内的初始值**，用它来初始化成员。

    2. 否则，**默认初始化**该成员。

* 某些类不能依赖于合成的默认构造函数

  * 合成的默认构造函数只适合非常简单的类
  * 对于一个普通的类来说，必须定义它自己的默认构造函数，原因有三：第一个原因也是最容易理解的一个原因就是**编译器只有在发现类不包含任何构造函数的情况下才会替我们生成一个默认的构造函数**。一旦我们定义了一些其他的构造函数，那么除非我们再定义一 个默认的构造函数，否则类将没有默认构造函数。这条规则的依据是，如果一个类在某种情况下需要控制对象初始化，那么该类很可能在所有情况下都需要控制。第二个原因是对于某些类来说，**合成的默认构造函数可能执行错误的操作**（**如果类包含有内置类型或者复合类型的成员，则只有当这些成员全都被赋予了类内的初始值时，这个类才适合于使用合成的默认构造函数**）。第三个原因是**有的时候编译器不能为某些类合成默认的构造函数**。例如，如果类中包含一个其他类类型的成员且这个成员的类型没有默认构造函数，那么编译器将无法初始化 该成员。对于这样的类来说，我们必须自定义默认构造函数，否则该类将没有可用的默认 构造函数。

* =default的含义

  * 首先请明确一点：因为该构造函数不接受任何实参，所以它是一个默认构造函数。我们定 义这个构造函数的目的仅仅是因为我们既需要其他形式的构造函数，也需要默认的构造函 数。我们希望这个函数的作用完全等同于之前使用的合成默认构造函数。
  * 在C++11新标准中，如果我们需要默认的行为，那么可以通过在参数列表后面写上 =default来要求编译器生成构造函数。其中，=default既可以和声明一起出现在 类的内部，也可以作为定义出现在类的外部。和其他函数一样，**如果=default在类的内部，则默认构造函数是内联的；如果它在类的外部，则该成员默认情况下不是内联的**
  * 如果你的编译器不支持类内初始值，那么你的默认构造函数就应该使用构造函数初始值列表来初始化类的每个成员

* 构造函数初始值列表

  * 构造函数初始值是成员名字的一个 列表，每个名字后面紧跟括号括起来的(或者在花括号内的)成员初始值。不同成员的初 始化通过逗号分隔开来。
  * **当某个数据成员被构造函数初始值列表 忽略时：它将以与合成默认构造函数相同的方式隐式初始化。**
  * **构造函数不应该轻易覆盖掉类内的初始值**，除非新赋的值与原值不同：如果你不能使用类内初始值，则所有构造函数都应该显式地初始化每个内置类型的成员

* 拷贝、赋值和析构

  * 对象在几种情况下会被拷贝，如我们**初始化变量**以及**以值的方式传递**或**返回一个对象**等。当我们**使用了赋值运算符时会发生对象的赋值操作**。当**对象不再存在时执行销毁的操作**，比如一个 局部对象会在创建它的块结束时被销毁，当vector对象（或者数组）销毁时存储在其中的对象也会被销毁。
  * 如果我们不主动定义这些操作，则编译器将替我们合成它们。一般来说，编译器生成 的版本将对对象的每个成员执行拷贝、赋值和销毁操作。

* **某些类不能依赖于合成的版本**

  * 尽管编译器能替我们合成拷贝、赋值和销毁的操作，但是必须要清楚的一点是，对于某些类来说合成的版本无法正常工作。特别是，当类需要分配类对象之外的资源时，合成的版本常常会失效。

#### 访问控制与封裝

* 到目前为止，我们已经为类定义了接口，但并没有任何机制强制用户使用这些接口。 我们的类还没有封装.在c++语言中，我们使用**访问说明符(access specifiers)**加强类的封装性：

  * 定义在public说明符之后的成员在整个程序内可被访问，public成员定义类的接口。
  * 定义在private说明符之后的成员可以被类的成员函数访问，但是不能被使用该类的代码访问，private部分封装了(即隐藏了)类的实现细节。
  * 一个类可以包含0个或多个访问说明符，而且对于某个访问说明符能出现多少次也没 有严格限定。每个访问说明符指定了接下来的成员的访问级别，其有效范围直到出现下一 个访问说明符或者到达类的结尾处为止。

* 使用class或struct关键字

  * 类可以在它的第一个访问说明符之前定义成员，对这种成员的访问权限依赖于类定义的方式。**如果我们使用struct关键字，则定义在第一个访问说明符之前的成员是public 的；相反，如果我们使用class关键字，则这些成员是private的。**
  * 出于统一编程风格的考虑，当我们希望定义的类的所有成员是public的时，使用 struct；反之，如果希望成员是private的，使用class。
  * **使用class和struct定义类唯一的区别就是默认的访问权限**

* 友元

  * **类可以允许其他类或者函数访问它的非公有成员，方法是令其他类或者函数成为它的友元（friend）**。如果类想把一个函数作为它的友元，只需要增加一条以friend关键字开始的函数声明语句即可
  * **友元声明只能出现在类定义的内部，但是在类内出现的具体位置不限。友元不是类的成员 也不受它所在区域访问控制级别的约束。**
  * 一般来说，最好在类定义开始或结束前的位置集中声明友元

* 关键概念：封装的益处

  * **确保用户代码不会无意间破坏封装对象的状态**。
  * **被封装的类的具体实现细节可以随时改变，而无须调整用户级别的代码**。
  * **一旦把数据成员定义成private的，类的作者就可以比较自由地修改数据了。当实现部分改变时，我们只需要检查类的代码本身以确认这次改变有什么影响；换句话说， 只要类的接口不变，用户代码就无须改变。如果数据是public的，则所有使用了原来数据成员的代码都可能失效，这时我们必须定位并重写所有依赖于老版本实现的代码， 之后才能重新使用该程序。**
  * 把数据成员的访问权限设成private还有另外一个好处，这么做能**防止由于用户的原因造成数据被破坏**,，如果我们发现有程序缺陷破坏了对象的状态，则可以在有限的范围内定位缺陷：因为只有实现部分的代码可能产生这样的错误。因此，将查错限制在 有限范围内将能极大地降低维护代码及修正程序错误的难度。
  * 尽管当类的定义发生改变时无须更改用户代码，但是使用了该类的源文件必须重新编译。

* 友元的声明

  * **友元的声明仅仅指定了访问的权限，而非一个通常意义上的函数声明。如果我们希望 类的用户能够调用某个友元函数，那么我们就必须在友元声明之外再专门对函数进行一次 声明**。
  * 为了使友元对类的用户可见，我们通常把友元的声明与类本身放置在同一个头文件中 （类的外部）。
  * 许多编译器并未强制限定友元函数必须在使用之前在类的外部声明。一些编译器允许在尚无友元函数的初始声明的情况下就调用它。不过即使你的编译器支持这种行为，最好还是提供一个独立的函数声明。这样即使你更换了一个有这种强制要 求的编译器，也不必改变代码。  

* **一个const成员函数如果以引用的形式返回\*this,那么它的返回类型将是 常量引用。**

* 基于const的重载

  * 通过区分成员函数是否是const的，我们可以对其进行重载，其原因与我们之前根 据指针参数是否指向const 而重载函数的原因差不多。具体说 来，因为**非常量版本的函数对于常量对象是不可用的**，所以我们只能在一个常量对象上调 用const成员函数。另一方面，虽然可以在非常量对象上调用常量版本或非常量版本， 但显然此时非常量版本是一个更好的匹配。
  * **当一个成员调用另外一个成员时，this指针在其中隐式地传递。 **

* 建议：**对于公共代码使用私有功能函数**

  * 一个基本的愿望是**避免在多处使用同样的代码**。
  * 我们预期随着类的规模发展，函数有可能变得更加复杂，此时，把相 应的操作写在一处而非两处的作用就比较明显了。
  * 我们很可能在开发过程中给函数添加某些调试信息，而这些信息 将在代码的最终产品版本中去除。 显然，一处添加或删除这 些信息要更容易一些。
  * **设计良好的C++代码常常包含大量的小函数，通过调用这些函数，可以完成一组其他函数的"实际"工作。**

* 类类型

  * **每个类定义了唯一的类型**。对于两个类来说，即使它们的成员完全一样，这两个类也 是两个不同的类型。
  * 我们可以把类名作为类型的名字使用，从而直接指向类类型。或者，我们也可以把类 名跟在关键字class或struct后面

* 类的声明

  * 就像可以把函数的声明和定义分离开来一样，**我们也能仅仅声明类而暂时不定义它. `class Person`**. 这种声明有时被称作**前向声明（forward declaration）**,它**向程序中引入了名字Person并且指明Person是一种类类型。对于类型Person来说，在它声明之后定义之前是一个不完全类型（incomplete type）,也就是说，此时我们已知Person是一个类类型，但是不清楚它到底包含哪些成员。**
  * 不完全类型只能在非常有限的情景下使用：可以定义指向这种类型的指针或引用，也可以声明（但是不能定义）以不完全类型作为参数或者返回类型的函数。

* **对于一个类来说，在我们创建它的对象之前该类必须被定义过，而不能仅仅被声明。 否则，编译器就无法了解这样的对象需要多少存储空间。类似的，类也必须首先被定义， 然后才能用引用或者指针访问其成员。毕竟，如果类尚未定义，编译器也就不清楚该类到底有哪些成员。**

* 类被定义之后数据成员才能被声明成这种类类型。换句话说，我们必须首先完成类的定义，然后编译器才能知道存 储该数据成员需要多少空间。因为只有当类全部完成后类才算被定义，所以**一个类的成员类型不能是该类自己**。然而，一旦一个类的名字出现后，它就被认为是声明过了（但尚未 定义），因此**类允许包含指向它自身类型的引用或指针**

* 友元再探

  * 类把普通的**非成员函数**定义成友元。类还可以把**其他的类**定义成友元，也可以把**其他类（之前已定义过的）的成员函数**定义成友元。此外，友元函数能定义在类的内部，这样的函数是隐式内联的。

* 类之间的友元关系

  * `clss Animal {`

    ​	friend class Person;

    `}`

  * **友元关系不存在传递性。每个类负责控制自己的友元类或友元函数。**

* 令成员函数作为友元

  * **除了令整个类作为友元之外， 还可以只为类中某个函数提供访问权限。 当把一个成员函数声明友元时，我们必须明确指出该成员函数属哪个类**

* 函数重载和友元

  * **尽管重载函数的名字相同，但它们仍然是不同的函数。因此，如果一个类想把一组重载函数声明成它的友元，它需要对这组函数中的每一个分别声明**

* 友元声明和作用域

  * 类和非成员函数的声明不是必须在它们的友元声明之前。当一个名字第一次出现在一 个友元声明中时，我们隐式地假定该名字在当前作用域中是可见的。然而，**友元本身不一 定真的声明在当前作用域中**。
  * 甚至**就算在类的内部定义该函数，我们也必须在类的外部提供相应的声明从而使得函数可见**。换句话说，即使我们仅仅是用声明友元的类的成员调用该友元函数，它也必须是被声明过的

#### 类的作用域

* **每个类都会定义它自己的作用域**。在类的作用域之外，普通的数据和函数成员只能由对象、引用或者指针使用成员访问运算符来访问。对于类类型成员则使用作用域运算符访问。不论哪种情况，跟在运算符之后的名字都必须是对应类的成员
* 一个类就是一个作用域的事实能够很好地解释为什么当我们在类的外部定义成员函数时必须同时提供类名和函数名。**在类的外部，成员的名字被隐藏起来了。**
* **一旦遇到了类名，定义的剩余部分就在类的作用域之内了**，这里的剩余部分包括参数列表和函数体。结果就是，我们可以直接使用类的其他成员而无须再次授权了。
* 另一方面，函数的返回类型通常出现在函数名之前。因此**当成员函数定义在类的外部时，返回类型中使用的名字都位于类的作用域之外。这时，返回类型必须指明它是哪个类的成员。**

* 名字查找与类的作用域
  * 在目前为止，我们编写的程序中，**名字查找(name lookup)**寻找与所用名字最匹配的声明的过程)的过程比较直截了当：首先，**在名字所在的块中寻找其声明语句**，只考虑在名字的使用之前出现的声明。如果没找到，继续**查找外层作用域**。如果最终没有找到匹配的声明，则程序报错。
  * 对于定义在类内部的成员函数来说，解析其中名字的方式与上述的査找规则有所区别，不过在当前的这个例子中体现得不太明显。类的定义分两步处理：
    * 首先，**编译成员的声明**。
    * 直到**类全部可见后才编译函数体**。
  * 按照这种两阶段的方式处理类可以简化类代码的组织方式。因为成员函数体直到整个类可见后才会被处理，所以它能使用类中定义的任何名字。相反，如果函数的定义和成员 的声明被同时处理，那么我们将不得不在成员函数中只使用那些已经出现的名字。
* **编译器处理完类中的全部声明后才会处理成员函数的定义**。
* 用于类成员声明的名字查找
  
  * 这种两阶段的处理方式只适用于成员函数中使用的名字。**声明中使用的名字，包括返回类型或者参数列表中使用的名字，都必须在使用前确保可见**。如果某个成员的声明使用了类中尚未出现的名字，则编译器将会在定义该类的作用域中继续査找。
* 类型名要特殊处理
  * 一般来说，内层作用域可以重新定义外层作用域中的名字，即使该名字已经在内层作用域中使用过。然而**在类中，如果成员使用了外层作用域中的某个名字，而该名字代表一种类型，则类不能在之后重新定义该名字**
  * 尽管重新定义类型名字是一种错误的行为，但是编译器并不为此负责。一些编译器仍将顺利通过这样的代码，而忽略代码有错的事实。
  * **类型名的定义通常出现在类的开始处，这样就能确保所有使用该类型的成员都出现在类名的定义之后。**
* 成员定义中的普通块作用域的名字查找. 成员函数中使用的名字按照如下方式解析：
  * 首先，**在成员函数内查找该名字的声明**。和前面一样，只有在函数使用之前岀现的 声明才被考虑。
  * 如果在成员函数内没有找到，则**在类内继续査找**，这时类的所有成员都可以被考虑。
  * 如果类内也没找到该名字的声明，**在成员函数定义之前的作用域内继续查找**。
  * 一般来说，**不建议使用其他成员的名字作为某个成员函数的参数**
  * 尽管类的成员被隐藏了，但我们仍然可以通过加上类的名字或显式地使用 this指针来强制访问成员
* 类作用域之后，在外围的作用域中查找
  * 如果编译器在函数和类的作用域中都没有找到名字，它将接着在外围的作用域中查找。
  * **尽管外层的对象被隐藏掉了，但我们仍然可以用作用域运算符访问它。**
* 构造函数再探
  * 当我们定义变量时习惯于立即对其进行初始化，而非先定义、再赋值
  * 就对象的数据成员而言，初始化和赋值也有类似的区别。**如果没有在构造函数的初始值列表中显式地初始化成员，则该成员将在构造函数体之前执行默认初始化。**
* 构造函数的初始值有时必不可少
  * 有时我们可以忽略数据成员初始化和赋值之间的差异，但并非总能这样。**如果成员是 const 或者是引用的话，必须将其初始化**。类似的，**当成员属于某种类类型且该类没有定义默认构造函数时，也必须将这个成员初始化**。
  * **随着构造函数体一开始执行，初始化就完成了。我们初始化const或者引用类型的数据成员的唯一机会就是通过构造函数初始值**

* 建议：使用构造函数初始值

  * 在很多类中，**初始化和赋值的区别事关底层效率问题：前者直接初始化数据成员， 后者则先初始化再赋值**。
  * 除了效率问题外更重要的是，一些数据成员必须被初始化。建议读者养成使用构造 函数初始值的习惯，这样能避免某些意想不到的编译错误，特别是遇到有的类含有需要 构造函数初始值的成员时。

* 成员初始化的顺序

  * 显然，在构造函数初始值中每个成员只能出现一次。否则，给同一个成员赋两个不同 的初始值有什么意义呢？

  * 不过让人稍感意外的是，**构造函数初始值列表只说明用于初始化成员的值，而不限定初始化的具体执行顺序**。

  * **成员的初始化顺序与它们在类定义中的岀现顺序一致：第一个成员先被初始化，然后 第二个，以此类推。构造函数初始值列表中初始值的前后位置关系不会影响实际的初始化顺序。**

  * 一般来说，初始化的顺序没什么特别要求。不过如果一个成员是用另一个成员来初始 化的，那么这两个成员的初始化顺序就很关键了。

    ```
    class X {
    public:
        int i, j;
        X(int val):j(val), i(j){} // i = 0; j = val;
    };
    ```

  * 最好**令构造函数初始值的顺序与成员声明的顺序保持一致**。而且如果可能的话，**尽量避免使用某些成员初始化其他成员**。
  * 如果可能的话，**最好用构造函数的参数作为成员的初始值，而尽量避免使用同一个对象的其他成员**。这样的好处是我们可以不必考虑成员的初始化顺序。

* **如果一个构造函数为所有参数都提供了默认实参，则它实际上也定义了默认构造函数。**

* 委托构造函数

  * **一个委托构造函数使用它所属类的其他构造函数执行它自己的初始化过程**，或者说它把它自己的一些(或者全部)职责委托给了其他构造函数。
  * 和其他构造函数一样，**一个委托构造函数也有一个成员初始值的列表和一个函数体。 在委托构造函数内，成员初始值列表只有一个唯一的入口，就是类名本身**。和其他成员初始值一样，类名后面紧跟圆括号括起来的参数列表，参数列表必须与类中另外一个构造函数匹配。

* 默认构造函数的作用

  * **当对象被默认初始化或值初始化时自动执行默认构造函数。**默认初始化在以下情况下

    发生：

    * 当我们在块作用域内不使用任何初始值定义一个非静态变量或者数组时
    * 当一个类本身含有类类型的成员且使用合成的默认构造函数时
    * 当类类型的成员没有在构造函数初始值列表中显式地初始化时

  * 值初始化在以下情况下发生：
    
    * 在数组初始化的过程中如果我们提供的初始值数量少于数组的大小时
    * 当我们不使用初始值定义一个局部静态变量时
    * 当我们通过书写形如T（）的表达式显式地请求值初始化时，其中T是类型名

* 隐式的类类型转换
  * C++语言在内置类型之间定义了几种自动转换规则。 同样的，我们也能为类定义隐式转换规则。如果构造函数只接受一个实参，则它实际上定义了转换为此类类型的隐式转换机制，有时我们把这种构造函数称作**转换构造函数 (converting constructor)**
  * **能通过一个实参调用的构造函数定义了一条从构造函数的参数类型向类类型隐式转换的规则。**
  * 只允许一步类类型转换
    * **编译器只会自动地执行一步类型转换**。例如， 隐式地使用了两种转换规则是错误的
* 类类型转换不是总有效
  
  * 是否需要从string到Sales_data的转换依赖于我们对用户使用该转换的看法。 在此例中，这种转换可能是对的。
* 抑制构造函数定义的隐式转换
  * 在要求隐式转换的程序上下文中，我们可以通过将构造函数声明为explicit加以阻止
  * **关键字explicit只对一个实参的构造函数有效。需要多个实参的构造函数不能用于执行隐式转换，所以无须将这些构造函数指定为explicit的。只能在类内声明构造 函数时使用explicit关键字，在类外部定义时不应重复**
* explicit构造函数只能用于直接初始化
  * 发生隐式转换的一种情况是当我们执行拷贝形式的初始化时(使用=)。此时，我们**只能使用直接初始化而不能使用explicit构造函数**
  * 当我们用explicit关键字声明构造函数时，它将只能以直接初始化的形式使用. 而且，编译器将不会在自动转换过程中使用该构造函数。

* 为转换显式地使用构造函数

  * 尽管编译器不会将explicit的构造函数用于隐式转换过程，但是我们可以使用这 样的构造函数显式地强制进行转换

    ```
    saleData.add(SaleData(" ma"));
    saleData.add(static_cast<SaleData>(" ma"));
    // 执行了显式的而非隐式的转换
    ```

* 聚合类

  * **聚合类(aggregate class)使得用户可以直接访问其成员，并且具有特殊的初始化语法形式**。当一个类满足如下条件时，我们说它是聚合的：

    * 所有成员都是public的。
    * 没有定义任何构造函数。
    * 没有类内初始值。
    * 没有基类，也没有virtual函数

    ```
    struct Person{
    	std::string name;
    	int age;
    }
    ```

  * 我们可以提供一个花括号括起来的成员初始值列表，并用它初始化聚合类的数据成员.  **初始值的顺序必须与声明的顺序一致**，也就是说，第一个成员的初始值要放在第一个，然 后是第二个，以此类推。
  * 与初始化数组元素的规则一样，**如果初始值列表中的元素个数少于类的成员数量，则靠后的成员被值初始化。初始值列表的元素个数绝对不能超过类的成员数量。**值得注意的是，显式地初始化类的对象的成员存在三个明显的缺点：
    * 要求类的所有成员都是public的。
    * **将正确初始化每个对象的每个成员的重任交给了类的用户（而非类的作者）。因为用户很容易忘掉某个初始值，或者提供一个不恰当的初始值，所以这样的初始化过 程冗长乏味且容易岀错。**
    * 添加或删除一个成员之后，所有的初始化语句都需要更新。

* 字面值常量类
  * constexpr函数的参数和返回值必须是字面 值类型。除了算术类型、引用和指针外，某些类也是字面值类型。
  * 和其他类不同，**字面值类型的类可能含有constexpr函数成员**。这样的成员必须符合constexpr函数的所有要求，它们是隐式const的。
  * **数据成员都是字面值类型的聚合类是字面值常量类**。如 果一个类不是聚合类，但它符合下述要求，则它也是一个字面值常量类：
    * 数据成员都必须是字面值类型。
    * 类必须至少含有一个constexpr构造函数。
    * 如果一个数据成员含有类内初始值，则内置类型成员的初始值必须是一条常量表达式；或者如果成员属于某种类类型，则初始值必须使用 成员自己的constexpr构造函数。
    * 类必须使用析构函数的默认定义，该成员负责销毁类的对象

* constexpr构造函数
  * 尽管构造函数不能是const的，但是字面值常量类的构造函数可以是constexpr 函数。事实上，一个字面值常量类必须至少提供一个constexpr构造函数。
  * constexpr构造函数可以声明 = default 的形式（或者是删除函数的形式））。构造函数就必须既符合构造函数的要求（意味着不能包含返回语句），又符合constexpr 函数的要求（意味着它能拥有的唯一可执行语句就是返回语句。 综合这两点可知，constexpr构造函数体一般来说应该是空的。我们通过前置关键字 constexpr就可以声明一个constexpr构造函数了
  * **constexpr构造函数必须初始化所有数据成员，初始值或者使用constexpr构造函数, 或者是一条常量表达式。**

#### 类的静态成员

* **有的时候类需要它的一些成员与类本身直接相关，而不是与类的各个对象保持关联。 **
  *  例如，一个银行账户类可能需要一个数据成员来表示当前的基准利率。在此例中，我们希 望利率与类关联，而非与类的每个对象关联。从实现效率的角度来看，没必要每个对象都 存储利率信息。而且更加重要的是，一旦利率浮动，我们希望所有的对象都能使用新值。
* 声明静态成员
  * 我们通过**在成员的声明之前加上关键字static使得其与类关联在一起**。和其他成员一样，静态成员可以是public的或private的。静态数据成员的类型可以是常量、引用、指针、类类型等。
* **类的静态成员存在于任何对象之外，对象中不包含任何与静态数据成员有关的数据。**
* 类似的，**静态成员函数也不与任何对象绑定在一起，它们不包含this指针**。作为结果，静态成员函数不能声明成const的，而旦我们也不能在static函数体内使用this 指针。这一限制既适用于this的显式使用，也对调用非静态成员的隐式使用有效。

* 使用类的静态成员
  * 我们**使用作用域运算符直接访问静态成员**：`Person::desc()`
  * 虽然静态成员不属于类的某个对象，但是我们仍然可以**使用类的对象、引用或者指针来访问静态成员**: `Person person; person.desc()`
  * **成员函数不用通过作用域运算符就能直接使用静态成员**

* 定义静态成员
  * 和其他的成员函数一样，我们既可以在类的内部也可以在类的外部定义静态成员函数。**当在类的外部定义静态成员时，不能重复static关键字，该关键字只出现在类内部的声明语句**
* 因为静态数据成员不属于类的任何一个对象，所以它们并**不是在创建类的对象时被定义的**。这意味着**它们不是由类的构造函数初始化的。而且一般来说，我们不能在类的内部初始化静态成员。相反的，必须在类的外部定义和初始化每个静态成员。和其他对象一样， —个静态数据成员只能定义一次。**

* **类似于全局变量，静态数据成员定义在任何函数之外。因此一旦它被定义，就将一直存在于程序的整个生命周期中。**
* 我们定义静态数据成员的方式和在类的外部定义成员函数差不多。我们需要指定对象的类型名，然后是类名、作用域运算符以及成员自己的名字

* **要想确保对象只定义一次，最好的办法是把静态数据成员的定义与其他非内联函数的定义放在同一个文件中**
* 静态成员的类内初始化
  * 通常情况下，**类的静态成员不应该在类的内部初始化**。
  * 我们**可以为静态成员提供const整数类型的类内初始值，不过要求静态成员必须是字面值常量类型的 constexpr** 。初始值必须是常量表达式，因为这些成员本身就是常量表达式，所以它们能用在所有适合于常量表达式的地方。
  * 如果某个静态成员的应用场景仅限于编译器可以替换它的值的情况，则一个初始化的 const或constexpr static不需要分别定义。相反，如果我们将它用于值不能替换的场景中，则该成员必须有一条定义语句。
  * **如果在类的内部提供了一个初始值，则成员的定义不能再指定一个初始值了**
  * **即使一个常量静态数据成员在类内部被初始化了，通常情况下也应该在类的外 部定义一下该成员**

* 静态成员能用于某些场景，而普通成员不能
  * 如我们所见，静态成员独立于任何对象。因此，在某些非静态数据成员可能非法的场 合，静态成员却可以正常地使用。举个例子，**静态数据成员可以是不完全类型**。特别的，静态数据成员的类型可以就是它所属的类类型。而非静态数据 成员则受到限制，只能声明成它所属类的指针或引用
  * **静态成员和普通成员的另外一个区别是我们可以使用静态成员作为默认实参。非静态数据成员不能作为默认实参，因为它的值本身属于对象的一部分，这么做的结果是无法真正提供一个对象以便从中获取成员的值，最终将引发错误。**

---

* 类成员再探

* 除了定义数据和函数成员之外，**类还可以自定义某种类型在类中的别名**。由类定义的类型名字和其他成员一样存在访问限制，可以是public或者private中的一种

  ```
  class Screen （
  public:
    typedef std::string::size_type pos; 	// 自定义某种类型在类中的别名
    using pos = std：:string：:size_type；	//使用类型别名等价地声明一个类型名字
  ）;
  ```

  * **用来定义类型的成员必须先定义后使用**，这一点与普通成员有所区别。因此，类型成员通常岀现在类开始的地方。

* 令成员作为内联函数

  * 在类中，常有一些**规模较小的函数**适合于被声明成内联函数。如我们之前所见的，定义在类内部的成员函数是自动 inline 的
  * 可以在类的内部把inline作为声明的一部分显式地声明成员函数，同样的，也 能在类的外部用inline关键字修饰函数的定义
  * **最好只在类外部定义的地方说明inline**,这样可以使类更容易理解。inline成员函数也应该与相应的类定义在同一个头文件中。

* 重载成员函数

  * 和非成员函数一样，成员函数也可以被重载，只要函数之间在参数的数量和/或类型上有所区别就行。成员函数的函数匹配过程同样与非成员函数非常类似。

* 变数据成员

  * 有时(但并不频繁)会发生这样一种情况，我们希望能修改类的某个数据成员，即使是在一个const成员函数内。可以通过在变量的声明中加入mutable关键字做到这 —点。
  * **一个可变数据成员(mutable data member)永远不会是const,即使它是const对象的成员。因此，一个const成员函数可以改变一个可变成员的值**。

* 当我们提供一个类内初始值时，必须以符号=或者花括号表示

* 返回\*this的成员函数

  * **返回引用的函数是左值的，意味着这些函数返回 的是对象本身而非对象的副本。**

#### 小结

* 类是C++语言中最基本的特性。**类允许我们为自己的应用定义新类型**，从而使得程序 更加简洁旦易于修改。
* 类有两项基本能力：1. 是**数据抽象，即定义数据成员和函数成员的能力**；2. 是**封装， 即保护类的成员不被随意访问的能力**。通过将类的实现细节设为private,我们就能完 成类的封装。类可以将其他类或者函数设为友元，这样它们就能访问类的非公有成员了
* 类可以定义一种特殊的成员函数：构造函数，其作用是控制初始化对象的方式。构造函数可以重载，构造函数应该使用构造函数初始值列表来初始化所有数据成员。
* 类还能定义可变或者静态成员。一个可变成员永远都不会是const,即使在const 成员函数内也能修改它的值：一个静态成员可以是函数也可以是数据，静态成员存在于所有对象之外。