##### 类型转换与继承

* 静态类型与动态类型

  * 当我们使用存在继承关系的类型时，必须将一个变量或其他表达式的静态类型（static type）与该表达式表示对象的动态类型（dynamic type）区分开来。**表达式的静态类型在编译时总是已知的，它是变量声明时的类型或表达式生成的类型：动态类型则是变量或表达式表示的内存中的对象的类型。动态类型直到运行时才可知。**
  * 动态类型直到在运行时调用该函数时才会知道。
  * **如果表达式既不是引用也不是指针，则它的动态类型永远与静态类型一致，我们无论如何都不能改变该表达式对应的对象的类型。**
  * 基类的指针或引用的静态类型可能与其动态类型不一致

* **不存在从基类向派生类的隐式类型转换**

  * 之所以存在派生类向基类的类型转换是因为**每个派生类对象都包含一个基类部分，而基类的引用或指针可以绑定到该基类部分上**。一个基类的对象既可以以独立的形式存在， 也可以作为派生类对象的一部分存在。如果基类对象不是派生类对象的一部分，则它只含有基类定义的成员，而不含有派生类定义的成员。因为一个基类的对象可能是派生类对象的一部分，也可能不是，所以不存在从基类向派生类的自动类型转换
  * 除此之外还有一种情况显得有点特别，**即使一个基类指针或引用绑定在一个派生类对象上，我们也不能执行从基类向派生类的转换**
  * **编译器在编译时无法确定某个特定的转换在运行时是否安全，这是因为编译器只能通过检査指针或引用的静态类型来推断该转换是否合法**。如果在基类中含有一个或多个虚函数， 我们可以使用 dynamic_cast 请求一个类型转换，该转换的安全检査将在运行时执行。同样，如果我们已知某个基类向派生类的转换是安全的，则我们可以使用 static_cast 来强制覆盖掉编译器的检查工作。

* 在对象之间不存在类型转换

  * 派生类向基类的自动类型转换只对指针或引用类型有效，在派生类类型和基类类型之间不存在这样的转换。很多时候，我们确实希望将派生类对象转换成它的基类类型，但是这种转换的实际发生过程往往与我们期望的有所差别。

  * 请注意，当我们初始化或赋值一个类类型的对象时，实际上是在调用某个函数。当执行初始化时，我们调用构造函数；而当执行赋值操作时，我们调用赋值运算符。这些成员通常都包含一个参数，该参数的类型是类类型的const版本的引用。

  * **因为这些成员接受引用作为参数，所以派生类向基类的转换允许我们给基类的拷贝/移动操作传递一个派生类的对象**。这些操作不是虚函数。当我们给基类的构造函数传递一个派生类对象时，实际运行的构造函数是基类中定义的那个，显然该构造函数只能处理基类自己的成员。类似的，如果我们将一个派生类对象赋值给一个基类对象，则实际运行的赋值运算符也是基类中定义的那个，该运算符同样只能处理基类自己的成员。

    ```c++
    Bulk_quote bulk; //派生类对象
    Quote item(bulk); // 使用 Quote: :Quote (const Quote&)构造函数
    item = bulk; // 调用 Quote: :operator=(const Quotes)
    ```

    当构造item时，运行Quote的拷贝构造函数。它负责拷贝bulk中Quote部分的成员，同时忽略掉bulk中Bulk_quote部分 的成员。类似的，对于将bulk赋值给item的操作来说，只有bulk中Quote部分的成员被赋值给item。

    因为在上述过程中会忽略Bulk_quote部分，所以我们可以说bulk的Bulk_quote 部分**被切掉（sliced down）了**。

* 