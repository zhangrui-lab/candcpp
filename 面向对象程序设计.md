* 面向对象程序设计基于三个基本概念：**数据抽象、继承和动态绑定**。
* 继承和动态绑定对程序的编写有两方面的影响：一是我们可以更容易地定义与其他类相似但不完全相同的新类；二是在使用这些彼此相似的类编写程序时，我们可以在一定程度上忽略掉它们的区别。
* **在很多程序中都存在着一些相互关联但是有细微差别的概念。**例如，书店中不同书籍的定价策略可能不同：有的书籍按原价销售，有的则打折销售。有时，我们给那些购买书 籍超过一定数量的顾客打折；另一些时候，则只对前多少本销售的书籍打折，之后就调回 原价，等等。面向对象的程序设计(OOP)适用于这类应用。

#### OOP概述

* 面向对象程序设计(object-oriented programming)的核心思想是数据抽象、继承和动态绑定。
  * 通过使用数据抽象，我们可以**将类的接口与实现分离**
  * 使用继承， 可以**定义相似的类型并对其相似关系建模**；
  * 使用动态绑定，**可以在一定程度上忽略相似类型的区别，而以统一的方式使用它们的对象**。

##### 继承

* 通过继承(inheritance)联系在一起的类构成一种层次关系。通常在层次关系的根部 有一个基类(base class),其他类则直接或间接地从基类继承而来，这些继承得到的类称 为派生类(derived class)。基类负责定义在层次关系中所有类共同拥有的成员，而每个派 生类定义各自特有的成员。
* 在C++语言中，**基类将类型相关的函数与派生类不做改变直接继承的函数区分对待。对于某些函数，基类希望它的派生类各自定义适合自身的版本，此时基类就将这些函数声明成虚函数(virtual function)** `virtual returnType funcName(parameter list);`
* **派生类必须通过使用类派生列表(class derivation list)明确指出它是从哪个(哪些)基类 继承而来的。**类派生列表的形式是：首先是一个冒号，后面紧跟以逗号分隔的基类列表， 其中每个基类前面可以有访问说明符  `class name: public Parent1, private Parent2 {}`
* 派生类必须在其内部对所有重新定义的虚函数进行声明。派生类可以在这样的函数之前加上virtual关键字，但是并不是非得这么做。C++11新标准允许派生类显式地注明它将使用哪个成员函数改写基类的虚函数，具体措施是在该函数的形参列表之后增加一个override关键字。

##### 动态绑定

* c++中动态绑定是**将一个过程调用与相应代码链接起来的行为**。是指与给定的过程调用相关联的代码，只有在**运行期才可知的一种绑定**，他是多态实现的具体形式。

* 在函数时选择函数的版本，所以动态绑定有时又被称为**运行时绑定(run-time binding)**。
* 在C++语言中，当我们**使用基类的引用(或指针)调用一个虚函数时将发生动态绑定**。

#### 定义基类和派生类

* 定义基类和派生类的方式在很多方面都与我们已知的定义其他类的方式类似，但是也有一些不同之处。
* 基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如

* 派生类可以继承其基类的成员，然而当遇到某些操作时，派生类必须对其重新定义。换句话说，**派生类需要对这些操作提供自己的新定义以覆盖 (override)从基类继承而来的旧定义。**
* 在C++语言中，基类必须将它的两种成员函数区分开来：一种是**基类希望其派生类进行覆盖的函数**；另一种是**基类希望派生类直接继承而不要改变的函数**。对于前者，基类通常将其定义为虚函数(virtual)。当我们使用指针或引用调用虚函数时，该调用将被动态绑定。根据引用或指针所绑定的对象类型不同，该调用可能执行基类的版本，也可能执行某个派生类的版本。
* 基类通过在其成员函数的声明语句之前加上关键字virtual使得该函数执行动态绑 定。**任何构造函数之外的非静态函数都可以是虚函数。关键字 virtual只能出现在类内部的声明语句之前而不能用于类外部的函数定义。如果基类把 一个函数声明成虚函数，则该函数在派生类中隐式地也是虚函数。**
* **成员函数如果没被声明为虚函数，则其解析过程发生在编译时而非运行时**
* 访问控制与继承
  * 派生类可以继承定义在基类中的成员，但是**派生类的成员函数不一定有权访问从基类继承而来的成员**。和其他使用基类的代码一样，派生类能访问公有成员，而不能访问私有成员。不过在某些时候基类中还有这样一种成员，基类希望它的派生类有权访问该成员， 同时禁止其他用户访问。我们用**受保护的（protected）**访问运算符说明这样的成员。
* 派生类必须通过使用**类派生列表（class derivation list）**明确指出它是从哪个（哪些） 基类继承而来的。类派生列表的形式是：首先是一个冒号，后面紧跟以逗号分隔的基类列 表，其中每个基类前面可以有以下三种访问说明符中的一个：public、protected或者 private。
  * **访问说明符的作用是控制派生类从基类继承而来的成员是否对派生类的用户可见。**
  * **如果一个派生是公有的，则基类的公有成员也是派生类接口的组成部分。此外，我们 能将公有派生类型的对象绑定到基类的引用或指针上。**
  * 大多数类都只继承自一个类
* **派生类必须将其继承而来的成员函数中需要覆盖的那些重新声明**
* 派生类中的虚函数
  * 派生类经常（但不总是）覆盖它继承的虚函数。如果派生类没有覆盖其基类中的某个虚函数，则该虚函数的行为类似于其他的普通成员，派生类会直接继承其在基类中的版本。
  * 派生类可以在它覆盖的函数前使用virtual关键字，C++11新标准允许派生类显式地注明它使用某个成员函数覆盖了它继承的虚函数。具体做法是在形参列表后面、或者在const成员函数的const关键字后面、或者在引用成员函数的引用限定符后面添加--个关键字 override。
* 派生类对象及派生类向基类的类型转换
  * 一个派生类对象包含多个组成部分：一个含有派生类自己定义的（非静态）成员的子对象，以及一个与该派生类继承的基类对应的子对象，如果有多个基类，那么这样的子对象也有多个。
  * **C++标准并没有明确规定派生类的对象在内存中如何分布。在一个对象中，继承自基类的部分和派生类自定义的部分不一定是连续存储的.**
  * 因为在派生类对象中含有与其基类对应的组成部分，所以我们**能把派生类的对象当成基类对象来使用，而且我们也能将基类的指针或引用绑定到派生类对象中的基类部分上。**这种转换通常称为**派生类到基类的（derived-to-base）类型转换**。和其他类型转换一样，编译器会隐式地执行派生类到基类的转换。这种隐式特性意味着我们可以把派生类对象或者派生类对象的引用用在需要基类引用的地方；同样的，我们也可以把派生类对象 的指针用在需要基类指针的地方。
* 派生类构造函数
  * 尽管在派生类对象中含有从基类继承而来的成员，但是派生类并不能直接初始化这些成员。和其他创建了基类对象的代码一样，**派生类也必须使用基类的构造函数来初始化它的基类部分。**
  * **每个类控制它自己的成员初始化过程**
  * 派生类对象的基类部分与派生类对象自己的数据成员都是在构造函数的初始化阶段执行初始化操作的。类似于我们初始化成员的过程，**派生类构造函数同样是通过构造函数初始化列表来将实参传递给基类构造函数的**。
  * 除非我们特别指出，否则派生类对象的基类部分会像数据成员一样执行默认初始化。 如果想使用其他的基类构造函数，我们需要以类名加圆括号内的实参列表的形式为构造函数提供初始值。这些实参将帮助编译器决定到底应该选用哪个构造函数来初始化派生类对象的基类部分。
  * **首先初始化基类的部分，然后按照声明的顺序依次初始化派生类的成员。**
* 派生类使用基类的成员
  * 派生类可以访问基类的公有成员和受保护成员

* 关键概念：**遵循基类的接口**
  * 必须明确一点：**每个类负责定义各自的接口。要想与类的对象交互必须使用该类的接口，即使这个对象是派生类的基类部分也是如此。**
  * 因此，派生类对象不能直接初始化基类的成员。尽管从语法上来说我们可以在派生类构造函数体内给它的公有或受保护的基类成员赋值，但是最好不要这么做。和使用基类的其他场合一样，**派生类应该遵循基类的接口，并且通过调用基类的构造函数来初始化那些从基类中继承而来的成员。**
* 继承与静态成员
  * 如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义。不论从基类中派生出来多少个派生类，对于每个静态成员来说都只存在唯一的实例。
  * **静态成员遵循通用的访问控制规则**，如果基类中的成员是private的，则派生类无权访问它。假设某静态成员是可访问的，则我们既能通过基类使用它也能通过派生类使用它

* 派生类的声明

  * 派生类的声明与其他类差别不大，**声明中包含类名但是不包含它的派生列表**：

    ```c++
    class Bulk_quote : public Quote; //错误：派生列表不能出现在这里 class Bulk_quote;	//正确：声明派生类的正确方式
    ```

  * **一条声明语句的目的是令程序知晓某个名字的存在以及该名字表示一个什么样的实体，如 一个类、一个函数或一个变量等**。派生列表以及与定义有关的其他细节必须与类的主体一 起出现。

* 被用作基类的类

  * **如果我们想将某个类用作基类，则该类必须已经定义而非仅仅声明**

    ```c++
    class Quote;
    //错误：Quote必须被定义
    class Bulk_quote : public Quote { };
    ```

  * 派生类中包含并且可以使用它从基类继承而来的成员，为了使用这些成员，派生类当然要知道它们是什么。因此该规定还有一层隐含的意思，即**一个类不能派生它本身**。

  * 一个类是基类，同时它也可以是一个派生类:

    ```c++
    class Base { /* ...*/ };
    class D1: public Base { /*...*/ };
    class D2: public DI {/*...*/ );
    /*在这个继承关系中，Base是D1的直接基类(direct base),同时是D2的间接基类(indirect base)。直接基类出现在派生列表中，而间接基类由派生类通过其直接基类继承而来。*/
    ```

  * **每个类都会继承直接基类的所有成员(递归)**。对于一个最终的派生类来说，它会继承其直接 基类的成员；该直接基类的成员又含有其基类的成员；依此类推直至继承链的顶端。因此, 最终的派生类将包含它的直接基类的子对象以及每个间接基类的子对象。

* 防止继承的发生

  * 有时我们会定义这样一种类，我们不希望其他类继承它，或者不想考虑它是否适合作为一个基类。为了实现这一目的，C++11新标准提供了一种防止继承发生的方法，即在类名后跟一个关键字final

##### 类型转换与继承

* 理解基类和派生类之间的类型转换是理解C++语言面向对象编程的关键所在.
* 通常情况下，如果我们想把引用或指针绑定到一个对象上，则引用或指针的类型应与对象的类型一致，或者对象的类型含有一 个可接受的const类型转换规则。存在继承关系的类是一个重 要的例外：**我们可以将基类的指针或引用绑定到派生类对象上**。
* 可以将基类的指针或引用绑定到派生类对象上有一层极为重要的含义：**当使用基类的 引用（或指针）时，实际上我们并不清楚该引用（或指针）所绑定对象的真实类型。该对 象可能是基类的对象，也可能是派生类的对象。**
* 和内置指针一样，**智能指针类也支持派生类向基类 的型转换**，这意味着我们可以将一个派生类对象的指针存储在一个基类的智 能指针内

* 静态类型与动态类型