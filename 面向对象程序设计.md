* 面向对象程序设计基于三个基本概念：**数据抽象、继承和动态绑定**。
* 继承和动态绑定对程序的编写有两方面的影响：一是我们可以更容易地定义与其他类相似但不完全相同的新类；二是在使用这些彼此相似的类编写程序时，我们可以在一定程度上忽略掉它们的区别。
* **在很多程序中都存在着一些相互关联但是有细微差别的概念。**例如，书店中不同书籍的定价策略可能不同：有的书籍按原价销售，有的则打折销售。有时，我们给那些购买书 籍超过一定数量的顾客打折；另一些时候，则只对前多少本销售的书籍打折，之后就调回 原价，等等。面向对象的程序设计(OOP)适用于这类应用。

#### OOP概述

* 面向对象程序设计(object-oriented programming)的核心思想是数据抽象、继承和动态绑定。
  * 通过使用数据抽象，我们可以**将类的接口与实现分离**
  * 使用继承， 可以**定义相似的类型并对其相似关系建模**；
  * 使用动态绑定，**可以在一定程度上忽略相似类型的区别，而以统一的方式使用它们的对象**。

##### 继承

* 通过继承(inheritance)联系在一起的类构成一种层次关系。通常在层次关系的根部 有一个基类(base class),其他类则直接或间接地从基类继承而来，这些继承得到的类称 为派生类(derived class)。基类负责定义在层次关系中所有类共同拥有的成员，而每个派 生类定义各自特有的成员。
* 在C++语言中，**基类将类型相关的函数与派生类不做改变直接继承的函数区分对待。对于某些函数，基类希望它的派生类各自定义适合自身的版本，此时基类就将这些函数声明成虚函数(virtual function)** `virtual returnType funcName(parameter list);`
* **派生类必须通过使用类派生列表(class derivation list)明确指出它是从哪个(哪些)基类 继承而来的。**类派生列表的形式是：首先是一个冒号，后面紧跟以逗号分隔的基类列表， 其中每个基类前面可以有访问说明符  `class name: public Parent1, private Parent2 {}`
* 派生类必须在其内部对所有重新定义的虚函数进行声明。派生类可以在这样的函数之前加上virtual关键字，但是并不是非得这么做。C++11新标准允许派生类显式地注明它将使用哪个成员函数改写基类的虚函数，具体措施是在该函数的形参列表之后增加一个override关键字。

##### 动态绑定

* c++中动态绑定是**将一个过程调用与相应代码链接起来的行为**。是指与给定的过程调用相关联的代码，只有在**运行期才可知的一种绑定**，他是多态实现的具体形式。

* 在函数时选择函数的版本，所以动态绑定有时又被称为**运行时绑定(run-time binding)**。
* 在C++语言中，当我们**使用基类的引用(或指针)调用一个虚函数时将发生动态绑定**。

#### 定义基类和派生类

* 定义基类和派生类的方式在很多方面都与我们已知的定义其他类的方式类似，但是也有一些不同之处。
* 基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如

* 派生类可以继承其基类的成员，然而当遇到某些操作时，派生类必须对其重新定义。换句话说，**派生类需要对这些操作提供自己的新定义以覆盖 (override)从基类继承而来的旧定义。**
* 在C++语言中，基类必须将它的两种成员函数区分开来：一种是**基类希望其派生类进行覆盖的函数**；另一种是**基类希望派生类直接继承而不要改变的函数**。对于前者，基类通常将其定义为虚函数(virtual)。当我们使用指针或引用调用虚函数时，该调用将被动态绑定。根据引用或指针所绑定的对象类型不同，该调用可能执行基类的版本，也可能执行某个派生类的版本。
* 基类通过在其成员函数的声明语句之前加上关键字virtual使得该函数执行动态绑 定。**任何构造函数之外的非静态函数都可以是虚函数。关键字 virtual只能出现在类内部的声明语句之前而不能用于类外部的函数定义。如果基类把 一个函数声明成虚函数，则该函数在派生类中隐式地也是虚函数。**
* **成员函数如果没被声明为虚函数，则其解析过程发生在编译时而非运行时**
* 访问控制与继承
  
  * 派生类可以继承定义在基类中的成员，但是**派生类的成员函数不一定有权访问从基类继承而来的成员**。和其他使用基类的代码一样，派生类能访问公有成员，而不能访问私有成员。不过在某些时候基类中还有这样一种成员，基类希望它的派生类有权访问该成员， 同时禁止其他用户访问。我们用**受保护的（protected）**访问运算符说明这样的成员。
* 派生类必须通过使用**类派生列表（class derivation list）**明确指出它是从哪个（哪些） 基类继承而来的。类派生列表的形式是：首先是一个冒号，后面紧跟以逗号分隔的基类列 表，其中每个基类前面可以有以下三种访问说明符中的一个：public、protected或者 private。
  * **访问说明符的作用是控制派生类从基类继承而来的成员是否对派生类的用户可见。**
  * **如果一个派生是公有的，则基类的公有成员也是派生类接口的组成部分。此外，我们 能将公有派生类型的对象绑定到基类的引用或指针上。**
  * 大多数类都只继承自一个类
* **派生类必须将其继承而来的成员函数中需要覆盖的那些重新声明**
* 派生类中的虚函数
  * 派生类经常（但不总是）覆盖它继承的虚函数。如果派生类没有覆盖其基类中的某个虚函数，则该虚函数的行为类似于其他的普通成员，派生类会直接继承其在基类中的版本。
  * 派生类可以在它覆盖的函数前使用virtual关键字，C++11新标准允许派生类显式地注明它使用某个成员函数覆盖了它继承的虚函数。具体做法是在形参列表后面、或者在const成员函数的const关键字后面、或者在引用成员函数的引用限定符后面添加--个关键字 override。
* 派生类对象及派生类向基类的类型转换
  * 一个派生类对象包含多个组成部分：一个含有派生类自己定义的（非静态）成员的子对象，以及一个与该派生类继承的基类对应的子对象，如果有多个基类，那么这样的子对象也有多个。
  * **C++标准并没有明确规定派生类的对象在内存中如何分布。在一个对象中，继承自基类的部分和派生类自定义的部分不一定是连续存储的.**
  * 因为在派生类对象中含有与其基类对应的组成部分，所以我们**能把派生类的对象当成基类对象来使用，而且我们也能将基类的指针或引用绑定到派生类对象中的基类部分上。**这种转换通常称为**派生类到基类的（derived-to-base）类型转换**。和其他类型转换一样，编译器会隐式地执行派生类到基类的转换。这种隐式特性意味着我们可以把派生类对象或者派生类对象的引用用在需要基类引用的地方；同样的，我们也可以把派生类对象 的指针用在需要基类指针的地方。
* 派生类构造函数
  * 尽管在派生类对象中含有从基类继承而来的成员，但是派生类并不能直接初始化这些成员。和其他创建了基类对象的代码一样，**派生类也必须使用基类的构造函数来初始化它的基类部分。**
  * **每个类控制它自己的成员初始化过程**
  * 派生类对象的基类部分与派生类对象自己的数据成员都是在构造函数的初始化阶段执行初始化操作的。类似于我们初始化成员的过程，**派生类构造函数同样是通过构造函数初始化列表来将实参传递给基类构造函数的**。
  * 除非我们特别指出，否则派生类对象的基类部分会像数据成员一样执行默认初始化。 如果想使用其他的基类构造函数，我们需要以类名加圆括号内的实参列表的形式为构造函数提供初始值。这些实参将帮助编译器决定到底应该选用哪个构造函数来初始化派生类对象的基类部分。
  * **首先初始化基类的部分，然后按照声明的顺序依次初始化派生类的成员。**
* 派生类使用基类的成员
  
* 派生类可以访问基类的公有成员和受保护成员
  
* 关键概念：**遵循基类的接口**
  * 必须明确一点：**每个类负责定义各自的接口。要想与类的对象交互必须使用该类的接口，即使这个对象是派生类的基类部分也是如此。**
  * 因此，派生类对象不能直接初始化基类的成员。尽管从语法上来说我们可以在派生类构造函数体内给它的公有或受保护的基类成员赋值，但是最好不要这么做。和使用基类的其他场合一样，**派生类应该遵循基类的接口，并且通过调用基类的构造函数来初始化那些从基类中继承而来的成员。**
* 继承与静态成员
  * 如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义。不论从基类中派生出来多少个派生类，对于每个静态成员来说都只存在唯一的实例。
  * **静态成员遵循通用的访问控制规则**，如果基类中的成员是private的，则派生类无权访问它。假设某静态成员是可访问的，则我们既能通过基类使用它也能通过派生类使用它

* 派生类的声明

  * 派生类的声明与其他类差别不大，**声明中包含类名但是不包含它的派生列表**：

    ```c++
    class Bulk_quote : public Quote; //错误：派生列表不能出现在这里 class Bulk_quote;	//正确：声明派生类的正确方式
    ```

  * **一条声明语句的目的是令程序知晓某个名字的存在以及该名字表示一个什么样的实体，如 一个类、一个函数或一个变量等**。派生列表以及与定义有关的其他细节必须与类的主体一 起出现。

* 被用作基类的类

  * **如果我们想将某个类用作基类，则该类必须已经定义而非仅仅声明**

    ```c++
    class Quote;
    //错误：Quote必须被定义
    class Bulk_quote : public Quote { };
    ```

  * 派生类中包含并且可以使用它从基类继承而来的成员，为了使用这些成员，派生类当然要知道它们是什么。因此该规定还有一层隐含的意思，即**一个类不能派生它本身**。

  * 一个类是基类，同时它也可以是一个派生类:

    ```c++
    class Base { /* ...*/ };
    class D1: public Base { /*...*/ };
    class D2: public DI {/*...*/ );
    /*在这个继承关系中，Base是D1的直接基类(direct base),同时是D2的间接基类(indirect base)。直接基类出现在派生列表中，而间接基类由派生类通过其直接基类继承而来。*/
    ```

  * **每个类都会继承直接基类的所有成员(递归)**。对于一个最终的派生类来说，它会继承其直接 基类的成员；该直接基类的成员又含有其基类的成员；依此类推直至继承链的顶端。因此, 最终的派生类将包含它的直接基类的子对象以及每个间接基类的子对象。

* 防止继承的发生

  * 有时我们会定义这样一种类，我们不希望其他类继承它，或者不想考虑它是否适合作为一个基类。为了实现这一目的，C++11新标准提供了一种防止继承发生的方法，即在类名后跟一个关键字final

##### 类型转换与继承

* 理解基类和派生类之间的类型转换是理解C++语言面向对象编程的关键所在.
* 通常情况下，如果我们想把引用或指针绑定到一个对象上，则引用或指针的类型应与对象的类型一致，或者对象的类型含有一 个可接受的const类型转换规则。存在继承关系的类是一个重 要的例外：**我们可以将基类的指针或引用绑定到派生类对象上**。
* 可以将基类的指针或引用绑定到派生类对象上有一层极为重要的含义：**当使用基类的 引用（或指针）时，实际上我们并不清楚该引用（或指针）所绑定对象的真实类型。该对 象可能是基类的对象，也可能是派生类的对象。**
* 和内置指针一样，**智能指针类也支持派生类向基类 的型转换**，这意味着我们可以将一个派生类对象的指针存储在一个基类的智 能指针内
* 静态类型与动态类型
  * 当我们使用存在继承关系的类型时，必须将一个变量或其他表达式的静态类型（static type）与该表达式表示对象的动态类型（dynamic type）区分开来。**表达式的静态类型在编 译时总是已知的，它是变量声明时的类型或表达式生成的类型：动态类型则是变量或表达式表示的内存中的对象的类型。动态类型直到运行时才可知**。
  * **如果表达式既不是引用也不是指针，则它的动态类型永远与静态类型一致。**我们无论如何都不能改变该变量对应的对象 的类型。
  * 基类的指针或引用的静态类型可能与其动态类型不一致

* 不存在从基类向派生类的隐式类型转换

  * 之所以存在派生类向基类的类型转换是因为**每个派生类对象都包含一个基类部分，而基类的引用或指针可以绑定到该基类部分上**。一个基类的对象既可以以独立的形式存在， 也可以作为派生类对象的一部分存在。如果基类对象不是派生类对象的一部分，则它只含有基类定义的成员，而不含有派生类定义的成员。因为**一个基类的对象可能是派生类对象的一部分，也可能不是，所以不存在从基类向派生类的自动类型转换**。

    ```c++
    Quote base;
    Bulk_quote* bulkP = &base; //错误：不能将基类转换成派生类
    Bulk_quote& bulkRef = base; //错误：不能将基类转换成派生类
    ```

  * **即使一个基类指针或引用绑定在一个派生类对象上，我们也不能执行从基类向派生类的转换**

    ```c++
    Bulk_quote bulk;
    Quote *itemP = &bulk;  		//正确：动态类型是Bul.k_quote 
    Bulk_quote *bulkP = itemP;	//错误：不能将基类转换成派生类
    ```

  * 编译器在编译时无法确定某个特定的转换在运行时是否安全，这是因为**编译器只能通过检査指针或引用的静态类型来推断该转换是否合法**。如果在基类中含有一个或多个虚函数， 我们可以使用 dynamic_cast 请求一个类型转换，该**转换的安全检査将在运行时**。同样，如果我们已知某个基类向派生类的转换是安全的，则我们可以使用 static_cast 来**强制覆盖掉编译器的检查工作**。

* 在对象之间不存在类型转换

  * 派生类向基类的自动类型转换只对指针或引用类型有效，**在派生类类型和基类类型之间不存在这样的转换**。很多时候，我们确实希望将派生类对象转换成它的基类类型，但是 这种转换的实际发生过程往往与我们期望的有所差别。

  * 请注意，当我们**初始化或赋值一个类类型的对象时，实际上是在调用某个函数**。当执行初始化时，我们调用**构造函数**；而当执行赋值操作时，我们调用**赋值运算符**。这些成员通常都包含一个参数，该参数的类型是类类型的const版本的引用。

  * **因为这些成员接受引用作为参数，所以派生类向基类的转换允许我们给基类的拷贝/ 移动操作传递一个派生类的对象(函数匹配)**。这些操作不是虚函数。当我们给基类的构造函数传递一 个派生类对象时，实际运行的构造函数是基类中定义的那个，显然该构造函数只能处理基 类自己的成员。类似的，如果我们将一个派生类对象赋值给一个基类对象，则实际运行的赋值运算符也是基类中定义的那个，该运算符同样只能处理基类自己的成员。

    ```
    Bulk_quote bulk;  //派生类对象
    Quote item(bulk);  // 使用 Quote: :Quote (const Quote&)构造函数
    item = bulk;   // 调用 Quote: :operat。—(const Quotes)
    ```

* 关键概念：存在继承关系的类型之间的转换规则
  * **从派生类向基类的类型转换只对指针或引用类型有效**。
  * **基类向派生类不存在隐式类型转换**。
  * 和任何其他成员一样，**派生类向基类的类型转换也可能会由于访问受限而变得不可行**。
  * 尽管自动类型转换只对指针或引用类型有效，但是继承体系中的大多数类仍然（显式或隐式地）**定义了拷贝控制成员**。因此，我**们通常能够将一个派生类对象拷贝、移动或赋值给一个基类对象. 不过需要注意的是，这种操作只处理派生类对象的基类部分。**

#### 虚函数

* 在C++语言中，当我们使用基类的引用或指针调用一个虚成员函数时会执行动态绑定。因为我们直到运行时才能知道到底调用了哪个版本的虚函数，所以所有虚函数都必须有定义。通常情况下，如果我们不使用某个函数，则无须为该函数提供定义。但是**我们必须为每一个虚函数都提供定义，而不管它是否被用到了，这是因为连编译器也无法确定到底会使用哪个虚函数。**

* **对虚函数的调用可能在运行时才被解析**
  * 当某个虚函数通过指针或引用调用时，编译器产生的代码直到运行时才能确定应该调 用哪个版本的函数。被调用的函数是与绑定到指针或引用上的对象的动态类型相匹配的那—个。
* 动态绑定只有当我们通过指针或引用调用虚函数时才会发生。
* 当我们通过一个具有普通类型（非引用非指针）的表达式调用虚函数时，在编译时就会将调用的版本确定下来。
* 关键概念：C++的多态性
  * OOP的核心思想是多态性（polymorphism ）
  * **有继承关系的多个类型称为多态类型，因为我们能使用这些类型的“多种形式"而无须在意它们的差异**。
  * 引用或指针的静态类型与动态类型不同这一事实正是C++语言支持多态性的根本所在。
  * 当我们使用基类的引用或指针调用基类中定义的一个函数时，我们并不知道该函数 真正作用的对象是什么类型，因为它可能是一个基类的对象也可能是一个派生类的对象。如果该函数是虚函数。则直到运行时才会决定到底执行哪个版本，判断的依据是引用或指针所绑定的对象的真实类型。
  * 另一方面，**对非虚函数的调用在编译时进行绑定**。类似的，**通过对象进行的函数（虚函数或非虚函数）调用也在编译时绑定。对象的类型是确定不变的，我们无论如何都不 可能令对象的动态类型与静态类型不一致**。因此，通过对象进行的函数调用将在编译时 绑定到该对象所属类中的函数版本上。
  * 当且仅当对通过指针或引用调用虚函数时，才会在运行时解析该调用，也只有在这种情况下对象的动态类型才有可能与静态类型不同。
* 派生类中的虚函数
* 当我们在派生类中覆盖了某个虚函数时，可以再一次使用virtual关键字指出该函 数的性质。然而这么做并非必须，因为**一旦某个函数被声明成虚函数，则在所有派生类中 它都是虚函数**。
* **一个派生类的函数如果覆盖了某个继承而来的虚函数，则它的形参类型必须与被它覆 盖的基类函数完全一致。同样，派生类中虚函数的返回类型也必须与基类函数匹配。**该规则存在一个例外，当**类的虚函数返冋类型是类本身的指针或引用时**，上述规则无效。
  * 如果D由B派生得到，则基类的虚函数可以返回B\*而派生类的对应函数可以返回D\*,只不过这样的返回类型要求从D到B的类型转换是可访问的。
* final 和 override 说明符
  * 派生类如果定义了一个函数与基类中虚函 数的名字相同但是形参列表不同，这仍然是合法的行为。编译器将认为新定义的这个函数与基类中原有的函数是相互独立的。这时，派生类的函数并没有覆盖掉基类中的版本。就实际的编程习惯而言，这种声明往往意味着发生了错误，因为我们可能原本希望派生类能 覆盖掉基类中的虚函数，但是一不小心把形参列表弄错了。
  * 要想调试并发现这样的错误显然非常困难。在C++11新标准中我们可以使用 override关键字来说明派生类中的虚函数。这么做的好处是在**使得程序员的意图更加清晰的同时让编译器可以为我们发现一些错误**，后者在编程实践中显得更加重要。如果我们使用override标记了某个函数，但该函数并没有覆盖已存在的虚函数，此时编译器将报错
  * 只有虚函数才能被覆盖
  * 我们还能把某个函数指定为final,如果我们巳经把函数定义成final 了，则之后任何尝试覆盖该函数的操作都将引发错误

* 虚函数与默认实参
  * 和其他函数一样，虚函数也可以拥有默认实参。**如果某次函数调用使用了默认实参，则该实参值由本次调用的静态类型决定。**
  * 换句话说，如果我们通过基类的引用或指针调用函数，则使用基类中定义的默认实参, 即使实际运行的是派生类中的函数版本也是如此。此时，传入派生类函数的将是基类函数 定义的默认实参。如果派生类函数依赖不同的实参，则程序结果将与我们的预期不符。
  * **如果虚函数使用默认实参，则基类和派生类中定义的默认实参最好一致**
* 回避虚函数的机制
  * 在某些情况下，我们**希望对虚函数的调用不要进行动态绑定，而是强迫其执行虚函数的某个特定版本**。使用作用域运算符可以实现这一目的  `var->classType::funcName(parameter list);` 该调用将在编译时完成解析。
  * **通常情况下，只有成员函数(或友元)中的代码才需要使用作用域运算符来回避虚函数的机制。**
* 什么时候我们需要回避虚函数的默认机制呢？
  * 通常是**当一个派生类的虚函数调用它覆盖的基类的虚函数版本时**。在此情况下，**基类的版本通常完成继承层次中所有类型都要 做的共同任务，而派生类中定义的版本需要执行一些与派生类本身密切相关的操作**。
  * 如果一个派生类虚函数需要调用它的基类版本，但是没有使用作用域运算符，则在运行时该週用将被解析为对派生类版本自身的调用，从而导致无限递归

#### 抽象基类

* 纯虚函数
  * 和普通的虚函数不一样，一个**纯虚函数无须定义**。我们通过在函数体的位置（即在声明语句的分号之前)书写=0就可以将一个虚函数说明为纯虚函数。其中，=0只能出现在类内部
* 含有纯虚函数的类是抽象基类
  * 含有(或者未经覆盖直接继承)纯虚函数的类是**抽象基类( abstract base class)**。抽象基类负责定义接口，而后续的其他类可以覆盖该接口。
  * 我们**不能(直接)创建一个抽象基类的对象**。
* 关键概念：重构
  * **重构负责重新设计类的体系以便将操作和/或数据从一个类移动到另一个类中**。对于面向对象的应用程序来说，重构是一种很普遍的现象
  * 一旦类被重构(或以其他方式被改变)，就意味着我们必须重新编译含有这些类的代码了。

#### 访问控制与继承

* **每个类分别控制自己的成员初始化过程，与之类似，每个类还分别控制着其成员对于派生类来说是否可访问(accessible)**

* 受保护的成员

  * **类使用protected关键字来声明那些它希望与派生类分享但是不想被其他公共访问使用的成员**。protected说明符可以看做是public和private中和后的产物

  * 和私有成员类似，受保护的成员对于类的用户来说是不可访问的。

  * 和公有成员类似，受保护的成员对于派生类的成员和友元来说是可访问的。

  * **派生类的成员或友元只能通过派生类对象来访问基类的受保护成员。派生类对于一 个基类对象中的受保护成员没有任何访问特权。**(友元不具有继承性)

    ```c++
    class Base {
    protected:
        int protMem;
    };
    
    class Child: Base {
        friend void test(Child&);
        friend void test(Base&);
        int j;
    };
    
    void test(Child& c) {
        c.j = c.protMem = 0;
    }
    void test(Base& b)  {
        b.protMem = 0; // error: 'int Base::protMem' is protected within this context
    }
    ```

* 公有、私有和受保护继承

  * 某个类对其继承而来的成员的访问权限受到两个因素影响：一是**在基类中该成员的访问说明符**，二是**在派生类的派生列表中的访问说明符**。
  * **派生访问说明符对于派生类的成员(及友元)能否访问其直接基类的成员没什么影响。对基类成员的访问权限只与基类中的访问说明符有关。**
  * 派生访问说明符的目的是为了对派生类继承的基类成员进行**授权控制**
    * 控制**派生类用户(包括派生类的派生类在内)**对于基类成员的访问权限
    * 控制**继承自派生类的新类**的访问权限

* 派生类向基类转换的可访问性

  * 派生类向基类的转换是否可访问由使用该转换的代码决 定，同时派生类的派生访问说明符也会有影响。假定D继承自B：
  * 只有当D公有地继承B时，用户代码才能使用派生类向基类的转换；如果D继承B 的方式是受保护的或者私有的，则用户代码不能使用该转换。
  * 不论D以什么方式继承B, D的成员函数和友元都能使用派生类向基类的转换；派生类向其直接基类的类型转换对于派生类的成员和友元来说永远是可访问的。
  * 如果D继承B的方式是公有的或者受保护的，则D的派生类的成员和友元可以使用D向B的类型转换；反之，如果D继承B的方式是私有的，则不能使用。

* 关键概念：类的设计与受保护的成员

  * 不考虑继承的话，我们可以认为一个类有两种不同的用户：**普通用户**和**类的实现者**, 其中，普通用户编写的代码使用类的对象，这部分代码只能访问类的公有(接口)成员； 实现者则负责编写类的成员和友元的代码，成员和友元既能访问类的公有部分，也能访 问类的私有(实现)部分。
  * 如果进一步考虑继承的话就会出现第三种用户，即**派生类用户**。基类把它希望派生类能够使用的部分声明成受保护的。普通用户不能访问受保护的成员.而派生类及其友元仍旧不能访问私有成员。
  * 和其他类一样，**基类应该将其接口成员声明为公有的；同时将属于其实现的部分分成两组：一组可供派生类访问，另一组只能由基类及基类的友元访问**。对于前者应该声明为受保护的，这样派生类就能在实现自己的功能时使用基类的这些操作和数据；对于后者应该声明为私有的。

* 友元与继承

  * 就像友元关系不能传递一样，友元关系同样也不能继承。 **基类的友元在访问派生类成员时不具有特殊性，类似的，派生类的友元也不能随意访问基类的成员**
  * **每个类负责控制自己的成员的访问权限，这种可访问 性包括了基类对象内嵌在其派生类对象中的情况。**
  * **当一个类将另一个类声明为友元时，这种友元关系只对做出声明的类有效。对于原来那个类来说，其友元的基类或者派生类不具有特殊的访问能力**

*  改变个别成员的可访问性

* 有时我们需要改变派生类继承的某个名字的访问级别，通过使用using声明可以达到这一目的

  ```c++
  class Base {
  public:
      std::size_t size() const { return n; }
  protected:
      std::size_t n;
  };
  
  class Derived: private Base {	// 注意：private 继承
  public:
      //保持对象尺寸相关的成员的访问级别
      using Base::size;
  protected:
      using Base::n;
  };
  /*因为Derived使用了私有继承，所以继承而来的成员size和n (在默认情况下)是 Derived的私有成员。然而，我们使用using声明语句改变了这些成员的可访问性。改变之后，Derived的用户将可以使用size成员，而Derived的派生类将能使用n。*/
  ```

* 通过在类的内部使用using声明语句，我们可以将该类的直接或间接基类中的任何可访问成员(例如，非私有成员)标记出来=using声明语句中名字的访问权限由该using 声明语句之前的访问说明符来决定。也就是说，如果一条using声明语句出现在类的 private部分，则该名字只能被类的成员和友元访问；如果using声明语句位于public 部分，则类的所有用户都能访问它；如果using声明语句位于protected部分，则该 名字对于成员、友元和派生类是可访问的。

* **派生类只能为那些它可以访问的名字提供using声明。**

* 默认的继承保护级别

  * 使用struct和class关键字定义的类具有不同的默认访问说明符。类似的，默认派生运算符也由定义派生类所用的关键字来决定。 默认情况下，**使用class关键字定义的派生类是私有继承的；而使用struct关键字定义的派生类是公有继承的**

    ```c++
    class B {
    public:
        int num;
    };
    
    struct C1: B {};
    class C2 : B {};
    C1 c1;
    c1.num = 100;
    C2 c2;
    c2.num = 200; //error: 'int B::num' is inaccessible within this context
    ```

  * 人们常常有一种错觉，认为在使用struct关键字和class关键字定义的类之间还 有更深层次的差别。事实上，**唯一的差别就是默认成员访问说明符及默认派生访问说明符;** 除此之外，再无其他不同之处。

  * 一个私有派生的类最好显式地将private声明出来，而不要仅仅依赖于默认的设置、显式声明的好处是可以令私有继承关系清晰明了，不至于产生误会

#### 继承中的类作用域

* 每个类定义自己的作用域，在这个作用域内我们定义类的成 员。**当存在继承关系时，派生类的作用域嵌套在其基类的作用域之内**。如果一个名字在派生类的作用域内无法正确解析，则编译器将继续在外层的基类作用域中寻找该名字的定义。
* 派生类的作用域位于基类作用域之内这一事实可能有点儿出人意料，毕竟在我们的程 序文本中派生类和基类的定义是相互分离开来的。不过也**恰恰因为类作用域有这种继承嵌套的关系，所以派生类才能像使用自己的成员一样使用基类的成员**。

* 在编译时进行名字查找

  * **一个对象、引用或指针的静态类型决定了该对象的哪些成员是可见的。**即使静态类型与动态类型可能不一致（当使用基类的引用或指针时会发生这种情况），但是我们能使用哪些成员仍然是由静态类型决定的。

* 名字冲突与继承

  * 和其他作用域一样，**派生类也能重用定义在其直接基类或间接基类中的名字，此时定义在内层作用域（即派生类）的名字将隐藏定义在外层作用域（即基类）的名字**

    ```c++
    struct Base {
        Base():num(0) {}
    protected:
        int num;
    };
    
    struct Derived: Base {
        Derived(int i) :num(i) {}
        int getMem() { return num; }
        int getMem1() { return Base::num; } // 通过作用域运算符来使用隐藏的成员
    protected:
        int num; // 隐藏基类成员
    };
    ```

* **通过作用域运算符来使用隐藏的成员**
  
* 我们可以通过作用域运算符来使用一个被隐藏的基类成员
  
* **除了覆盖继承而来的虚函数之外，派生类最好不要重用其他定义在基类中的名字**

* 关键概念：名字查找与继承 

  * 理解函数调用的解析过程对于理解C++的继承至关重要，假定我们调用`p->mem()`

  （或者 `obj.mem()`），则依次执行以下4个步骤：

  1. **首先确定p的静态类型**。因为我们调用的是一个成员，所以该类型必然是类类型
  2. **在p的静态类型对应的类中查找`mem`、如果我不到，则依次在直接基类中不断查找直至到达继承链的顶端**。如果找遍了该类及其基类仍然找不到，则编译器将报錯。一旦我到了`mem`,就进行常规的类型检查以确认对于当前找到的`mem`,**本次调用是否合法**。
  3. 假设调用合法，则编译器将**根据调用的是否是虚函数而产生不同的代码**：
     1. 如果`mem`是虚函数且我们是通过引用或指针进行的调用，则编译器产生的代
        码将在运行时确定到底运行该虚函数的哪个版本，依据是对象的动态类型。
     2. 反之，如果`mem`不是虚函数或者我们是通过对象（而非引用或指针）进行的 调用，则编译器将产生―个常规函数调用

* **一如往常，名字查找先于类型检查**

  * 如前所述，**声明在内层作用域的函数并不会重载声明在外层作用域的函数**。因此，定义派生类中的函数也不会重载其基类中的成员。和其他作用域一样，如果派生类（即内层作用域）的成员与基类（即外层作用域）的某个成员同名，贝派生类将在其作用域内隐藏该基类成员。**即使派生类成员和基类成员的形参列表不一致， 基类成员也仍然会被隐藏掉**

    ```c++
    struct Base {
        int memfcn();
        int memfcn(string);
    };
    
    struct Derived: Base {
        int memfcn(int);
    };
    
    Derived d; Base b;
    b.memfcn();
    b.memfcn("jack");
    d.memfcn(10);
    d.memfcn(); // error: no matching function for call to 'Derived::memfcn()'
    d.memfcn("jack"); // error: invalid conversion from 'const char*' to 'int' [-fpermissive]
    d.Base::memfcn();
    
    /*为了解析这条调用语句,编译器首先在Derived中査找名字memfcn；因为Derived
    确实定义了一个名为memfcn的成员，所以査找过程终止。一旦名字找到，编译器就不再 继续査找了。Derived中的memfcn版本需要一个int实参，而当前的调用语句无法提 供任何实参，所以该调用语句是错误的。*/
    ```

  * **一旦名字找到，编译器就不再 继续査找了。**

* 虚函数与作用域

  * 我们现在可以理解为什么基类与派生类中的虚函数必须有相同的形参列表了。**假如基类与派生类的虚函数接受的实参不同，则我们就无法通过基类的引用或指针调用派生类的虚函数了**。

* 覆盖重载的函数

  * 和其他函数一样，**成员函数无论是否是虚函数都能被重载**。派生类可以覆盖重载函数的0个或多个实例。**如果派生类希望所有的重载版本对于它来说都是可见的，那么它就需 要覆盖所有的版本，或者一个也不覆盖**。
  * 有时一个类仅需覆盖重载集合中的一些而非全部函数，此时，如果我们不得不覆盖基类中的每一个版本的话，显然操作将极其烦琐。
  * 一种好的解决方案是为重载的成员提供一条using声明语句，这样我们就无须覆盖基类中的每一个重载版本了。**using声明语句指定一个名字而不指定形参列表，所以一条基类成员函数的using声明语句就可以把该函数的所有重载实例添加到派生类作用域中。此时，派生类只需要定义其特有的函数就可以了，而无须为继承而来的其他函数重新定义。**
  * 类内using声明的一般规则同样适用于重载函数的名字； 基类函数的每个实例在派生类中都必须是可访问的。对派生类没有重新定义的重载版本的访问实际上是对using声明点的访问。

#### 构造函数与拷贝控制

* 和其他类一样，位于继承体系中的类也需要控制当其对象执行一系列操作时发生什么样的行为，这些操作包括创建、拷贝、移动、赋值和销毁。如果一个类(基类或派生类) 没有定义拷贝控制操作，则编译器将为它合成一个版本。当然，这个合成的版本也可以定 义成被删除的函数。

##### 虚析构函数

* **继承关系对基类拷贝控制最直接的影响是基类通常应该定义一个虚析构函数**，这样我们就能动态分配继承体系中的对象了。

* 如前所述，当我们delete 一个动态分配的对象的指针时将执行析构函数。如果该指针指向继承体系中的某个类型，则有可能出现指针的静态类型与被删除对象的动态类型不符的情况。和其他函数一样，我们通过在基类中将析构函数定义成虚函数以确履执行正确的析构函数版本

  ```c++
  class Quote {
  public:
      //如果我们删除的是一个指向派生类对象的基类指针，则需要虚析构函数
      virtual -Quote （） = default;	// 动态绑定析构函数
  }；
  ```

  和其他虚函数一样，析构函数的虚属性也会被继承。因此，无论Quote的派生类使用合 成的析构函数还是定义自己的析构函数，都将是虚析构函数。只要基类的析构函数是虚函 数，就能**确保当我们delete基类指针时将运行正确的析构函数版本**

* **如果基类的析构函数不是虚函数，则delete 一个指向派生类对象的基类指针将产生未定义的行为。**
* 之前我们曾介绍过一条经验准则，即如果一个类需要析构函数，那么它也同样需要拷贝和赋值操作。基类的析构函数并不遵循上述准则，它是一 个重要的例外。一个基类总是需要析构函数，而且它能将析构函数设定为虚函数。此时， 该析构函数为了成为虚函数而令内容为空，我们显然无法由此推断该基类还需要赋值运算符或拷贝构造函数。
* **虚析构函数将阻止合成移动操作**
  
  * 基类需要一个虚析构函数这一事实还会对基类和派生类的定义产生另外一个间接的 影响：如果一个类定义了析构函数，即使它通过=default的形式使用了合成的版本，编译器也不会为这个类合成移动操作

##### 合成拷贝控制与继承

* 基类或派生类的合成拷贝控制成员的行为与其他合成的构造函数、赋值运算符或析构函数类似：它们**对类本身的成员依次进行初始化、赋值或销毁的操作**。此外，这些**合成的成员还负责使用直接基类中对应的操作对一个对象的直接基类部分进行初始化、赋值或销 毁的操作**。
* 值得注意的是，**无论基类成员是合成的版本还是自定 义的版本都没有太大影响。唯一的要求是相应的成员应该可访问并且不是一个被删除的函数。**
* **其隐式的析构部分负责销毁类的成员。对于派生类的析构函数来说，它除了销毁派生类自己的成员外，还负责销毁派生类的直接基类； 该直接基类又销毁它自己的直接基类，以此类推直至继承链的顶端。**

* 派生类中删除的拷贝控制与基类的关系

  * 就像其他任何类的情况一样，基类或派生类也能出于同样的原因将其合成的默认构造用函数或者任何一个拷贝控制成员定义成被删除的函数。此外，某些定义基类的方式也可能导致有的派生类成员成为被删除的函数
  * 如果基类中的默认构造函数、拷贝构造函数、拷贝赋值运算符或析构函数是被删除 的函数或者不可访问，则派生类中对应的成员将是被删除的，原因是编译器不能使用基类成员来执行派生类对象基类部分的构造、赋值 或销毁操作。
  * **如果在基类中有一个不可访问或删除掉的析构函数，则派生类中合成的默认和拷贝构造函数将是被删除的，因为编译器无法销毁派生类对象的基类部分。**
  * 和过去一样，编译器将不会合成一个删除掉的移动操作。当我们使用=default请 求一个移动操作时，如果基类中的对应操作是删除的或不可访问的，那么派生类中该函数将是被删除的，原因是派生类对象的基类部分不可移动。同样，如果基类的析构函数是删除的或不可访问的，则派生类的移动构造函数也将是被删除的。

* 在基类无法被拷贝和移动时， 如果派生类希望它自己的对象能被移动和拷贝，则派生类需要自定义相应版本的构造函数。当然，**在这一过程中派生类还必须考虑如何移动或拷贝其基类部分的成员。在实际编程过程中，如果在基类中没有默认、拷贝或移动构造函数，则一般情况下派生类也不会定义相应的操作。**

  ```c++
  class B {
  public:
      B();
      B(const B&) = delete;
  //其他成员，不含有移动构造函数
  };
  
  class D : public B {
      //没有声明任何构造函数
  };
  D d;	//正确：D的合成默认构造函数使用B的默认构造函数
  D d2(d);	//错误：D的合成拷贝构造函教是被删除的
  D d3 (std: :move (d) ) ; //错误：隐式地使用D的被删除的拷贝构造函数
  ```

* 移动操作与继承

  * 如前所述，大多数基类都会定义一个虚析构函数。因此在默认情况下，基类通常不含 有合成的移动操作，而且在它的派生类中也没有合成的移动操作。

  * 因为基类缺少移动操作会阻止派生类拥有自己的合成移动操作，所以当我们确实需要 执行移动操作时应该首先在基类中进行定义。

    ```c++
    class Quote (
    public:
        Quote () = default;
        Quote (const Quotes) = default;
        Quote(Quote&&) = default;
        Quotes operator=(const Quotes) = default
        Quotes operator=(Quote&&) = default;
        virtual -Quote() = default;
    };
    /*通过上面的定义，我们就能对Quote的对象逐成员地分别进行拷贝、移动、赋值和销毁 操作了。而且除非Quote的派生类中含有排斥移动的成员，否则它将自动获得合成的移 动操作。*/
    ```

* 派生类的拷贝控制成员

  * **派生类构造函数在其初始化阶段中不但要初始化派生类自己的成员，还负责初始化派生类对象的基类部分**。因此，派生类的拷贝和移动构造函数在拷贝和移动自有成员的同时，也要拷贝和移动基类部分的成员。类似的，派生类赋值运算符也必须为其基类部分的成员赋值。
  * 和构造函数及赋值运算符不同的是，**析构函数只负责销毁派生类自己分配的资源**。如前所述，**对象的成员是被隐式销毁的**；类似的，派生类对象的基类部分也是自动销毁的。
  * 当派生类定义了拷贝或移动操作时，该操作负责拷贝或移动包括基类部分成员在内的整个对象

* 定义派生类的拷贝或移动构造函数

  * 当为派生类定义拷贝或移动构造函数时，我们通常使用对应的基类构造函数初始化对象的基类部分

    ```c++
    class Base { /*...*/ };
    class D: public Base {
    public:
        //默认情况下，基类的默认构造函数初始化对象的基类部分
        //要想使用拷贝或移动构造函数，我们必须在构造函数初始值列表中
        //显式地调用该构造函数
        D (const D& d) : Base (d)	// 拷贝基类成员
        /* D的成员的初始值*/ { /* ... */ }
        
        D (D&& d) : Base (std: :move (d) )	// 移动基类成员
        /* D的成员的初始值*/ { /* ... */ }
    }；
    ```

    初始值Base(d)将一个D对象传递给基类构造函数。尽管从道理上来说，Base可以包含 一个参数类型为D的构造函数，但是在实际编程过程中通常不会这么做。相反，Base(d) 一般会匹配Base的拷贝构造函数。D类型的对象d将被绑定到该构造函数的Base&形参 上。Base的拷贝构造函数负责将d的基类部分拷贝给要创建的对象。假如我们没有提供基类的初始值的话：

    ```C++
    // D的这个拷贝构造函数很可能是不正确的定义
    //基类部分被默认初始化，而非拷贝
    D (const D& d) /*成员初始值，但是没有提供基类初始值*/
    { /* ... */ }
    ```

    **在上面的例子中，Base的默认构造函数将被用来初始化D对象的基类部分**。假定D的构造函数从d中拷贝了派生类成员，则这个新构建的对象的配置将非常奇怪：它的Base成员被赋予了默认值，而D成员的值则是从其他对象拷贝得来的。

  * **在默认情况下，基类默认构造函数初始化派生类对象的基类部分。如果我们想拷贝(或移动)基类部分，则必须在派生类的构造函数初始值列表中显式地使用基类的拷贝(或移动)构造函数**

* 派生类赋值运算符

  * 与拷贝和移动构造函数一样，派生类的赋值运算符也必须显式地为其基类部分赋值：

    ```c++
    // Base::operator= (const Base&)不会被自动调用
    D &D::operator=(const D &rhs) {
        Base::operator=(rhs) ; // 为基类部分赋值
        //按照过去的方式为派生类的成员赋值
        //酌情处理自赋值及释放已有资源等情况
        return *this;
    }
    ```

    上面的运算符首先显式地调用基类赋值运算符，令其为派生类对象的基类部分赋值。基类的运算符(应该可以)正确地处理自赋值的情况，如果赋值命令是正确的，则**基类运算符将释放掉其左侧运算对象的基类部分的旧值，然后利用rhs为其赋一个新值。随后，我们继续进行其他为派生类成员赋值的工作。**

    值得注意的是，无论基类的构造函数或赋值运算符是自定义的版本还是合成的版本， 派生类的对应操作都能使用它们。例如，对于Base : :operator=的调用语句将执行Base 的拷贝赋值运算符，至于该运算符是由Base显式定义的还是由编译器合成的无关紧要。

* 派生类析构函数

  * 如前所述，**在析构函数体执行完成后，对象的成员会被隐式销毁**。类似的，对象的基类部分也是隐式销毁的。因此，和构造函数及赋值运算符不同的是，**派生类析构函数只负责销毁由派生类自己分配的资源**

    ```c++
    class D: public Base (
    public:
        // Base: : ~Base被自动调用执行
        ~D() { /*该处由用户定义清除派生类成员的操作*/ }
    }；
    ```

  * **对象销毁的顺序正好与其创建的顺序相反：派生类析构函数首先执行，然后是基类的析构函数，以此类推，沿着继承体系的反方向直至最后。**

* 在构造函数和析构函数中调用虚函数

  * 如我们所知，**派生类对象的基类部分将首先被构建。当执行基类的构造函数时，该对象的派生类部分是未被初始化的状态。类似的，销毁派生类对象的次序正好相反，因此当执行基类的析构函数时，派生类部分已经被销毁掉了。由此可知，当我们执行上述基类成员的时候，该对象处于未完成的状态。**
  * 为了能够正确地处理这种未完成状态，编译器认为对象的类型在构造或析构的过程中 仿佛发生了改变一样。也就是说，当我们构建一个对象时，需要把对象的类和构造函数的类看作是同一个；对虚函数的调用绑定正好符合这种把对象的类和构造函数的类看成同一 个的要求；对于析构函数也是同样的道理。上述的绑定不但对直接调用虚函数有效，对间 接调用也是有效的，这里的间接调用是指通过构造函数(或析构函数)调用另一个函数。
  * 为了理解上述行为，不妨考虑当基类构造函数调用虚函数的派生类版本时会发生什么 情况。这个虚函数可能会访问派生类的成员，毕竟，如果它不需要访问派生类成员的话， 则派生类直接使用基类的虚函数版本就可以了。然而，当执行基类构造函数时，它要用到 的派生类成员尚未初始化，如果我们允许这样的访问，则程序很可能会崩溃。
  * **如果构造函数或析构函数调用了某个虚函数，则我们应该执行与构造函数或析 构函数所属类型相对应的虚函数版本**

##### 继承的构造函数

* 在C++11新标准中，派生类能够重用其直接基类定义的构造函数。尽管如我们所知，这些构造函数并非以常规的方式继承而来，但是为了方便，我们不妨姑且称其为“继承” 的。**一个类只初始化它的直接基类**，出于同样的原因，**一个类也只继承其直接基类的构造函数。类不能继承默认、拷贝和移动构造函数。如果派生类没有直接定义这些构造函数， 则编译器将为派生类合成它们。**

* 派生类继承基类构造函数的方式是提供一条注明了(直接)基类名的using声明语句。**`using parentClass::parentClass;`**

* 通常情况下，using声明语句只是令某个名字在当前作用域内可见。而当作用于构造函数 时，using声明语句将令编译器产生代码。**对于基类的每个构造函数，编译器都生成一个 与之对应的派生类构造函数。**换句话说，对于基类的每个构造函数，编译器都在派生类中生成一个形参列表完全相同的构造函数。

  ```
  derived (parms) : base (args) ( }
  /*其中，derived是派生类的名字，base是基类的名字，parms是构造函数的形参列表，args 将派生类构造函数的形参传递给基类的构造函数。*/
  ```

* **如果派生类含有自己的数据成员，则这些成员将被默认初始化**

* 继承的构造函数的特点
  * 和普通成员的using声明不一样，**一个构造函数的using声明不会改变该构造函数的访问级别**。例如，不管using声明出现在哪儿，基类的私有构造函数在派生类中还是 一个私有构造函数；受保护的构造函数和公有构造函数也是同样的规则。
  * **一个using声明语句不能指定explicit或constexpr**。如果基类的构造函数是explicit 或者constexpr ，则继承的构造函数也拥有相同的属性。
  * **当一个基类构造函数含有默认实参时，这些实参并不会被继承。相反，派生类将获得多个继承的构造函数，其中每个构造函数分别省略掉一个含 有默认实参的形参。**例如，如果基类有一个接受两个形参的构造函数，其中第二个形参含 有默认实参，则派生类将获得两个构造函数：一个构造函数接受两个形参(没有默认实参)， 另一个构造函数只接受一个形参，它对应于基类中最左侧的没有默认值的那个形参。
  * 如果基类含有几个构造函数，则除了两个例外情况，大多数时候派生类会继承所有这些构造函数。
    * 第一个例外是**派生类可以继承一部分构造函数，而为其他构造函数定义自己 的版本**。如果派生类定义的构造函数与基类的构造函数具有相同的参数列表，则该构造函 数将不会被继承。定义在派生类中的构造函数将替换继承而来的构造函数。
    * 第二个例外是**默认、拷贝和移动构造函数不会被继承**。这些构造函数按照正常规则被合成。继承的构造函数不会被作为用户定义的构造函数来使用，因此，如果一个类只含有继承的构造函数，则它也将拥有一个合成的默认构造函数。

#### 容器与继承

* 当我们使用容器存放继承体系中的对象时，通常必须釆取间接存储的方式。因为不允许在容器中保存不同类型的元素，所以**我们不能把具有继承关系的多种类型的对象直接存 放在容器当中**。

* **当派生类对象被赋值给基类对象时，其中的派生类部分将被“切掉”，因此容 器和存在继承关系的类型无法兼容**

* 在容器中放置(智能)指针而非对象
  * 当我们希望在容器中存放具有继承关系的对象时，我们实际上存放的通常是基类的指 针(更好的选择是智能指针)。和往常一样，这些指针所指对象 的动态类型可能是基类类型，也可能是派生类类型
  * 正如我们可以将一个 派生类的普通指针转换成基类指针一样，我们也能把一个派生类的智能指针转换成基类的智能指针。
  
* **对于C++面向对象的编程来说，一个悖论是我们无法直接使用对象进行面向对象编程。相反，我们必须使用指针和引用。因为指针会增加程序的复杂性，所以我们经常定义—些辅助的类来处理这种复杂情况。**

* 模拟虚拷贝

  * `virtual ClassName* clons() const&;`

  * `virtual ClassName* clons() &&;`

#### 小节

* 继承使得我们可以编写一些新的类，这些**新类既能共享其基类的行为，又能根据需要覆盖或添加行为**。
* **动态绑定使得我们可以忽略类型之冋的差异**，其机理是在运行时根据对象的动态类型来选择运行函数的哪个版本。继承和动态绑定的结合使得我们能够编写具有特定类型行为但又独立于类型的程序。
* 在C++语言中，动态绑定只作用于虚函数，并且需要通过指针或引用调用。
* 在派生类对象中包含有与它的每个基类对应的子对象。因为所有派生.类对象都含有基 类部分，所以我们能将派生类的引用或指针转换为一个可访问的基类引用或指针。
* 当执行派生类的构造、拷贝、移动和賦值操作时，首先构造、拷贝、移动和赋值其中 的基类部分，然后才轮到派生类部分。析构函数的执行顺序则正好相反，首先销毁派生类， 接下来执行基类于对象的析构函数。基类通常都应该定义一个虚析构函数，即使基类根本 不需要析构函数也最好这么做。将基类的析构函数定义成虚函数的原因是为了确保当我们删除一个基类指针，而该指针实际指向一个派生类对象时，程序也能正确运行。
* 派生类为它的每个基类提供一个保护级別.public基类的成员也是派生类接口的一 部分；private基类的成员是不可访问的：protected基类的成员对于派生类的派生类 是可访问的，但是对于派生类的用户不可访问。