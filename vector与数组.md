#### 标准库类型vector

* 标准库类型**vector表示对象的集合**，其中**所有对象的类型都相同**。集合中的每个对 象都有一个与之对应的索引，索引用于访问对象。因为vector"容纳着”其他对象，所 以它也常被称作容器(container).

* C++语言既有类模板(class template),也有函数模板，其中vector是一个类模板。

* 模板本身不是类或函数，相反可以**将模板看作为编译器生成类或函数编写的一份说明**。编译器根据模板创建类或函数的过程称为**实例化**(instantiation), 当使用模板时，需要指出编译器应把类或函数实例化成何种类型。

* 对于类模板来说，我们**通过提供一些额外信息来指定模板到底实例化成什么样的类**， 需要提供哪些信息由模板决定。提供信息的方式总是这样：即在模板名字后面跟一对尖括号，在括号内放上信息。

* **引用不是对象，所以不存在包含引用的vector**。

* 定义和初始化vector对象

  ```
  vector<string> svec; //默认初始化，svec不含任何元素
  vector<int> ivec;
  vector<int> ivec2(ivec); vector<int> ivec3 = ivec; // 元素拷贝
  vector<int> invc4 = {1, 2, 3};// 列表初始化vector对象,用花括号括起来的0个或多个初始元素值被赋给vector对象
  vector<int> invc4(10, -1);//创建指定数量的元素
  ```

* 值初始化
  * 通常情况下，可以只提供Vector对象容纳的元素数量而不用略去初始值。此时库会 创建一个值初始化的（value-initialized）元素初值，并把它赋给容器中的所有元素。这个 初值由vector对象中元素的类型决定。
  * 如果vector对象的元素是内置类型，比如int,则元素初始值自动设为0。如果元素是某种类类型，比如string,则元素由类默认初始化：对这种初始化的方式有两个特殊限制:
    * 其一,有些类要求必须明确地提供初始值，如果vector对象中元素的类型不支持默认初始化，我们就必须提供初始的元素值。对这种类型的对象来说，只提供元素的数量而不设定初始值无法完成初始化工作。
    * 其二，如果只提供了元素的数量而没有设定初始值，只能使用直接初始化
  * **如果用的是圆括号，可以说提供的值是用来构造(construct) vector对象的。如果用的是花括号，可以表述成我们想列表初始化(list initialize)该vector对象。**也就是说，初始化过程会尽可能地把花括号内的值当成是元素初始值的列表来处理，只有在无法执行列表初始化时才会考虑其他初始化方式。
* 向vector对象中添加元素
  * push_back负责把一个值当成vector对象的尾元素“压至 (push)" vector对象的“尾端(back)”

* 关键概念：vector对象能高效增长 
  * vector应该能在运行时高效快速地添加元素。因此既然vector对 象能高效地增长，那么在定义vector对象的时候设定其大小也就没什么必要了，事实 上如果这么做性能可能更差。只有一种例外情况，就是所有（all）元素的值都一样。一 旦元素的值有所不同，更有效的办法是先定义一个空的vector对象，再在运行时向其中添加具体值。
  * 开始的时候创建空的vector对象，在运行时再动态添加元素，这一做法与C语言 及其他大多数语言中内置数组类型的用法不同。特别是如果用惯了 C或者Java,可以 预计在创建vector对象时顺便指定其容量是最好的。然而事实上，通常的情况是恰恰相反。
* **范围for语句体内不应改变其所遍历序列的大小。**
* 各个相等性运算符和关系运算符也与string的相应运算符功能一致。**两个vector对象相等当且仅当它们所含的元素个数相同，而且对应位置的元 素值也相同**。
* 关系运算符依照字典顺序进行比较：**如果两个vector对象的容量不同，但 是在相同位置上的元素值都一样，则元素较少的vector对象小于元素较多的vector对 国〉象;若元素的值有区别，则vector对象的大小关系由第一对相异的元素值的大小关系决定**。
* **只有当元素的值可比较时，vector对象才能被比较**。一些类，如string等，确实定义了自己的相等性运算符和关系运算符；
* 使用下标运算符能获取到指定的元素。和string一样， vector对象的下标也是从0开始计起，下标的类型是相应的size_type类型。只要 vector对象不是一个常量，就能向下标运算符返回的元素赋值。

* **vector对象(以及string对象)的下标运算符可用于访问和操作已存在的元素, 而不能用于添加元素。 只能对确知已存在的元素执行下标操作。**
  * 试图用下标的形式去访问一个不存在的元素将引发错误，不过这种错误不会被编译器发 现，而是在运行时产生一个不可预知的值。
  * 不幸的是，这种通过下标访问不存在的元素的行为非常常见，而且会产生很严重的后果。所谓的**缓冲区溢出(buffer overflow )**指的就是这类错误，这也是导致PC及其他设备上应用程序出现安全问题的一个重要原因。
  * 确保下标合法的一种有效手段就是尽可能使用范围for语句

#### 迭代器

* 除了 vector之外，标准库还定义了其他几种容器。所有标准库容器 都可以使用迭代器，但是其中只有少数几种才同时支持下标运算符。
* 严格来说，string 对象不属于容器类型，但是string支持很多与容器类型类似的操作。
* 类似于指针类型，**迭代器也提供了对对象的间接访问**。就迭代器而言，其对象是容器中的元素或者string对象中的字符。使用迭代器可以访问某个元素，迭代器也能从一个元素移动到另外一个元素。迭代器有有效和无效之分，这一点 和指针差不多。**有效的迭代器或者指向某个元素，或者指向容器中尾元素的下一位置**, 其他所有情况都属于无效。
* 使用迭代器
  * 和指针不一样的是，获取迭代器不是使用取地址符，有迭代器的类型同时拥有返回迭 代器的成员。比如，这些类型都拥有名为begin和end的成员，其中begin成员负责返回指向第一个元素（或第一个字符）的迭代器。end成员则负责返回指向容器（或string对象**）“尾元素的下一位置（one past the end）” **的迭代器，也就是说，该迭代器指示的是容器的一个本不存在的**“尾后（off the end）”**元 素。这样的迭代器没什么实际含义，仅是个标记而已，表示我们已经处理完了容器中的所 有元素。end成员返冋的迭代器常被称作**尾后迭代器（off-the-end iterator）或者简称为尾迭代器（end iterator）**特殊情况下如果容器为空，则 begin和end返回的是同一个迭 代器。
  * 如果容器为空，则begin和end返回的是同一个迭代器，都是尾后迭代器。
  * 一般来说，我们不清楚（不在意）迭代器准确的类型到底是什么。
* 迭代器运算符
  * 使用==和！=来比较两个合法的迭代器是否相 等，如果两个迭代器指向的元素相同或者都是同一个容器的尾后迭代器，则它们相等；否 则就说这两个迭代器不相等。
  * 迭代器的关系运算符，**如果某迭代器指向的容器位置在另一个迭代器所指位置之前，则说前者小于后者**。参与运算的两个迭代器必须指向的是同一个容器中的元素或者尾元素的下一位置
  * **两个迭代器相减的结果是它们之间的距离**，也就是说，将运算符右侧的迭 代器向前移动差值个元素后将得到左侧的迭代器。参与运算的两个迭代器 必须指向的是同一个容器中的元素或者尾元素的下一位置
  * **迭代器加上/减去一个整数值仍得一个迭代器**，迭代器指示的新位置与原来相比向左/向后移动了若干个元素。结果迭代器或者指示容器内的一个元素，或者指 示容器尾元素的下一位置
* 和指针类似，也**能通过解引用迭代器来获取它所指示的元素**，执行解引用的迭代器必须合法并确实指示着某个元素。**试图解引用一个非法迭代器或者尾后迭代器都是未被定义的行为。**
* 将迭代器从一个元素移动到另外一个元素
  * 迭代器使用递增（++）运算符来从一个元素移动到下一个 元素。从逻辑上来说，迭代器的递增和整数的递增类似，整数的递增是在整数值上“加1”, **迭代器的递增则是将迭代器“向前移动一个位置”**。
  * 因为end返回的迭代器并不实际指示某个元素，所以不能对其进行递增或解引用的操作。
* 关键概念：泛型编程
  * 原来使用C或Java的程序员在转而使用C++语言之后，会对for循环中使用 != 而 非< 进行判断有点儿奇怪。C++程序员习惯性地使用 != ,其原因和他们更愿意使用迭代器而非下标的原因一样：因为这种编程风格在标准库提供的所有容器上都有效。 
  * 之前已经说过，只有string和vector等一些标准库类型有下标运算符，而并非全都如此。与之类似，所有标准库容器的迭代器都定义了 ==和 !=，但是它们中的大多 数都没有定义< 运算符。因此，只要我们养成使用迭代器和 != 的习惯，就不用太在意用的到底是哪种容器类型。
* 迭代器类型
  * 就像不知道string和vector的size_type成员到底是什么类型一样，一般来说我们也不知道（无须知道）迭代器的精确类型。而实际上, 那些拥有迭代器的标准库类型使用iterator和const_iterator来表示迭代器的类型
  * const_iterator和常量指针差不多，能读取但不能修改它所指的元素值。相反，iterator的对象可读可写。如果vector对象或string对象是 一个常量，只能使用const_iterator；如果vector对象或string对象不是常量， 那么既能使用iterator也能使用const_iterator
* 术语：迭代器和迭代器类型
  * 迭代器这个名词有三种不同的含义：可能是**迭代器概念本身**，也可能是指**容器定义的迭代器类型**，还可能是指**某个迭代器对象**。
  * 重点是理解存在一组概念上相关的类型，我们认定某个类型是迭代器当且仅当它支持一套操作，这套操作使得我们能访问容器的元素或者从某个元素移动到另外一个元素。
  * 每个容器类定义了一个名为iterator的类型，该类型支持迭代器概念所规定的 一套操作。

* begin和end运算符
  * begin和end返回的具体类型由对象是否是常量决定，如果对象是常量，begin和 end返回const_iterator；如果对象不是常量，返回iterator

* 使用迭代器运算
  * 使用迭代器运算的一个经典算法是二分搜索。二分搜索从有序序列中寻找某个给定的值。二分搜索从序列中间的位置开始搜索，如果中间位置的元素正好就是要找的元素，搜索完成；如果不是，假如该元素小于要找的元素，则在序列的后半部分继续搜素；假如该元素大于要找的元素，则在序列的前半部分继续搜索。在缩小的范围中计算一个新的中间元素并重复之前的过程，直至最终找到目标或者没有元素可供继续搜索。

#### 数组

* 数组是一种类似于标准库类型vector 的数据结构，但是在性能和灵活性的权衡上又与vector有所不同。

* 与vector相似的地方是，数组也是**存放类型相同的对象的容器**，这些**对象本身没有名字，需要通过其所在位置访问**。与vector 不同的地方是，**数组的大小确定不变，不能随意向数组中增加元素**。因为数组的大小固定， 因此对某些特殊的应用来说程序的运行时性能较好，但是相应地也损失了一些灵活性。

* 如果不清楚元素的确切个数，请使用vector。

* 定义和初始化内置数组

  * 数组是一种**复合类型**。数组的声明形如a[d],其中a是**数组的名字**，d是**数组的维度**。维度说明了数组中元素的个数，因此必须大于0。数组中元素的个数也属于数组类型的一部分，编译的时候维度应该是已知的。也就是说，维度必须是一个常量表达式
  * 和内置类型的变量一样，如果在函数内部定义了某种内置类型的数组，那么默认初始化会令数组含有未定义的值
  * **定义数组的时候必须指定数组的类型**，不允许用auto关键字由初始值的列表推断类型。另外和vector一样，**数组的元素应为对象，因此不存在引用的数组**。

* 显式初始化数组元素

  * 可以对数组的元素进行列表初始化，此时允许忽略数组的维度。如果在声明时没有指明维度，编译器会根据初始值的数量计算并推测出来；相反， 如果指明了维度，那么初始值的总数量不应该超出指定的大小。如果维度比提供的初始值数量大，则用提供的初始值初始化靠前的元素，剩下的元素被初始化成默认值

* 字符数组的特殊性

  * 字符数组有一种额外的初始化形式，我们可以用字符串字面值。对此类数组初始化。当使用这种方式时，一定要注意字符串字面值的结尾处还有一个 空字符，这个空字符也会像字符串的其他字符一样被拷贝到字符数组中去

* 不允许拷贝和赋值

  * 不能将数组的内容拷贝给其他数组作为其初始值，也不能用数组为其他数组赋值

* 理解复杂的数组声明

  * 和vector 一样，数组能存放大多数类型的对象。例如，可以定义一个存放指针的数 组。又因为数组本身就是对象，所以允许定义数组的指针及数组的引用。在这几种情况中, 定义存放指针的数组比较简单和直接，但是定义数组的指针或数组的引用就稍微复杂一点了

    ```
    int *ptrs[10];// ptrs是含有10个整型指针的数组
    int &refs[10];  //错误：不存在引用的数组
    int (*Parray)[10] = &arr; // Parray指向一个含有10个整数的数组
    int (&arrRef)[10] = arr;// arrRef引用一个含有10个整数的数组
    int * (&arry) [10] = ptrs; // arry是数组的引用，该数组含有10个指向int类型的指针
    ```

  * 要想理解数组声明的含义，最好的办法是从数组的名字开始按照由内向外的顺序阅读

* 访问数组元素

  * 与标准库类型vector和string 一样，数组的元素也能使用范围for语句或下标运算符来访问。数组的索引从0开始
  * 在使用数组下标的时候，通常将其定义为size_t类型。size_t是一种机器相关的无符号类型，它被设计得足够大以便能表示内存中任意对象的大小。 在cstddef头文件 中定义了 size_t 类型
  * 数组除了大小固定这一特点外，其他用法与vector基本类似

* 检查下标的值

  * 与vector和string—样，数组的下标是否在合理范围之内由程序员负责检查，所谓**合理就是说下标应该大于等于0而且小于数组的大小**。要想防止数组下标越界，除了小心谨慎注意细节以及对代码进行彻底的测试之外，没有其他好办法。对于一个程序来说， 即使顺利通过编译并执行，也不能肯定它不包含此类致命的错误。

* **大多数常见的安全问题都源于缓冲区溢出错误，当数组或其他类似数据结构的下标越界并试图访问非法内存区域时，就会产生此类错误**

* 指针和数组

  * 在C++语言中，指针和数组有非常紧密的联系。使用数组的时候编译器一般会把它转换成指针。

  * 通常情况下，使用取地址符来获取指向某个对象的指针，取地址符可以用于任何对象。**数组的元素也是对象，对数组使用下标运算符得到该数组指定位置的元素**。因此像其他对象一样，对数组的元素使用取地址符就能得到指向该元素的指针

  * 然而，数组还有一个特性：**在很多用到数组名字的地方，编译器都会自动地将其替换 为一个指向数组首元素的指针**

    ```c++
    int arr[] = {1, 2, 3}
    int *first = &arr[0];
    int *p2 = arr; // 等价于 p2 = &arr[0]
    ```

  * 在一些情况下数组的操作实际上是指针的操作

  * **当使用数组作为一个auto 变量的初始值时，推断得到的类型是指针而非数组**

    ```
    int arr[] = {1,2,3};
    auto p1 = arr; // => auto p1 = &arr[0];
    // 必须指出的是，当使用decltype关键字时上述转换不会发 生，decltype（arr）返回的类型是由3个整数构成的数组
    ```

* 指针也是迭代器

  * 指向数组元素的指针拥有更多功能。vector 和string的迭代器支持的运算，数组的指针全都支持。例如， 允许使用递增运算符将指向数组元素的指针向前移动到下一个位置上,就像使用迭代器遍历vector对象中的元素一样，使用指针也能遍历数组中的元素。 当然，这样做的前提是先得**获取到指向数组第一个元素的指针和指向数组尾元素的下一位 置的指针**。之前已经介绍过，通过数组名字或者数组中首元素的地址都能得到指向首元素 的指针；

    ```
    int *start = arr; // 首元素指针
    int *end = &arr[size]; // 尾元素下一指针
    
    // 这里显然使用下标运算符索引了一个不存在的元素,那个不存在的元素唯一的用处就是提供其地址用于初始化end。就像尾后迭代器一样，尾后指针也不指向具体的元素。因此，不能对尾后指针执行解引用或递增的操作。
    ```

  * 标准库函数 begin 和 end
    * 尽管能计算得到尾后指针，但这种用法极易出错。为了让指针的使用更简单、更安全， C++11新标准引入了两个名为begin和end的函数。这两个函数与容器中的两个同名成员功能类似，不过数组毕竟不是类类型，因此这两个函数不是成员函数。正确的使用形式是将数组作为它们的参数

* 指针运算
  * 指向数组元素的指针可以执行所有迭代器运算。这些运算，包括解引用、递增、比较、与整数相加、两个指针相减等，用在指针 和用在迭代器上意义完全一致。
  * 给(从)一个指针加上(减去)某整数值，结果仍是指针。新指针指向的元素与原来的指针相比前进了(后退了)该整数值个位置
  * 给指针加上一个整数，得到的新指针仍需指向同一数组的其他元素，或者指向同一数组的尾元素的下一位置
  * 和迭代器一样，两个指针相减的结果是它们之间的距离。参与运算的两个指针必须指向同一个数组当中的元素
  * 两个指针相减的结果的类型是一种名为ptrdiff_t的标准库类型，和size_t 一样， ptrdiff_t也是一种定义在cstddef头文件中的机器相关的类型。因为差值可能为负值，所以ptrdiff_t是一种带符号类型。
  * 如果两个指针分别指向不相关的对象，则不能比较它们(比较毫无意义)
* 解引用和指针运算的交互
  * 指针加上一个整数所得的结果还是一个指针。假设结果指针指向了一个元素，则允许解引用该结果指针
  * 虽然标准库类型string和vector也能执行下标运算，但是数组与它们相比还是有所不同。**标准库类型限定使用的下标必须是无符号类型，而内置的下标运算无此要求**。内置的下标运算符可以处理负值，当然，结果地址必须指向原来的指针所指同一数组中的元素（或是同一数组尾元素的下一位置）

* C 风格字符串

* 字符串字面值是一种通用结构的实例，这种结构即是C++由C继承而来的C风格字符串 (C-style character string). **C风格字符串不是一种类型，而是为了表达和使用字符串而形成 的一种约定俗成的写法**。按此习惯书写的字符串存放在字符数组中并以空字符结束(null terminated). 以空字符结束的意思是在字符串最后一个字符后面跟着一个空字符.  —般利用指针来操作这些字符串。尽管C++支持C风格字符串，但在C++程序中最好还是不要使用它们.

*  比较字符串

  * 比较两个C风格字符串的方法和之前学习过的比较标准库string对象的方法大相径庭。比较标准库string对象的时候，用的是普通的关系运算符和相等性运算符。如果把这些运算符用在两个c风格字符串上，实际比较的将是指针而非字符串本身

* 连接或拷贝C风格字符串也与标准库string对象的同类操作差别很大， string 可以使用+操作符。同样的操作如果放到ca1和ca2这两个数组身上就会产生错误了。表达式ca1 + ca2 试图将两个指针相加，显然这样的操作没什么意义，也肯定是非法的。正确的方法是使用strcat函数和strcpy函数。不过要想使用这两个函数，还必须 提供一个用于存放结果字符串的数组，该数组必须足够大以便容纳下结果字符串及末尾的空字符。下面的代码虽然很常见，但是充满了安全风险，极易引发严重错误：

  ```
  //如果我们计算错了 largeStr的大小将引发严重错误
  strcpy (largeStr,	cal) ;	//	把 cal 拷贝给丄argeStr
  strcat (largeStr,	*' ”)；	//	在 largeStr 的末尾加上一个空格
  strcat (largeStr,	ca2) ;	//	把 ca2 连接至  largeStr 后面
  ```

  —个潜在的问题是，我们在估算largeStr所需的空间时不容易估准，而且largeStr 所存的内容一旦改变，就必须重新检查其空间是否足够。不幸的是，这样的代码到处都是, 程序员根本没法照顾周全。这类代码充满了风险而且经常导致严重的安全泄漏。

* 混用string对象和C风格字符串

  * 任何出现字符串字面值的地方都可以用以空字符结束的字符数组来替代
  * 允许使用以空字符结束的字符数组来初始化string对象或为string对象赋值
  * 在string对象的加法运算中允许使用以空字符结束的字符数组作为其中一个运 算对象(不能两个运算对象都是)；在string对象的复合赋值运算中允许使用以 空字符结束的字符数组作为右侧的运算对象
  * 如果程序的某处需要一个C风格字符串，无法直接用 string对象来代替它。为了完 成该功能，string专门提供了一个名为c_str的成员函数，c_str函数的返回值是一个C风格的字符串。也就是说，函数的返回结果是一个指针，该指针指向一个以空字符结束的字符数组，而这个数组所存的数据恰好与那个 string对象的一样。结果指针的类型是const char*,从而确保我们不会改变字符数 组的内容。
  * 针的类型是const char*,从而确保我们不会改变字符数 组的内容。
  * 我们无法保证c_str函数返回的数组一直有效，事实上，如果后续的操作改变了 string 的值就可能让之前返向的数组失去效用。**如果执行完c_str()函数后程序想一直都能使用其返回的数组，最好将该数 组重新拷贝一份**

* 用数组初始化vector对象

  * 允许使用数组来初始化vector对象。要 实现这一目的，只需指明要拷贝区域的首元素地址和尾后地址就可以了

    ```
    int int_arr[] = (0, 1, 2, 3, 4, 5};
    // ivec有6个元素，分别是int_arr中对应元素的副本
    vector<int> ivec(begin(int_arr), end(int_arr));
    // 在上述代码中，用于创建ivec的两个指针实际上指明了用来初始化的值在数组int_arr 中的位置，其中第二个指针应指向待拷贝区域尾元素的下一位置。
    ```

* 建议：尽量使川标准库类型而非数组

  * 使用指针和数组很容易出错。一部分原因是概念上的问题：指针常用于底层操作， 因此容易引发一些与烦琐细节有关的错误。其他问题则源于语法错误，特别是声明指针 时的语法错误。
  * 现代的C++程序应当尽量使用vector和迭代器，避免使用内置数组和指针；应该 尽量使用string,避免使用C风格的基于数组的字符串

* 多维数组

* 严格来说，**C++语言中没有多维数组，通常所说的多维数组其实是数组的数组。**

* 当**一个数组的元素仍然是数组**时，通常使用两个维度来定义它：一个维度表示数组本 身大小，另外一个维度表示其元素(也是数组)大小

* 按照由内而外的顺序阅读此类定义有助于更好地理解其真实含义。

* 对于二维数组来说，常把第一个维度称作行，第二个维度称作列。

* 多维数组的初始化

  * 允许使用花括号括起来的一组值初始化多维数组，这点和普通的数组一样。**多维数组的每一行分别用花括号括了起来** ，其中内层嵌套着的花括号并非必需的。

    ```c++
        int arr[2][3] = {   // 行区分类型的初始化
                {1, 2, 3},
                {4, 5, 6},
        };
        int arr2[2][3] = { {1}, {4} }; // 初始化每行的首元素
        int arr1[2][3] = {1, 2, 3, 4, 5, 6}; 
    ```

* 维数组的下标引用

  * 可以使用下标运算符来访问多维数组的元素，此时数组的每个维度对应一个下标运算符。

  * 如果表达式含有的下标运算符数量和数组的维度一样多，该表达式的结果将是给定类型的元素；反之，如果表达式含有的下标运算符数量比数组的维度小，则表达式的结果将是给定索引处的一个内层数组

    ```
    for(auto row:arr) 
        for(auto col:row)
            cout << col << '\t';
    /*
    程序将无法通过编译。这是因为，像之前一样第一个循环遍历arr的所有元素，注意这些元素实际上是数组。因为row不是引用类型，所以编译器初始化row时会自动将这些数组形式的元素(和其他类型的数组一样)转换成指向该数组内首元素的指针。 这样得到的row的类型就是int*,显然内层的循环就不合法了，编译器将试图在一个 int*内遍历，这显然和程序的初衷相去甚远。
    */
    ```

  * **要使用范围for语句处理多维数组，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型**

* 指针和多维数组

  * 当程序使用多维数组的名字时，也会自动将其转换成指向数组首元素的指针。

  * 定义指向多维数组的指针时，千万别忘了这个多维数组实际上是数组的数组。

  * 因为多维数组实际上是数组的数组，所以由**多维数组名转换得来的指针实际上是指向 第一个内层数组的指针**

    ```c++
        for(auto p = arr; p != arr+2; ++p) {    // p 为一个指向数组的指针； *p = &arr[col][0]
            for (auto q = *p; q != *p+3; ++q) { // q 为一个指向int的指针
                cout << *q << '\t';
            }
        }
    //---
    for(auto p = begin(arr); p != end(arr); p++)
        for(auto q = begin(*p); q != end(*p); q++)
            cout << *q << '\t';
    ```

#### 小结

* string和vector是两种最重要的标准库类型。**string对象是一个可变长的字符序列，vector对象是一组同类型对象的容器。**
* **迭代器允许对容器中的对象进行间接访问**，对于string对象和vector对象来说，可以通过迭代器访问元素或者在元素间移动。
* 数组和指向数组元素的指针在一个较低的层次上实现了与标准库类型string和 vector类似的功能。一般来说，应该优先选用标准库提供的类型，之后再考虑C++语言 内置的低层的替代品数组或指针。

#### 术语表

* begin是string和vector的成员，返 回指向第一个元素的迭代器。也是一个标准库函数，输入一个数组，返回指向该数 组首元素的指针。
* **缓冲区溢出(bufferoverflow) 一种严重的程序故障，主要的原因是试图通过一个越界的索引访问容器内容，容器类型包括 string、vector 和数组等。**
* C风格字符串(C-style string)以空字符结朿的字符数组。字符串字面值是C风格字符串，C风格字符串容易岀错。
* **类模板(class template)用于创建具体类类型的模板**。要想使用类模板，必须提供 关于类型的辅助信息。
* 编译器扩展(compilerextension)某个特 定的编译器为C++语言额外增加的特性。基于编译器扩展编写的程序不易移植到其 他编译器上。
* **容器(container)是一种类型，其对象容纳了一组给定类型的对象。**vector是一 种容器类型。
* **拷贝初始化(copy initialization)使用赋值号(=)的初始化形式。**新创建的对象是 初始值的一个副本。
* difference_type 由 string 和 vector 定 义的一种带符号整数类型，表示两个迭代器之间的距离。
* **直接初始化(direct initialization)不使用赋值号(=)的初始化形式。**
* empty是string和vector的成员，返 回一个布尔值。当对象的大小为0时返回 真，否则返回假.
* end是string和vector的成员，返回 一个尾后迭代器。也是一个标准库函数， 输入一个数组，返回指向该数组尾元素的下一位置的指针。
* getline在string头文件中定义的一个函 数，以一个istream对象利--个string 对象为输入参数。该函数首先读取输入流的 内容直到遇到换行符停止，然后将读入的数 据存入string对象，最后返回istream 对象。其中换行符读入但是不保留。
* 索引(index)是下标运算符使用的值。 表示要在string对象、vector对象或者数组中访问的一个位置。
* **实例化(instantiation)编译器生成一个指定的模板类或函数的过程。**
* **迭代器(iterator)是一种类型，用于访问容器中的元素或者在元素之间移动。**
* 迭代器运算(iterator arithmetic ) 是 string或vector的迭代器的运算：迭 代器与整数相加或相减得到一个新的迭代 器，与原来的迭代器相比，新迭代器向前或向后移动了若干个位置。两个迭代器相 减得到它们之间的距离，此时它们必须指向同一个容器的元素或该容器尾元素的下 一位置。
* **尾后迭代器(off-the-end iterator) end 函数返冋的迭代器，指向一个并不存在的 元素，该元素位于容器尾元素的下一位置。**
* 指针运算(pointer arithmetic)是指针类型支持的算术运算。指向数组的指针所支 持的运算种类与迭代器几乎一致。
* prtdiff_t是cstddef头文件中定义的一种 与机器实现有关的带符号整数类型，它的空间足够大，能够表示数组中任意两个指针之间的距髙。
* 范围for语句(range for) 一种控制语句， 可以在值的一个特定集合内迭代。
* size是string和vector的成员，分别 返冋字符的数量或元素的数量。返回值的 类型是 size_type
* size_t是cstddef头文件中定义的一种 与机器实现有关的无符号整数类型，它的 空间足够大，能够表示任意数组的大小。
* using 声明(using declaration) 令命名空 间中的某个名字可被程序直接使用。``using命名空间::名字；``
* **值初始化(value initialization)是一种初始化过程。内置类型初始化为0,类类型由类的默认构造函数初始化。只有当类包含默认构造函数时，该类的对象才会被值初始化. 对于容器的初始化来说，如果只说明了容器的大小而没有指定初始值的话， 就会执行值初始化。此时编译器会生成一 个值，而容器的元素被初始化为该值。**