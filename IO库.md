* C++语言不直接处理输入输出，而是通过一族定义在标准库中的类型来处理IO。这些 类型支持从设备读取数据、向设备写入数据的IO操作，设备可以是文件、控制台窗口等。 还有一些类型允许内存IO，即，从string读取数据，向string写入数据。
* IO库定义了读写内置类型值的操作。此外，一些类，如string,通常也会定义类似的IO操作，来读写自己的对象。

#### IO 类

* 到目前为止，我们已经使用过的IO类型和对象都是操纵char数据的。默认情况下， 这些对象都是关联到用户的控制台窗口的。当然，我们不能限制实际应用程序仅从控制台窗口进行IO操作，应用程序常常需要读写命名文件。而且，使用IO操作处理string中的字符会很方便。此外，应用程序还可能读写需要宽字符支持的语言。

| 头文件   | 类型                                                         |
| -------- | ------------------------------------------------------------ |
| iostream | istream, wistream从流读取数据; ostream. wostream向流写入数据;  iostream, wiostream 读写流 |
| fstream  | ifstream, wifstream从文件读取数据;  ofstream, wofstream向文件写入数据;  fstream, wfstream 读写文件 |
| sstream  | istringstream,  wistringstream 从 string 读取数据;  ostringstream, wostringstream 向 string 写入数据;  stringstream, wstringstream 读写 string |

* 为了支持使用宽字符的语言，标准库定义了一组类型和对象来操纵wchar_t类型的数据。宽字符版本的类型和函数的名字以一个w开始。例如， wcin、wcout和wcerr是分别对应cin、cout和cerr的宽字符版对象。**宽字符版本的类型**和对象与其对应的普通char版本的类型定义在同一个头文件中。例如，头文件 fstream 定义了 ifstream 和 wifstream 类型。
* IO类型间的关系
  * 概念上，**设备类型和字符大小都不会影响我们要执行的IO操作**。例如，我们可以用 >>读取数据，而不用管是从一个控制台窗口，一个磁盘文件,还是一个string读取。类似的，我们也不用管读取的字符能存入一个char对象内，还是需要一个wchar_t对象 来存储。
  * 标准库使我们能**忽略这些不同类型的流之间的差异**，这是通过继承机制（inheritance） 实现的。利用模板，我们可以使用具有继承关系的类，而不必了解继承机制如何工作的细节。
  * 简单地说，继承机制使我们可以声明一个特定的类继承自另一个类。我们通常可以**将 一个派生类（继承类）对象当作其基类（所继承的类）对象来使用**。
  * 类型ifstream和istringstream都继承自istream. 因此，我们可以像使用 istream对象一样来使用ifstream和istringstream对象。也就是说，我们是如何使用cin的，就可以同样地使用这些类型的对象。例如，可以对一个ifstream或 istringstream对象调用getline ,也可以使用 >>从一个ifstream 或 istringstream对象中读取数据。类似的，类型ofstream和ostringstream都继承自ostream。因此，我们是如何使用cout的，就可以同样地使用这些类型的对象。
* **IO对象无拷贝或赋值**
  * 由于不能拷贝IO对象，因此我们也不能将形参或返回类型设置为流类型。进行IO操作的函数通常以引用方式传递和返回流。读写一个IO对象会改变其状态，因此传递和返回的引用不能是const的。
* **条件状态（condition state）**
  * IO操作一个与生俱来的问题是可能发生错误。一些错误是可恢复的，而其他错误则发生在系统深处，已经超出了应用程序可以修正的范围。

* **一个流一旦发生错误，其上后续的IO操作都会失败**。只有当一个流处于无错状态时， 我们才可以从它读取数据，向它写入数据。由于流可能处于错误状态，因此**代码通常应该在使用一个流之前检査它是否处于良好状态**。确定一个流对象的状态的最简单的方法是将它当作一个条件来使用

* 查询流的状态

  * **将流作为条件使用，只能告诉我们流是否有效，而无法告诉我们具体发生了什么**。有 时我们也需要知道流为什么失败。例如，在键入文件结束标识后我们的应对措施，可能与遇到一个IO设备错误的处理方式是不同的。

  * IO库定义了一个与机器无关的iostate类型，它提供了表达流状态的完整功能。这个类型应作为一个位集合来使用。IO库定义了 4 个iostate类型的constexpr值， 表示特定的位模式。这些值用来表示特定类型的IO条件，可以与位运算符一起使用来一次性检测或设置多个标志位。
  * **badbit表示系统级错误**，如不可恢复的读写错误。通常情况下，一旦badbit被置位，流就无法再使用了。在**发生可恢复错误后，failbit被置位**，如期望读取数值却读出一个字符等错误。这种问题通常是可以修正的，流还可以继续使用。如果**到达文件结束位置，eofbit和failbit都会被置位**。**goodbit的值为0,表示流未发生错误**。如果 badbit、failbit和eofbit任一个被置位，则检测流状态的条件会失败。
  * 标准库还定义了一组函数来査询这些标志位的状态。**操作good在所有错误位均未置位的情况下返回true**,而bad、fail和eof则在对应错误位被置位时返回true。此外，在badbit被置位时，fail也会返回true。这意味着，使用good或fail是确定流的总体状态的正确方法。实际上，我们将流当作条件使用的代码就等价于!fail()而 eof和bad操作只能表示特定的错误。

* 管理条件状态
  * 流对象的rdstate成员返回一个iostate值，对应流的当前状态。setstate操作将给定条件位置位，表示发生了对应错误。clear成员是一个重载的成员：它有一个不接受参数的版本，而另一个版本接受一个iostate类型的参数。clear不接受参数的版本清除（复位）所有错误标志位。执行clear（）后，调用good 会返回true。
  * 带参数的clear版本接受一个iostate值，表示流的新状态。为了复位单一的条件状态位，我们首先用rdstate读出当前条件状态，然后用位操作将所需位复位来生成新的状态。
* 管理输出缓冲
  * **每个输岀流都管理一个缓冲区，用来保存程序读写的数据**。例如，如果执行下面的代码`os << "please enter a value: “;`文本串可能立即打印出来，但也有可能被操作系统保存在缓冲区中，随后再打印。**有了缓冲机制，操作系统就可以将程序的多个输出操作组合成单一的系统级写操作。由于设备的写操作可能很耗时，允许操作系统将多个输岀操作组合为单一的设备写操作可以带来很大的性能提升。**
* 导致缓冲刷新（即，数据真正写到输岀设备或文件）的原因有很多：
  * **程序正常结束**，作为main函数的return操作的一部分，缓冲刷新被执行。
  * **缓冲区满时**，需要刷新缓冲，而后新的数据才能继续写入缓冲区。
  * 我们可以**使用操纵符如 endl 来显式刷新缓冲区**。
  * 在每个输出操作之后，我们可以**用操纵符unitbuf设置流的内部状态，来清空缓冲区**。默认情况下，对cerr是设置unitbuf的，因此写到cerr的内容都是立即刷新的。
  * **一个输出流可能被关联到另一个流。在这种情况下，当读写被关联的流时，关联到的流的缓冲区会被刷新**。例如，默认情况下，cin和cerr都关联到cout。因此， 读cin或写cerr都会导致cout的缓冲区被刷新。

* 刷新输出缓冲区

  * 我们己经使用过操纵符endl,它完成换行并刷新缓冲区的工作。IO库中还有两个类似的操纵符：flush和ends。flush刷新缓冲区，但不输出任何额外的字符；ends向缓冲区插入一个空字符，然后刷新缓冲区.

    ```
    cout << "hi!” << endl; //输出hi和一个换行，然后刷新缓冲区
    cout « “hi!” « flush; //输出hi,然后刷新缓冲区，不附加任何额外字符
    cout « "hi!" « ends; //输出hi和一个空字符，然后刷新缓冲区
    ```

* unitbuf操纵符

  * 如果想在每次输出操作后都刷新缓冲区，我们可以使用unitbuf操纵符。它告诉流在接下来的每次写操作之后都进行一次flush操作。而nounitbuf操纵符则重置流， 使其恢复使用正常的系统管理的缓冲区刷新机制

    ```
    cout << unitbuf;	//所有输出操作后都会立即刷新缓冲区
    //任何输出都立即刷新，无缓冲
    cout << nounitbuf;	//回到正常的缓冲方式
    ```

* **警告：如果程序崩溃，输出缓冲区不会被刷新**
  * 如果程序异常终止，输出缓冲区是不会被刷新的。当一个程序崩溃后，它所输出的数据很可能停留在输出缓冲区中等待打印。
  * **当调试一个已经崩溃的程序时，需要确认那些你认为已经输出的数据确实已经刷新 . 否则，可能将大量时间浪费在追踪代码为什么没有执行上，而实际上代码已经执行 了，只是程序崩溃后缓冲区没有被刷新，输出数据被挂起没有打印而已。**
* 关联输入和输出流
  * 当一个输入流被关联到一个输出流时，任何试图从输入流读取数据的操作都会先刷新关联的输出流。标准库将cout和cin关联在一起 因此语句 `cin >> ival;` 导致cout的缓冲区被刷新。
  * **交互式系统通常应该关联输入流和输出流。这意味着所有输出，包括用户提示 信息，都会在读操作之前被打印出来**
  * tie有两个重载的版本：一个版本不带参数，返回指向输出流的指针。如果本对象当前关联到一个输出流，则返回的就是指向这个流的指针，如果对象未关联到流，则返回空指针。tie的第二个版本接受一个指向。stream的指针，将自己关联到此ostream。 即，x. tie（&o）将流x关联到输出流o。
  * **一个流同时最多关联到一个流， 但多个流可以同时关联到同一个ostream。**
* 文件输入输出
  * **头文件fstream定义了三个类型来支持文件IO： ifstream从一个给定文件读取数据， ofstream向一个给定文件写入数据，以及fstream可以读写给定文件。**
  * 这些类型提供的操作与我们之前已经使用过的对象cin和cout的操作一样。特别是， 我们可以用IO运算符（＜＜和＞＞）来读写文件，可以用 getline 从一个ifstream读取数据
  * 除了继承自iostream类型的行为之外，fstream中定义的类型还增加了一些新的成员来管理与流关联的文件。我们可以对fstream、 ifstream和ofstream对象调用这些操作，但不能对其他IO类型调用这些操作
* 使用文件流对象
  * 当我们想要读写一个文件时，可以定义一个文件流对象，并将对象与文件关联起来。
  * 每个文件流类都定义了一个名为 open 的成员函数，它完成一些系统相关的操作，来定位给定的文件，并视情况打开为读或写模式。
  * 创建文件流对象时，我们可以提供文件名（可选的）。如果提供了一个文件名，则 open 会自动被调用
  * 在新C++ 标准中，文件名既可以是库类型string对象，也可以是C风格字符数组。旧版本的标准库只允许C风格字符数组。
* 用 fstream 代替 iostream&
  * **在要求使用基类型对象的地方，我们可以用继承类型的对象来替代。**这意味着，接受一个iostream类型引用（或指针）参数的函数，可以用一个对应的 fstream （或sstream）类型来调用。也就是说，如果有一个函数接受一个ostream&参数，我们在调用这个函数时，可以传递给它一个ofstream对 象，对istream&和ifstream也是类似的。
* 成员函数open和close
  * 如果我们定义了一个空文件流对象，可以随后调用open来将它与文件关联起来. 如果调用open失败，failbit会被置位。因为调用 open 可能失败，进行 open 是否成功的检测通常是一个好习惯
  * **一旦一个文件流已经打开，它就保持与对应文件的关联。实际上，对一个已经打开的文件流调用。open 会失败，并会导致failbit被置位。随后的试图使用文件流的操作都会失败。为了将文件流关联到另外一个文件，必须首先关闭已经关联的文件。一旦文件成功关闭，我们可以打开新的文件.**

* **当一个fstream对象离开其作用域时，与之关联的文件会自动关闭。**
* **当一个fstream对象被销毁时，close会自动被调用。**
* 文件模式
  * 每个流都有一个关联的文件模式(file mode),用来指出如何使用文件
  * 无论用哪种方式打开文件，我们都可以指定文件模式，调用 open 打开文件时可以， 用一个文件名初始化流来隐式打开文件时也可以。指定文件模式有如下限制：
    * 只可以对ofstream或fstream对象设定out模式。
    * 只可以对ifstream或fstream对象设定in模式。
    * **通常情况下，out 模式意味着同时使用trunc模式**
    * 只有当out也被设定时才可设定trunc模式。
    * 只要trunc没被设定，就可以设定app模式。在app模式下，即使没有显式指定 ou t模式，文件也总是以输出方式被打开。
    * **默认情况下，即使我们没有指定trunc,以out模式打开的文件也会被截断。为 了保留以。ut模式打开的文件的内容，我们必须同时指定app模式，这样只会将数据追加写到文件末尾；或者同时指定in模式，即打开文件同时进行读写操作**

#### string 流

* sstream头文件定义了三个类型来支持内存IO,这些类型可以向string写入数据， 从string读取数据，就像string是一个IO流一样。
* istringstream 从 string 读取数据，ostringstream 向 string 写入数据， 而头文件stringstream既可从string读数据也可向string写数据。与fstream 类型类似，头文件sstream中定义的类型都继承自我们已经使用过的iostream头文件中定义的类型。除了继承得来的操作，sstream中定义的类型还增加了一些成员来管理与流相关联的操作，可以对stringstream对象调用这些操作，但不能对其他IO类型调用这些操作。
* 使用 istringstream
  * **当我们的某些工作是对整行文本进行处理，而其他一些工作是处理行内的单个单词时，通常可以使用istringstream;**
* 使用 ostringstream
  * **当我们逐步构造输出，希望最后一起打印时，ostringstream是很有用的。**