* C++语言定义了大量运算符以及内置类型的自动转换规则。这 些特性使得程序员能编写出形式丰富、含有多种混合类型的表达式。
* **当运算符被用于类类型的对象时，C++语言允许我们为其指定新的含义**；同时，我们也能**自定义类类型之间的转换规则**。和内置类型的转换一样，类类型转换隐式地将一种类型的对象转换成另一种我们所需类型的对象。
* 当运算符作用于类类型的运算对象时，可以通过运算符重载重新定义该运算符的含义。明智地使用运算符重载能令我们的程序更易于编写和阅读。

#### 基本概念

* **重载的运算符是具有特殊名字的函数**：它们的名字由关键字operator和其后要定义的运算符号共同组成。和其他函数一样，重载的运算符也包含返回类型、参数列表以及函数体。

* **重载运算符函数的参数数量与该运算符作用的运算对象数量一样多**。一元运算符有一个参数，二元运算符有两个。**对于二元运算符来说，左侧运算对象传递给第一个参数，而右侧运算对象传递给第二个参数**。除了重载的函数调用运算符。perator() 之外，其他重载运算符不能含有默认实参。

* **如果一个运算符函数是成员函数，则它的第一个（左侧）运算对象绑定到隐式的this 指针上**，因此，成员运算符函数的（显式）参数数量比运算符的运算对象总数少一个。

* **对于一个运算符函数来说，它或者是类的成员，或者至少含有一个类类型的参数**：

  ```c++
  //错误：不能为int重定义内置的运算符
  int operator+(int, int);
  ```

  这一约定意味着**当运算符作用于内置类型的运算对象时，我们无法改变该运算符的含义**。

* 我们可以重载大多数（但不是全部）运算符

* **我们只能重载已有的运算符，而无权发明新的运算符号**。例如，我们不能提供 operator\*\*来执行幕操作。

* **有四个符号（+、-、*、&）既是一元运算符也是二元运算符，所有这些运算符都能被重载，从参数的数量我们可以推断到底定义的是哪种运算符**。

* 对于一个重载的运算符来说，其优先级和结合律与对应的内置运算符保持一致。不考虑运算对象类型的话

  ```c++
  x == y + z; // 永远等价于
  x == （y + z）
  ```

* 直接调用一个重载的运算符函数

  * 通常情况下，我们**将运算符作用于类型正确的实参**，从而以这种**间接方式“调用”重载的运算符函数**。然而，我们也能像调用普通函数一样直接调用运算符函数，先指定函数名字，然后传入数量正确、类型适当的实参：

    ```c++
    // 一个非成员运算符函数的等价调用
    datal + data2 ；	//普通的表达式
    operator+ （datal, data2） ；	// 等价的函数调用
    ```

    这两次调用是等价的，它们都调用了非成员函数operator+,传入data1作为第一个实 参、传入data2作为第二个实参。

  * 我们**像调用其他成员函数一样显式地调用成员运算符函数**。具体做法是，首先指定运 行函数的对象（或指针）的名字，然后使用点运算符（或箭头运算符）访问希望调用的函数：

    ```c++
    datal+= data2;	//基于“调用”的表达式
    datal.operator+=(data2) ;	//对成员运算符函数的等价调用
    ```

    这两条语句都调用了成员函数operator+=,将this绑定到datal的地址、将data2 作为实参传入了函数。

* 某些运算符不应该被重载

  * 回忆之前介绍过的，**某些运算符指定了运算对象求值的顺序。因为使用重载的运算符本质上是一次函数调用，所以这些关于运算对象求值顺序的规则无法应用到重载的运算符上**。特别是，逻辑与运算符、逻辑或运算符和逗号运算符的运算对象求值顺序规则无法保留下来。除此之外，&&和丨|运算符的重载版本也无法保留内置运算符的短路求值属性，两个运算对象总是会被求值。
  * 因为上述运算符的重载版本无法保留求值顺序和/或短路求值属性，因此不建议重载它 们。当代码使用了这些运算符的重载版本时，用户可能会突然发现他们一直习惯的求值规则不再适用了。还有一个原因使得我们一般不重载逗号运算符和取地址运算符：C++语言已经定义了这两种运算符用于类类型对象时的特殊含义，这一点与大多数运算符都不相同。因为这两种运算符已经有了内置的含义，所以一般来说它们不应该被重载，否则它们的行为将异于常态，从而导致类的用户无法适应。

* 通常情况下，不应该重载逗号、取地址、逻辑与和逻辑或运算符。

* 使用与内置类型一致的含义

  * 当你开始设计一个类时，首先应该考虑的是这个类将提供哪些操作。在确定类需要哪些操作之后，才能思考到底应该把每个类操作设成普通函数还是重载的运算符。
  * 如果**某些操作在逻辑上与运算符相关，则它们适合于定义成重载的运算符**：
    * 如果类执行IO操作，则定义移位运算符使其与内置类型的IO保持一致。
    * 如果类的某个操作是检查相等性，则定义operator==, 如果类有了 operator==,意味着它通常也应该有operator !=
    * 如果类包含一个内在的单序比较操作，则定义operator<如果类有了 operator<,则它也应该含有其他关系操作。
    * **重载运算符的返回类型通常情况下应该与其内置版本的返回类型兼容**：逻辑运算符和关系运算符应该返回bool,算术运算符应该返回一个类类型的值，赋值运算符 和复合赋值运算符则应该返回左侧运算对象的一个引用。

* 提示：尽量明智地使用运算符

  * **每个运算符在用于内置类型时都有比较明确的含义**。以二元+运算符为例，它明显执行的是加法操作。因此，把二元+运算符映射到类类型的一个类似操作上可以极大地简化记忆。例如对于标准库类型string来说，我们就会使用+把一个string对象连接到另一个后面，很多编程语言都有类似的用法。
  * **当在内置的运算符和我们自己的操作之间存在逻辑映射关系时，运算符重载的效果最好**。此时，使用重载的运算符显然比另起一个名字更自然也更直观。不过，过分滥用运算符重载也会使我们的类变得难以理解。
  * 在实际编程过程中，一般没有特别明显的滥用运算符重载的情况。例如，一般来说没有哪个程序员会定义operator+并让它执行减法操作。然而经常发生的一种情况是， 程序员可能会强行扭曲了运算符的“常规”含义使得其适应某种给定的类型，这显然是我们不希望发生的。因此我们的建议是：**只有当操作的含义对于用户来说清晰明了时才使用运算符。如果用户对运算符可能有几种不同的理解，则使用这样的运算符将产生二义性。**

* 赋值和复合赋值运算符

  * 赋值运算符的行为与复合版本的类似：赋值之后，左侧运算对象和右侧运算对象的值相等，并且运算符应该返回它左侧运算对象的一个引用。重载的赋值运算应该继承而非违背其内置版本的含义。
  * **如果类含有算术运算符或者位运算符，则最好也提供对应的复合赋值运算符**。无须赘言，+=运算符的行为显然应该与其内置版本一致，即先执行+,再执行=。

* 选择作为成员或者非成员

  * 当我们定义重载的运算符时，必须首先决定是将其声明为类的成员函数还是声明为一个普通的非成员函数。在某些时候我们别无选择，因为有的运算符必须作为成员；另一些情况下，运算符作为普通函数比作为成员更好。

  * 下面的准则有助于我们在将运算符定义为成员函数还是普通的非成员函数做出抉择：

    * **赋值( = )、下标([])、调用(())和成员访问箭头(->)运算符必须是成员**。
    * **复合赋值运算符一般来说应该是成员**，但并非必须，这一点与赋值运算符略有不同。
    * **改变对象状态的运算符或者与给定类型密切相关的运算符，如递增、递减和解引用运算符，通常应该是成员。**
    * **具有对称性的运算符可能转换任意一端的运算对象，例如算术、相等性、关系和位 运算符等，因此它们通常应该是普通的非成员函数。**

  * **程序员希望能在含有混合类型的表达式中使用对称性运算符**。例如，我们能求一个 int 和一个 double 的和，因为它们中的任意一个都可以是左侧运算对象或右侧运算对象， 所以加法是对称的。**如果我们想提供含有类对象的混合类型表达式，则运算符必须定义成非成员函数。**

    * 当我们把运算符定义成成员函数时，它的左侧运算对象必须是运算符所属类的一个对象。例如：

      ```c++
      string s = "world**;
      string t = s + M ! ";	//正确：我们能把一个const char*加到一个string对象中
      string u = ”hi" + s; //如果+是string的成员，则产生错误
      ```

      如果operator+是string类的成员，则上面的第一个加法等价于s.operator+ ("!"). 同样的，"hi"+s 等价于"hi".operator+ (s). 显然"hi"的类型是 const char*.这 是一种内置类型，根本就没有成员函数。

      因为string将+定义成了普通的非成员函数，所以"hi"+s等价于 operator+("hi",s)和任何其他函数调用一样，每个实参都能被转换成形参类型。唯 一的要求是至少有一个运算对象是类类型，并且两个运算对象都能准确无误地转换成 string。

#### 输入和输出运算符

* io标准库分别使用>>和<<执行输入和输出操作。对于这两个运算符来说，IO库定义了用其读写内置类型的版本，而类则需要自定义适合其对象的新版本以支持IO操作。

##### 重载输出运算符<<

* 通常情况下，**输出运算符的第一个形参是一个非常量ostream对象的引用**。之所以 ostream是非常量是因为向流写入内容会改变其状态；而该形参是引用是因为我们无法 直接复制一个ostream对象。

* **第二个形参一般来说是一个常量的引用**，该常量是我们想要打印的类类型。第二个形参是引用的原因是我们希望避免复制实参；而之所以该形参可以是常量是因为(通常情况 F)打印对象不会改变对象的内容。

* 为了与其他输出运算符保持-,致，operator<<一般要返回它的ostream形参。

* **输出运算符尽量减少格式化操作**

  * 用于内置类型的输岀运算符不太考虑格式化操作，尤其不会打印换行符，用户希望类的输出运算符也像如此行事。如果运算符打印了换行符，则用户就无法在对象的同一行内 接着打印一些描述性的文本了。相反，令输出运算符尽量减少格式化操作可以使用户有权控制输出的细节。
  * 通常，输出运算符应该主要负责打印对象的内容而非控制格式，输出运算符不应该打印换行符

* **输入输出运算符必须是非成员函数**

  * 与iostream标准库兼容的输入输出运算符必须是普通的非成员函数，而不能是类的成员函数。否则，它们的左侧运算对象将是我们的类的一个对象：

    ```c++
    Sales_data data;
    data << cout; // 若operator<< 为类成员函数时
    ```

    因此，如果我们希望为类自定义 IO 运算符，则必须将其定义成非成员函数。当然, IO运算符通常需要读写类的非公有数据成员，所以。**运算符一般被声明为友元**

##### 重载输入运算符>>

* 通常情况下，输入运算符的**第一个形参是运算符将要读取的流的引用**，**第二个形参是将要读入到的（非常量）对象的引用**。该运算符通常会返回某个给定流的引用。第二个形 参之所以必须是个非常量是因为输入运算符本身的目的就是将数据读入到这个对象中。
* **输入运算符必须处理输入可能失败的情况，而输出运算符不需要。**
* 输入时的错误, 在执行输入运算符时可能发生下列错误：
  * **当流含有错误类型的数据时读取操作可能失败**。
  * **当读取操作到达文件末尾或者遇到输入流的其他错误时也会失败。**
  * 如果在发生错误前对象已经有一部分被改变，则适时地将对象置为合法状态显得异常重要。
  * 通过**将对象置为合法的状态，我们能(略微)保护使用者免于受到输入错误的影响**。 此时的对象处于可用状态，即它的成员都是被正确定义的。而且该对象也不会产生误导性的结果，因为它的数据在本质上确实是一体的。
  * **当读取操作发生错误时，输入运算符应该负责从错误中恢复**。
* **标示错误**
  * 一些输入运算符需要做更多数据验证的工作。例如，我们的输入运算符可能需要检查 bookNo 是否符合规范的格式。
  * 在这样的例子中，即使从技术上来看IO是成功的，输入运算符也应该设置流的条件状态以标示出失败信息。通常情况 下，输入运算符只设置 failbit。除此之外，设置 eofbit 表示文件耗尽，而设置 badbit 表示流被破坏。最好的方式是由 IO 标准库自己来标示这些错误。

#### 算术和关系运算符

* 通常情况下，我们把算术和关系运算符定义成非成员函数以允许对左侧或右侧的运算对象进行转换。因为这些运算符一般不需要改变运算对象的状态，所以形参都是常量的引用。
* **算术运算符通常会计算它的两个运算对象并得到一个新值，这个值有别于任意一个运算对象，常常位于一个局部变量之内，操作完成后返回该局部变量的副本作为其结果**。如果类定义了算术运算符，则它一般也会定义一个对应的复合赋值运算符。此时，最有效的方式是使用复合赋值来定义算术运算符
* **如果类同时定义了算术运算符和相关的复合赋值运算符，则通常情况下应该使用复合赋值来实现算术运算符。**

##### 相等运算符

* 通常情况下，C++中的类通过定义相等运算符来检验两个对象是否相等。也就是说， 它们会比较对象的每一个数据成员，只有当所有对应的成员都相等时才认为两个对象相等。
* 设计准则：
* **如果一个类含有判断两个对象是否相等的操作，则它显然应该把函数定义成 operator==而非一个普通的命名函数**：因为用户肯定希望能使用==比较对象， 所以提供了 ==就意味着用户无须再费时费力地学习并记忆一个全新的函数名字。 此外，类定义了==运算符之后也更容易使用标准库容器和算法。
* 如果类定义了 operator==,则该运算符应该能判断一组给定的对象中是否含有重复数据。
* 通常情况下，**相等运算符应该具有传递性**，换句话说，如果a==b和b==c都为真， 则a==c也应该为真。
* 如果类定义了 operator==,则这个类也应该定义operator ! =。对于用户来说， 当他们能使用==时肯定也希望能使用!=, 反之亦然。
* 相等运算符和不相等运算符中的一个应该把工作委托给另外一个，这意味着其中一 个运算符应该负责实际比较对象的工作，而另一个运算符则只是调用那个真正工作的运算符。
* **如果某个类在逻辑上有相等性的含义，则该类应该定义operator==**,这样做可以使得用户更容易使用标准库算法来处理这个类。

##### 关系运算符

* 定义了相等运算符的类也常常（但不总是）包含关系运算符。特别是，因为关联容器和一些算法要用到小于运算符，所以定义 operator< 会比较有用。
* 通常情况下关系运算符应该
  * **定义顺序关系**，令其与关联容器中对关键字的要求一致
  * **如果类同时也含有==运算符的话，则定义一种关系令其与==保持一致。特别是， 如果两个对象是 != 的，那么一个对象应该 < 另外一个。**
  * **如果存在唯一一种逻辑可靠的 < 定义，则应该考虑为这个类定义 < 运算符。如果类同时还包含==,则当且仅当 < 的定义和==产生的结果一致时才定义 < 运算符。**

##### 赋值运算符

* 之前已经介绍过拷贝赋值和移动赋值运算符，它们可以把类的一个对象赋值给该类的另一个对象。此外，类还可以定义其 他赋值运算符以使用别的类型作为右侧运算对象。

* 举个例子，在拷贝赋值和移动赋值运算符之外，标准库vector类还定义了第三种赋值运算符，该运算符接受花括号内的元素列表作为参数。我们 能以如下的形式使用该运算符

  ```CQL
  Class& operator=(std::initializer_list<type>);
  ```

  ```c++
  StrVec &StrVec::operator=(initializer_list<string> il)
  {
    // alloc_n_copy分配内存空间并从给定范围内拷贝元素
    auto data = alloc_n_copy(il.begin() , il.end());
    free() ;	一一 //销毁对象中的元素并释放内存空间
    elements = data.first; //更新数据成员使其指向新空间
    first_free = cap = data.second; return *this;
  }
  ```

* **和拷贝赋值及移动赋值运算符一样，其他重载的赋值运算符也必须先释放当前内存空间， 再创建一片新空间。**
* **我们可以重载赋值运算符。不论形参的类型是什么，赋值运算符都必须定义为成员函数。**

##### 复合赋值运算符

* 复合赋值运算符不非得是类的成员，不过我们还是**倾向于把包括复合赋值在内的所有赋值运算都定义在类的内部**。为了与内置类型的复合赋值保持一致，类中的复合赋值运算符也要返回其左侧运算对象的引用。

* 例如，下面是Sales_data类中复合赋值运算符的 定义：

  ```c++
  //作为成员的二元运算符：左侧运算对象绑定到隐式的this指针
  //假定两个对象表示的是同一本书
  Sales_data& Sales_data::operator+=(const Sales_data &rhs)
  {
  units_sold += rhs.units_sold; revenue += rhs.revenue;
  return *this;
  }
  ```

* 赋值运算符必须定义成类的成员，复合赋值运算符通常情况下也应该这样做. 这两类运算符都应该返回左侧运算对象的引用

##### 下标运算符

* 表示容器的类通常可以通过元素在容器中的位置访问元素，这些类一般会定义下标运算符 operator[]。

* 为了与下标的原始定义兼容，**下标运算符通常以所访问元素的引用作为返回值，这样做的好处是下标可以出现在赋值运算符的任意一端**。进一步，我们最好同时定义下标运算符的常量版本和非常量版本，当作用于一个常量对象时，下标运算符返回常量引用以确保 我们不会给返回的对象赋值。

* 如果一个类包含下标运算符，则它通常会定义两个版本：一个返回**普通引用**，另一个是类的常量成员并且返回**常量引用**

* 举个例子，我们按照如下形式定义 StrVec 的下标运算符：

  ```c++
  class StrVec  {
  public:
    std::strings operator[](std::size_t n)( return elements[n] ; }
    const std::strings operator[](std::size_t n) const
    { return elements[n]; }
  private:
    std: : string *elements;	//指向数组首元素的指针
  }；
  ```

  上面这两个下标运算符的用法类似于vector或者数组中的下标。因为下标运算符返回的是元素的引用，所以**当StrVec是非常量时，我们可以给元素赋值；而当我们对常量对象取下标时，不能为其赋值**

#### 增和递减运算符

* **在迭代器类中通常会实现递增运算符(++)和递减运算符这两种运算符使得类可以在元素的序列中前后移动**。C++语言并不要求递增和递减运算符必须是类的成员， 但是因为它们改变的正好是所操作对象的状态，所以建议将其设定为成员函数。
* **对于内置类型来说，递增和递减运算符既有前置版本也有后置版本。同样，我们也应该为类定义两个版本的递增和递减运算符**。

##### 前置版本

* 定义前置递增/递减运算符

* 为了说明递增和递减运算符，我们不妨在StrBlobPtr类中定义它们：

  ```c++
  class StrBlobPtr {
  public:
    //递増和递减运算符
    StrBlobPtr& operator++ () ;	// 前置运算符
    StrBlobPtr& operator—();
    //其他成员和之前的版本一致
  }；
  ```

  为了与内置版本保持一致，**前置运算符应该返回递増或递减后对象的引用。**

* 递增和递减运算符的工作机理非常相似：它们首先调用check函数检验StrBlobPtr是否有效，如果是，接着检查给定的索引值是否有效。如果check函数没有抛出异常，则运算符返回对象的引用。在递增运算符的例子中，我们把curr的当前值传递给check函数。如果这个值小 于vector的大小，则check正常返回；否则，如果curt已经到达了 vector的末尾， check将抛出异常：

  ```c++
  //前置版本：返回递増/递减对象的引用
  StrBlobPtr& StrBlobPtr::operator++()
  {
    //如果curr已经指向了容器的尾后位置，则无法递増它
    check (curr, "increment past end of StrBlobPtr*');
    ++curr;	//将curr在当前状态下向前移动一个元素
    return *this;
  }
  
  StrBlobPtr& StrBlobPtr::operator--()
  {
    //如果curr是0,则继续递减它将产生一个无效下标
    --curr;	//将curr在当前状态下向后移动一个元素
    check(curr, "decrement past begin of StrBlobPtr");
    return *this;
  }
  ```

  递减运算符先递减curr,然后调用check函数。此时，**如果curr (一个无符号数)已经是0 了，那么我们传递给check的值将是一个表示无效下标的非常大的正数值**。

* 区分前置和后置运算符
  * 要想同时定义前置和后置运算符，必须首先解决一个问题，即普通的重载形式无法区分这两种情况。前置和后置版本使用的是同一个符号，意味着其重载版本所用的名字将是相同的，并且运算对象的数量和类型也相同。
  * 为了解决这个问题，**后置版本接受一个额外的(不被使用)int类型的形参**。当我们使用后置运算符时，编译器为这个形参提供一个值为0的实参。尽管从语法上来说后置函数可以使用这个额外的形参，但是在实际过程中通常不会这么做。**这个形参的唯一作用就是区分前置版本和后置版本的函数，而不是真的要在实现后置版本时参与运算。**

##### 后置版本

* **对于后置版本来说，在递增对象之前需要首先记录对象的状态**

  ````c++
  /后置版本：递增/递减对象的值但是返回原值
  StrBlobPtr StrBlobPtr::operator++(int)
  {
    //此处无须检查有效性，调用前置递增运算时才需要检查
    StrBlobPtr ret = *this; // 记录当前的值
    ++*this;	//向前移动一个元素，前置++需要检查递增的有效性
    return ret;	//返回之前记录的状态
  }
  StrBlobPtr StrBlobPtr::operator-一(int)
  {
    //此处无须检查有效性，调用前置递减运算时才需要检查
    StrBlobPtr ret = *this;	// 记录当前的值
    --*this;	//向后移动一个元素，前置一需要检查递减的有效性
    return ret;	//返回之前记录的状态
  }
  // 因为我们不会用到int形参，所以无须为其命名
  ````

* **我们的后置运算符调用各自的前置版本来完成实际的工作**。

* 显式地调用后置运算符

  * 可以显式地调用一个重载的运算符，其效果与在表达式中以运算符号的形式使用它完全一样。如果我们想通过函数调用的方式调用后置版本，则**必须为它的整型参数传递一个值**：

    ```c++
    StrBlobPtr p (al) ;	// p 指向 al 中的 vector
    p.operator++ (0) ;	// 调用后置版本的 operator++
    p.operator++ () ;	// 调用前置版本的 operator++
    ```

    尽管传入的值通常会被运算符函数忽略，但却必不可少，因为编译器只有通过它才能知道 应该使用后置版本。

#### 成员访问运算符

* 在迭代器类及智能指针类中常常用到解引用运算符(*) 和箭头运算符(->)。

  ```c++
  class StrBlobPtr (
  public:
  std::strings operator*() const
  {
    auto p = check(curr, "dereference past end");
    return (*p) [curr] ;	// (*p)是对象所指的 vector
  }
  std::string* operator-> () const
  {
    //将实际工作委托给解引用运算符
    return & this->operator*();
  }
  ```

* **箭头运算符必须是类的成员。解引用运算符通常也是类的成员，尽管并非必须如此**