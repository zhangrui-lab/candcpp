### Que

```
为什么使用变量
数据如何在计算机内部表示.
数据运算的精度问题
进制与进制之间的运算
数据溢出问题
计算机数字编码技术
浮点数中精度和取值范围, 宽度的理解. 计算机如何实现浮点数计算
缓冲区的理解
c指针
思考结构到类的转变
如何理解未初始化的指针，以及未初始化的指针所带来的问题
理解复合字面量
联合的工作场景
```

### 起源

* 优缺点

```
1972年，贝尔实验室的丹尼斯·里奇（Dennis Ritch）和肯·汤普逊（Ken Thompson）在开发UNIX操作系统时设计了C语言.他是在B语言（汤普逊发明）的基础上进行设计.
C语言的设计理念让用户能轻松地完成自顶向下的规划、结构化编程和模块化设计.
C是高效的语言。c程序相对更紧凑，而且运行速度很快。实际上，C 语言具有通常是汇编语言才具有的微调控制能力（汇编语言是为特殊的中央处理单元设计的一系列内部指令，使用助记符来表示；不同的 CPU 系列使用不同的汇编语言），可以根据具体情况微调程序以获得最大运行速度或最有效地使用内存
C是可移植的语言
C语言功能强大且灵活
C语言是为了满足程序员的需求而设计的，程序员利用 C 可以访问硬件、操控内存中的位. C 语言在提供更多自由的同时，也让使用者承担了更大的责任。
---
C语言使用指针，而涉及指针的编程错误往往难以察觉
C 语言紧凑简洁，结合了大量的运算符。正因如此，我们也可以编写出让人极其费解的代码
```

* 应用范围

```
早在20世纪80年代，C语言就已经成为小型计算机（UNIX系统）使用的主流语言。从那以后，C语言的应用范围扩展到微型机（个人计算机）和大型机（庞然大物）
20世纪90年代，许多软件公司开始改用C++来开发大型的编程项目。 C++在C语言的基础上嫁接了面向对象编程工具（面向对象编程是一门哲学，它通过对语言建模来适应问题，而不是对问题建模以适应语言）。 C++几乎是C的超集，这意味着任何C程序差不多就是一个C++程序。学习C语言，也相当于学习了许多C++的知识。
为嵌入式系统编程
科学编程领域
开发操作系统
```

* 计算机能做什么

```
中央处理单元（CPU）承担绝大部分的运算工作。
随机存取内存（RAM）是存储程序和文件的工作区；
而永久内存存储设备（过去一般指机械硬盘，现在还包括固态硬盘）即使在关闭计算机后，也不会丢失之前储存的程序和文件。
还有各种外围设备（如，键盘、鼠标、触摸屏、监视器）提供人与计算机之间的交互。CPU负责处理程序
CPU 的工作非常简单。它从内存中获取并执行一条指令，然后再从内存中获取并执行下一条指令，诸如此类（一个吉赫兹的CPU一秒钟能重复这样的操作大约十亿次，因此，CPU 能以惊人的速度从事枯燥的工作）。CPU 有自己的小工作区——由若干个寄存器组成，每个寄存器都可以储存一个数字。一个寄存器储存下一条指令的内存地址，CPU使用该地址来获取和更新下一条指令。在获取指令后，CPU在另一个寄存器中储存该指令，并更新第1个寄存器储存下一条指令的地址。 CPU能理解的指令有限（这些指令的集合叫作指令集）。而且，这些指令相当具体，其中的许多指令都是用于请求计算机把一个数字从一个位置移动到另一个位置。例如，从内存移动到寄存器.

储存在计算机中的所有内容都是数字。计算机以数字形式储存数字和字符.每个字符都有一个数字码。计算机载入寄存器的指令也以数字形式储存，指令集中的每条指令都有一个数字码。
计算机程序最终必须以数字指令码（即，机器语言）来表示
计算机的工作原理是：如果希望计算机做某些事，就必须为其提供特殊的指令列表（程序），确切地告诉计算机要做的事以及如何做。
两数相加: (你要做的是，必须用数字码来表示以上的每个步骤！)
  1.从内存位置2000上把一个数字拷贝到寄存器1。 
  2.从内存位置2004上把另一个数字拷贝到寄存器2。 
  3.把寄存器2中的内容与寄存器1中的内容相加，把结果储存在寄存器1中。
  4.把寄存器1中的内容拷贝到内存位置2008。
```

* 高级计算机语言和编译器

```
高级编程语言（如，C）以多种方式简化了编程工作。首先，不必用数字码表示指令；其次，使用的指令更贴近你如何想这个问题，而不是类似计算机那样繁琐的步骤。使用高级编程语言，可以在更抽象的层面表达你的想法.不用考虑CPU在完成任务时具体需要哪些步骤.
在计算机看来，高级指令就是一堆无法理解的无用数据.
编译器是把高级语言程序翻译成计算机能理解的机器语言指令集的程序。程序员进行高级思维活动，而编译器则负责处理冗长乏味的细节工作。
编译器还有一个优势。一般而言，不同CPU制造商使用的指令系统和编码格式不同。例如，用Intel Core i7 （英特尔酷睿i7）CPU编写的机器语言程序对于ARM Cortex-A57 CPU而言什么都不是。但是，可以找到与特定类型CPU匹配的编译器。因此，使用合适的编译器或编译器集，便可把一种高级语言程序转换成供各种不同类型 CPU 使用的机器语言程序。一旦解决了一个编程问题，便可让编译器集翻译成不同 CPU 使用的机器语言.
高级语言（如C、Java、Pascal）以更抽象的方式描述行为，不受限于特定CPU或指令集
```

* 语言标准

```
1987年，布莱恩·柯林汉（Brian Kernighan）和丹尼斯·里奇（Dennis Ritchie）合著的The C Programming Language（《C语言程序设计》）第1版是公认的C标准，通常称之为K&R C 或经典C
ANSI C 定义了C语言和C标准库
ISO C和ANSI C是完全相同的标准。ANSI/ISO标准的最终版本通常叫作C89
C的精神:
  信任程序员； 
  不要妨碍程序员做需要做的事；
  保持语言精练简单； 
  只提供一种方法执行一项操作； 
  让程序运行更快，即使不能保证其可移植性。 (作为实现，应该针对目标计算机来定义最合适的某特定操作，而不是强加一个抽象、统一的定义)
1994年，ANSI/ISO联合委员会（C9X委员会）开始修订C标准，最终发布了C99标准
	支持国际化编程(提供多种方法处理国际字符集)
	调整现有实践致力于解决明显的缺陷
	提高计算的实用性
2011年终于发布了C11标准
	出于对当前编程安全的担忧，不那么强调“信任程序员”目标了
	不应要求服务小型机市场的供应商支持其目标环境中用不到的特性
	修订标准的原因不是因为原标准不能用，而是需要跟进新的技术。例如，新标准添加了可选项支持当前使用多处理器的计算机
```

* 组建C程序的几个基本步骤

```
1. 定义程序的目标
	在动手写程序之前，要在脑中有清晰的思路。想要程序去做什么首先自己要明确自己想做什么，思考你的程序需要哪些信息，要进行哪些计算和控制，以及程序应该要报告什么信息。在这一步骤中，不涉及具体的计算机语言，应该用一般术语来描述问题。
2. 设计程序
	对程序应该完成什么任务有概念性的认识后，就应该考虑如何用程序来完成它.除此之外，还要决定在程序（还可能是辅助文件）中如何表示数据，以及用什么方法处理数据. 通常，选择一个合适的方式表示信息可以更容易地设计程序和处理数 据。再次强调，应该用一般术语来描述问题，而不是用具体的代码。但是，你的某些决策可能取决于语言的特性.
3. 编写代码
	设计好程序后，就可以编写代码来实现它。也就是说，把你设计的程序翻译成C语言。这里是真正需要使用C语言的地方。可以把思路写在纸上， 但是最终还是要把代码输入计算机。这个过程的机制取决于编程环境，我们稍后会详细介绍一些常见的环境。一般而言，使用文本编辑器创建源代码文件。该文件中内容就是你翻译的C语言代码
4. 编译源代码
	编译器是把源代码转换成可执行代码的程序。可执行代码是用计算机的机器语言表示的代码。这种语言由数字码表示的指令组成。如前所述，不同的计算机使用不同的机器语言方案。C 编译器负责把C代码翻译成特定的机器语言。此外，C编译器还将源代码与C库（库中包含大量的标准函数供用户使用，如printf()和scanf()）的代码合并成最终的程序（更精确地说，应该是由一个被称为链接器的程序来链接库函数，但是在大多数系统中，编译器运行链接器）。其结果是，生成一个用户可以运行的可执行文件，其中包含着计算机能理解的代码。编译器还会检查C语言程序是否有效。如果C编译器发现错误，就不生成可执行文件并报错
5. 运行程序: 可执行文件是可运行的程序
6. 测试和调试程序
	程序能运行是个好迹象，但有时也可能会出现运行错误。接下来，应该检查程序是否按照你所设计的思路运行。你会发现你的程序中有一些错误，计算机行话叫作bug。查找并修复程序错误的过程叫调试
7. 维护和修改代码
	创建完程序后，你发现程序有错，或者想扩展程序的用途，这时就要修改程序.

编程并非像描述那样是一个线性的过程。有时，要在不同的步骤之间往复.
刚开始学习时，编写的程序非常简单，完全可以在脑中构思好整个过程。即使写错了，也很容易发现。但是，随着编写的程 序越来越庞大、越来越复杂，动脑不动手可不行，而且程序中隐藏的错误也越来越难找。最终，那些跳过前两个步骤的人往往浪费了更多的时间，因为 他们写出的程序难看、缺乏条理、让人难以理解。要编写的程序越大越复杂，事先定义和设计程序环节的工作量就越大。 磨刀不误砍柴工，应该养成先规划再动手编写代码的好习惯，用纸和笔记录下程序的目标和设计框架。这样在编写代码的过程中会更加得心应手、 条理清晰.
```

* 编程机制 

```
用C语言编写程序时，编写的内容被储存在文本文件中，该文件被称为源代码文件（source code file）
C编程的基本策略是，用程序把源代码文件转换为可执行文件（其中包含可直接运行的机器语言代码）
典型的C实现通过编译和链接两个步骤来完成这一过程。编译器把源代码转换成中间代码，链接器把中间代码和其他代码合并，生成可执行文件. C 使用这种分而治之的方法方便对程序进行模块化，可以独立编译单独的模块，稍后再用链接器合并已编译的模块。通过这种方式，如果只更改某个模块，不必因此重新编译其他模块。另外，链接器还将你编写的程序和预编译的库代码合并.
中间文件有多种形式。我们在这里描述的是最普遍的一种形式，即把源代码转换为机器语言代码，并把结果放在目标代码文件（或简称目标文件）中.虽然目标文件中包含机器语言代码， 但是并不能直接运行该文件。因为目标文件中储存的是编译器翻译的源代码，这还不是一个完整的程序.
目标代码文件缺失启动代码（startup code）。启动代码充当着程序和操作系统之间的接口. 例如，可以在MS Windows或Linux系统下运行IBM PC兼容机。这两种情况所使用的硬件相同，所以目标代码相同，但是Windows和 Linux所需的启动代码不同，因为这些系统处理程序的方式不同。
目标代码还缺少库函数。几乎所有的C程序都要使用C标准库中的函数.
链接器的作用是，把你编写的目标代码、系统的标准启动代码和库代码这3部分合并成一个文件，即可执行文件。对于库代码，链接器只会把程序中要用到的库函数代码提取出来.

简而言之，目标文件和可执行文件都由机器语言指令组成的。然而，目标文件中只包含编译器为你编写的代码翻译的机器语言代码，可执行文件中还包含你编写的程序中使用的库函数和启动代码的机器代码.

输入源代码 =》 文件编辑器 =》 源代码 =》 编译器 =》 目标代码文件 =》 链接器 =》可执行文件 =》运行程序 

GNU项目始于1987年，是一个开发大量免费UNIX软件的集合（GNU的 意思是“GNU’s Not UNIX”，即GNU不是UNIX）
Linux是一个开源、流行、类似于UNIX的操作系统，可在不同平台（包 括PC和Mac）上运行
C编译器不是标准Windows软件包的一部分，因此需要从别处获取并安装C编译器。可以从互联网免费下载Cygwin和MinGW，这样便可在PC上通过命令行使用GCC编译器。

源代码文件应该是文本文件，不是字处理器文件（字处理器文件包含许多额外的信息，如字体和格式等）。因此，要使用文本编辑器（如， Windows Notepad）来编辑源代码。如果使用字处理器，要以文本模式另存文件。源代码文件的扩展名应该是.c。一些字处理器会为文本文件自动添 加.txt 扩展名。如果出现这种情况，要更改文件名，把txt替换成c。通常，C编译器生成的中间目标代码文件的扩展名是.obj
```

### 数据和C

```
关键字：int 、short、long、unsigned、char、float、double、_Bool、 _Complex、_Imaginary
程序离不开数据。把数字、字母和文字输入计算机，就是希望它利用这些数据完成某些任务.
两大数据类型：
	整数类型
	浮点数类型
非交互式程序与交互式程序
数据，即承载信息的数字和字符。有些数据类型在程序使用之前已经预先设定好了，在整个程序的运行过程中没有变化，这些称为常量（constant）。其他数据类型在程序运行期间可能会改变或被赋值，这些称为变量（variable）。不仅变量和常量不同，不同的数据类型之间也有差异。（储存方式不同；他们所在的数据类型的数据集合的大小， 可表达范围 =》 数据本身的大小）
位、字节和字是描述计算机数据单元或存储单元的术语。这里主要指存储单元。
	最小的存储单元是位（bit），可以储存0或1（或者说，位用于设 置“开”或“关”）。虽然1位储存的信息有限，但是计算机中位的数量十分庞大。位是计算机内存的基本构建块。
	字节（byte）是常用的计算机存储单位。对于几乎所有的机器，1字节均为8位。这是字节的标准定义，至少在衡量存储单位时是这样。 既然1位可以表示0或1，那么8位字节就有256（2的8次方）种可能的0、1的组合。通过二进制编码（仅用0和1便可表示数字），便可表示0～255的整数或一组字符。
	字（word）是设计计算机时给定的自然存储单位。对于8位的微型计算机（如，最初的苹果机）， 1个字长只有8位。从那以后，个人计算机字长增至16位、32位，直到目前的64位。计算机的字长越大，其数据转移越快， 允许的内存访问也更多。
	
计算机把浮点数分成小数部分和指数部分来表示，而且分开储存这两部分。 计算机在内部使用二进制和2的幂进行储存，而不是10的幂。
整数没有小数部分，浮点数有小数部分。 浮点数可以表示的范围比整数大。
对于一些算术运算（如，两个很大的数相减），浮点数损失的精度更多。因为在任何区间内（如，1.0 到 2.0 之间）都存在无穷多个实数，所以计算机的浮点数不能表示区间内所有的值。浮点数通常只是实际值的近似值。 过去，浮点运算比整数运算慢。不过，现在许多CPU都包含浮点处理器，缩小了速度上的差距。

为什么一种类型不够用？因为C语言让程序员针对不同情况选择不同的类型。特别是，C语言中的整数类型可表示不同的取值范围和正负值。一般情况使用int类型即可，但是为满足特定任务和机器的要求，还可以选择其他类型。

一般而言，储存一个int要占用一个机器字长。C规定int的取值范围最小 为-32768～32767（16位）。
一般而言，系统用一个特殊位的值表示有符号整数的正负号。
变量声明： int a; =》 为变量赋予名称并创建和标记存储空间。
初始化变量(为变量赋一个初始值)： a = 12;
int dogs, cats = 94; => 只初始化了cats，并未初始化dogs

八进制和十六进制记数系统在表达与计算机相关的值时很方便。 十六进制数的每一位的数恰好由4位二进制数表示， 八进制数的每一位的数恰好由3位二进制数表示。 
0x或0X前缀表示十六进制值。 0前缀表示八进制。 使用不同的进制数是为了方便，不会影响数被储存的方式。
short int类型（或者简写为short）占用的存储空间可能比int类型少，常用于较小数值的场合以节省空间。与int类似，short是有符号类型。
long int或long占用的存储空间可能比int多，适用于较大数值的场合。与 int类似，long是有符号类型。 
long long int或long long（C99标准加入）占用的储存空间可能比long多， 适用于更大数值的场合。该类型至少占64位。与int类似，long long是有符号类型。
unsigned int或unsigned只用于非负值的场合。这种类型与有符号类型表示的范围不同。 无符号整型可以表示更大的数

C语言只规定了short占用的存储空间不能多于int， long占用的存储空间不能少于int。这样规定是为了适应不同的机器。例如， 过去的一台运行Windows 3的机器上，int类型和short类型都占16位，long类 型占32位。后来，Windows和苹果系统都使用16位储存short类型，32位储存 int类型和long类型（使用32位可以表示的整数数值超过20亿）。现在，计算 机普遍使用64位处理器，为了储存64位的整数，才引入了long long类型。

short 和 int 的最小取值范围是[−32767,32767]；对于32位机，long的最小取值范围是[−2147483647,2147483647]。对于unsigned short和unsigned int，最小取值范 围是[0,65535]；对于unsigned long，最小取值范围是[0,4294967295]。long long类型是为了支持64位的需求

考虑unsigned类型。这种类型的数常用于计数，因为计数不用负数。而且，unsigned类型可以表示更大的正数。
如果一个数超出了int类型的取值范围，且在long类型的取值范围内时， 使用long类型。然而，对于那些long占用的空间比int大的系统，使用long类型会减慢运算速度。因此，如非必要，请不要使用long类型。另外要注意一点：如果在long类型和int类型占用空间相同的机器上编写代码，当确实需要 32位的整数时，应使用long类型而不是int类型，以便把程序移植到16位机后仍然可以正常工作。类似地，如果确实需要64位的整数，应使用long long类型
通常，只有当程序使用相对于系统可用内存较大的整型数组时， 才需要重点考虑节省空间的问题。使用short类型的另一个原因是，计算机中某些组件使用的硬件寄存器是16位。

要把一个较小的常量作为long类型对待，可以在值的末尾加上l（小 写的L）或L后缀。 在支持long long类型的系统中，也可以使用ll或LL后缀来表示 long long类型的值，如3LL。另外，u或U后缀表示unsigned long long，如 5ull。

溢出行为是未定义的行为，C 标准并未定义有符号类型的溢出规则。

char类型用于储存字符（如，字母或标点符号），但是从技术层面看，char是整数类型。因为char类型实际上储存的是整数而不是字符。计算机使用数字编码来处理字符，即用特定的整数表示特定的字符。
标准ASCII码的范围是0～127，只需7位二进制数即可表示。
C语言把1字节定义为char类型占用的位（bit）数，因此无论是16位还是32位系统，都可以使用char类型。
在C语言中，用单引号括起来的单个字符被称为字符常量。编译器一发现'A'，就会将其转换成相应的代码值。（特定数字编码进行编码之后的值）。实际上，字符是以数值形式储存的，所以也可使用数字代码值来赋值。

非打印字符：单引号只适用于字符、数字和标点符号，浏览ASCII表会发现，有些 ASCII 字符打印不出来。
	使用ASCII码
	使用特殊的符号序列（转义序列）
	八进制或十六进制数前加上一个反斜杠
有些C编译器把char实现为有符号类型，这意味着char可表示的范围 是-128～127。而有些C编译器把char实现为无符号类型，那么char可表示的 范围是0～255。
unsigned char表示无符号类型。这在用char类型处理小整数时很有用。如果只用char处理字符，那么char前面无需使用任何修饰符。
C99标准添加了_Bool类型，用于表示布尔值，即逻辑值true和false。因为C语言用值1表示true，值0表示false，所以_Bool类型实际上也是一种整数类型。但原则上它仅占用1位存储空间，因为对0和1而言，1位的存储空间足够了。
可移植的类型名：
  精确宽度整数类型
  最小宽度类型
  最快最小宽度类型
  最大的无符号整数类型
  
浮点类型能表示包括小数在内更大范围的数。浮点数的表示类似于科学记数法（即用小数乘以10的幂来表示数字）。该记数系统常用于表示非常大或非常小的数.
C标准规定，float类型必须至少能表示6位有效数字，且取值范围至少是 10-37～10+37。前一项规定指float类型必须至少精确表示小数点后的6位有效数字，如33.333333。后一项规定用于方便地表示诸如太阳质量（2.0e30千 克）、一个质子的电荷量（1.6e-19库仑）或国家债务之类的数字。通常， 系统储存一个浮点数要占用32位。其中8位用于表示指数的值和符号，剩下24位用于表示非指数部分（也叫作尾数或有效数）及其符号.
C语言提供的另一种浮点类型是double（意为双精度）。double类型和float类型的最小取值范围相同，但至少必须能表示10位有效数字。一般情况 下，double占用64位而不是32位。一些系统将多出的 32 位全部用来表示非指数部分，这不仅增加了有效数字的位数（即提高了精度），而且还减少了 舍入误差。另一些系统把其中的一些位分配给指数部分，以容纳更大的指 数，从而增加了可表示数的范围。无论哪种方法，double类型的值至少有13 位有效数字，超过了标准的最低位数规定。
C只保证long double类型至少与double类型的精度相同。

float some = 4.0 * 2.0; 通常，4.0和2.0被储存为64位的double类型，使用双精度进行乘法运算，然后将乘积截断成float类型的宽度。这样做虽然计算精度更高，但是会减慢程序的运行速度。

当计算导致数字过大，超过当前类型能表达的范围时，就会发生上溢。
当除以一个很小的数时，情况更为复杂。回忆一下，float类型的数以指数和尾数部分来储存。存在这样一个数，它的指数部分是最小值，即由全部可用位表示的最小尾数值。该数字是float类型能用全部精度表示的最小数字。现在把它除以 2。通常，这个操作会减小指数部分，但是假设的情况中，指数已经是最小值了。所以计算机只好把尾数部分的位向右移，空出第 1 个二进制位，并丢弃最后一个二进制数。以十进制为例，把一个有4位有效数字的数（如，0.1234E-10）除以10，得到的结果是0.0123E-10。虽然得到了结果，但是在计算过程中却损失了原末尾有效位上的数字。这种情况叫 作下溢（underflow）。C语言把损失了类型全精度的浮点值称为低于正常的（subnormal）浮点值。因此，把最小的正浮点数除以 2将得到一个低于正常 的值。如果除以一个非常大的值，会导致所有的位都为0

一般而言，long类型占用的内存比short类型大，int类型的宽度要么和long类型相同，要么和short类型相同
无符号整型只能用于表示零和正整数，因此无符号整型可表示的正整数比有符号整型的大。出于历史原因，1字节通常是8位，但是如果要表示基本字符集，也可以是16位或更大。

计算机中的浮点数和整数在本质上不同，其存储方式和运算过程有很大区别。即使两个32位存储单元储存的位组合完全相同，但是一个解释为float 类型，另一个解释为long类型，这两个相同的位组合表示的值也完全不同。
```

* 类型转换

```
当类型转换出现在表达式时，无论是unsigned还是signed的char和short 都会被自动转换成int，如有必要会被转换成unsigned int。由于都是从较小类型转换为较大类型，所以这些转换被称为升级 （promotion）。
涉及两种类型的运算，两个值会被分别转换成两种类型的更高级别。
类型的级别从高至低依次是long double、double、float、unsigned long long、long long、unsigned long、long、unsigned int、int。例外的情况是，当 long 和 int 的大小相同时，unsigned int比long的级别高。之所以short和char类 型没有列出，是因为它们已经被升级到int或unsigned int.
在赋值表达式语句中，计算的最终结果会被转换成被赋值变量的类型。这个过程可能导致类型升级或降级（demotion）。所谓降级，是指把一 种类型转换成更低级别的类型。
当作为函数参数传递时，char和short被转换成int，float被转换成 double。函数原型会覆盖自动升级.
类型升级通常都不会有什么问题，但是类型降级会导致真正的麻烦。原 因很简单：较低类型可能放不下整个数字。
```

### 字符输入和输出管理

```
为什么要有缓冲区？首先，把若干字符作为一个块进行传输比逐个发送这些字符节约时间。其次，如果用户打错字符，可以直接通过键盘修正错误。当最后按下Enter键时，传输的是正确的输入。

缓冲分为两类：完全缓冲I/O和行缓冲I/O。完全缓冲输入指的是当缓冲区被填满时才刷新缓冲区（内容被发送至目的地），通常出现在文件输入 中。缓冲区的大小取决于系统，常见的大小是 512 字节和 4096字节。行缓 冲I/O指的是在出现换行符时刷新缓冲区。键盘输入通常是行缓冲输入，所以在按下Enter键后才刷新缓冲区。

文件（file）是存储器中储存信息的区域。通常，文件都保存在某种永 久存储器中（如，硬盘、U盘或DVD等）。毫无疑问，文件对于计算机系统 相当重要。

从较低层面上，C可以使用主机操作系统的基本文件工具直接处理文件，这些直接调用操作系统的函数被称为底层 I/O （low-level I/O）。 由于计算机系统各不相同，所以不可能为普通的底层I/O函数创建标准库， ANSI C也不打算这样做。然而从较高层面上，C还可以通过标准I/O包 （standard I/O package）来处理文件。这涉及创建用于处理文件的标准模型和一套标准I/O函数。在这一层面上，具体的C实现负责处理不同系统的差异，以便用户使用统一的界面。

不同的系统储存文件的方式不同。 有些系统把文件的内容储存在一处，而文件相关的信息储存在另一处；有些系统在文件中创建一份文件描述。在处理文件方面，有些系统使用单个换行符标记行末尾，而其他系统可能使用回车符和换行符的组合来表示行末尾。 有些系统用最小字节来衡量文件的大小，有些系统则以字节块的大小来衡量。

从概念上看，C程序处理的是流而不是直接处理文件。流（stream）是一个实际输入或输出映射的理想化数据流。这意味着不同属性和不同种类的输入，由属性更统一的流来表示。于是，打开文件的过程就是把流与文件相关联，而且读写都通过流来完成。

C把输入和输出设备视为存储设备上的普通文件，尤其是把键盘和显示设备视为每个C程序自动打开的文件。

计算机操作系统要以某种方式判断文件的开始和结束。检测文件结尾的一种方法是，在文件末尾放一个特殊的字符标记文件结尾。 操作系统使用的另一种方法是储存文件大小的信息。如果文件有3000字节，程序在读到3000字节时便达到文件的末尾。MS-DOS 及其相关系统使用这种方法处理二进制文件，因为用这种方法可以在文件中储存所有的字符， 包括Ctrl+Z。新版的DOS也使用这种方法处理文本文件。UNIX使用这种方法处理所有的文件。

在C语言中，读取文件检测到文件结尾时将返回一个特殊的值，即EOF（end of file的缩写）。某些系统也许把EOF定义为-1以外的值，但是定义的值一定与输入字符所产生的返回值不同。如果包含stdio.h文件，并使用EOF符号，就不必担心 EOF值不同的问题。这里关键要理解EOF是一个值，标志着检测到文件结尾，并不是在文件中找得到的符号。

输入和输出涉及函数、数据和设备。

在默认情况下，C程序使用标准I/O包查找标准输入作为输入源。这就是前面介绍过的stdin流，它是把数据读入计算机的常用方式。它可以是一个过时的设备，如磁带、穿孔卡或电传打印机，或者（假设）是键盘，甚至是一些先进技术，如语音输入。然而，现代计算机非常灵活，可以让它到别处查找输入。尤其是，可以让一个程序从文件中查找输入，而不是从键盘。

程序可以通过两种方式使用文件。第 1 种方法是，显式使用特定的函数打开文件、关闭文件、读取文件、写入文件，诸如此类。第2种方法是，设计能与键盘和屏幕互动的程序，通过不同的渠道重定向输入至文件和从文件输出。换言之，把stdin流重新赋给文件。继续使用getchar()函数从输入流中获取数据，但它并不关心从流的什么位置获取数据。虽然这种重定向的方法在某些方面有些限制，但是用起来比较简单.

重定向的一个主要问题与操作系统有关，与C无关。尽管如此，许多C 环境中（包括UNIX、Linux和Windows命令提示模式）都有重定向特性，而且一些C实现还在某些缺乏重定向特性的系统中模拟它。

C程序把输入作为传入的字节流。getchar()函数把每个字符解释成一个字符编码。scanf()函数以同样的方式看待输入，但是根据转换说明，它可以把字符输入转换成数值。许多操作系统都提供重定向，允许用文件代替键盘输入，用文件代替显示器输出。

程序通常接受特殊形式的输入。可以在设计程序时考虑用户在输入时可能犯的错误，在输入验证部分处理这些错误情况，让程序更强健更友好.对于一个小型程序，输入验证可能是代码中最复杂的部分。处理这类问 题有多种方案。例如，如果用户输入错误类型的信息，可以终止程序，也可 以给用户提供有限次或无限次机会重新输入。
```

### 函数

```
C的设计思想是，把函数用作构件块.
函数（function）是完成特定任务的独立程序代码单元。

使用函数可以省去编写重复代码的苦差。如果程序要多次完成某项任务，那么只需编写一个合适的函数，就可以在需要时使用这个函数，或者在不同的程序中使用该函数.
函数让程序更加模块化，从而提高了程序代码的可读性，更方便后期修改、完善。
描述性的函数名能清楚地表达函数的用途和组织结构。然后，单独设计和测试每个函数，直到函数都能正常完成任务。如果这些函数够通用，还可以用于其他程序。
许多程序员喜欢把函数看作是根据传入信息（输入）及其生成的值或响应的动作（输出）来定义的“黑盒”。如果不是自己编写函数，根本不用关心黑盒的内部行为。函数有助于把注意力集中在程序的整体设计，而不是函数的实现细节上。因此，在动手编写代码之前，仔细考虑一下函数应该完成什么任务，以及函数和程序整体的关系。

函数原型（function prototype）告诉编译器函数 xx() 的类型； (函数和变量一样，有多种类型。任何程序在使用函数之前都要声明该函数的类型; 并告诉编译器在别处查找该函数的定义)
函数定义（function definition）明确地指定了函数要做什么。
函数调用（function call）表明在此处执行函数； 
函数原型指明了函数的返回值类型和函数接受的参数类型。 这些信息称为该函数的签名（signature）.首先函数头包括函数类型、 函数名和圆括号，接着是左花括号、变量声明、函数表达式语句，最后以右花括号结束.

把函数都放在一个文件中的单文件形式比较容易编译，而使用多个文件方便在不同的程序中使用同一个函数。

声明函数时必须声明函数的类型。带返回值的函数类型应该与其返回值 类型相同，而没有返回值的函数应声明为void类型。
类型声明是函数定义的一部分。要记住，函数类型指的是返回值的类型，不是函数参数的类型。
要正确地使用函数，程序在第 1 次使用函数之前必须知道函数的类型。提前声明函数，把函数的信息告知编译器。

C允许函数调用它自己，这种调用过程称为递归（recursion）。递归有时难以捉摸，有时却很方便实用。结束递归是使用递归的难点，因为如果递归代码中没有终止递归的条件测试部分，一个调用自己的函数会无限递归。
可以使用循环的地方通常都可以使用递归。有时用循环解决问题比较 好，但有时用递归更好。递归方案更简洁，但效率却没有循环高。

递归调用
	每级函数调用都有自己的变量。
	每次函数调用都会返回一次。当函数执行完毕后，控制权将被传 回上一级递归。程序必须按顺序逐级返回递归，不能跳级回到前级调用。
	递归函数中位于递归调用之前的语句，均按被调函数的顺序执行。
	递归函数中位于递归调用之后的语句，均按被调函数相反的顺序执行。
	虽然每级递归都有自己的变量，但是并没有拷贝函数的代码。程序按顺序执行函数中的代码，而递归调用就相当于又从头开始执行函数的代码。除了为每次递归调用创建变量外，递归调用非常类似于一个循环语句。 实际上，递归有时可用循环来代替，循环有时也能用递归来代替。
	递归函数必须包含能让递归调用停止的语句。通常，递归函数都使用if或其他等价的测试条件在函数形参等于某特定值时终止递归。
	
最简单的递归形式是把递归调用置于函数的末尾，即正好在 return 语句之前。这种形式的递归被称为尾递归（tail recursion），因为递归调用在函数的末尾。尾递归是最简单的递归形式，因为它相当于循环。
在二进制中，奇数的末尾一定是1，偶数的末尾一定是0。
递归既有优点也有缺点。优点是递归为某些编程问题提供了最简单的解决方案。缺点是一些递归算法会快速消耗计算机的内存资源。另外，递归不方便阅读和维护.

把函数原型和已定义的字符常量放在头文件中是一个良好的编程习惯。
```

### 数组和指针

```
一元&运算符给出变量的存储地址.（%p是输出地址的转换说明）
每个C 函数都有自己的变量。这样做更可取，因为这样做可以防止原始变量被被调函数中的副作用意外修改。
指针（pointer）是一个值为内存地址的变量（或数据对象）. eg: int类型变量的值是整数，指针变量的值是地址。
使用间接运算符*（indirection operator）找出储存在地址中的值，该运算符有时也称为解引用运算符（dereferencing operator）。不要把间接运算符和二元乘法运算符（*）混淆，虽然它们使用的符号相同，但语法功能不同。
地址运算符：& ；后跟一个变量名时，&给出该变量的地址。
地址运算符：* ；后跟一个指针名或地址时，*给出储存在指针指向地址上的值。

声明指针变量时必须指定指针所指向变量的 类型，因为不同的变量类型占用不同的存储空间，一些指针操作要求知道操 作对象的大小。另外，程序必须知道储存在指定地址上的数据类型。long和 float可能占用相同的存储空间，但是它们储存数字却大相径庭。

型说明符表明了指针所指向对象的类型，星号（*）表明声明的变量 是一个指针。int * pi;声明的意思是pi是一个指针，*pi是int类

不要把指针认为是整数类型。一些处理整数 的操作不能用来处理指针，反之亦然。例如，可以把两个整数相乘，但是不 能把两个指针相乘。所以，指针实际上是一个新类型，不是整数类型。

编写程序时，可以认为变量有两个属性：名称和值（还有其他性质，如 类型）。计算机编译和加载程序后，认为变量也有两个属性：地址和值。地址就是变量在计算机内部的名称。在许多语言中，地址都归计算机管，对程序员隐藏。然而在 C 中，可以通过&运算符访问地址，通过*运算符获得地址上的值。例如，&barn表示变量barn的地址，使用函数名即可获得变量的数值。例如，printf("%d\n", barn)打印barn的值，使用*运算符即可获得储存在地址上的值。如果pbarn= &barn;，那么*pbarn表示的是储存在&barn地址上的值。简而言之，普通变量把值作为基本量，把地址作为通过&运算符获得的派生量，而指针变量把地址作为基本量，把值作为通过*运算符获得的派生量。虽然打印地址可以满足读者好奇心，但是这并不是&运算符的主要用途。更重要的是使用&、*和指针可以操纵地址和地址上的内容.

形参声明列表是用逗号分隔的一系列变量声明。除形参变量外，函数的 其他变量均在函数体的花括号之内声明。
实参用于把值从主调函数传递给被调函数。 使用关键字return把被调函数中的一个值传回主调函数。
函数的返回类型指的是函数返回值的类型。如果返回值的类型与声明的 返回类型不匹配，返回值将被转换成函数声明的返回类型
函数的返回类型和形参列表构成了函数签名。因此，函数签名指定了传 入函数的值的类型和函数返回值的类型

函数可以作为组成大型程序的构件块。每个函数都应该有一个单独且定 义好的功能。使用参数把值传给函数，使用关键字return把值返回函数。如果需要在被调函数中修改主调函数的变量，使用地址或指针作为参数。


数组由数据类型相同的一系列元素组成。需要使用数组时，通过声明数组告诉编译器数组中内含多少元素和这些元素的类型。编译器根据这些信息正确地创建数组。普通变量可以使用的类型，数组元素都可以用。
数组通常被用来储存程序需要的数据。

有时需要把数组设置为只读。这样，程序只能从数组中检索值，不能把新值写入数组。要创建只读数组，应该用const声明和初始化数组.这样修改后，程序在运行过程中就不能修改该数组中的内容。和普通变量一样，应该使用声明来初始const 数据，因为一旦声明为 const，便不能再给它赋值.

当初始化列表中的值少于数组元素个数 时，编译器会把剩余的元素都初始化为0。也就是说，如果不初始化数组， 数组元素和未初始化的普通变量一样，其中储存的都是垃圾值；但是，如果 部分初始化数组，剩余的元素就会被初始化为0

数组的初始化：
 花括号列表 {1，2，}
 指定初始化器（designated initializer）。利用该特性可以初始化指定的数组元素。 
  int arr[6] = {[5] = 212}; // 把arr[5]初始化为212
  如果指定初始化 器后面有更多的值，那么后面这些值将被用于初始化指定元素后面的元素。
  如果再次初始化指定的元素，那么最后的初始化将会取代之前的初始化。
  
在使用数组时，要防止数组下标超出边界。也就是说，必须确保下标是有效的值。 编译器不会检查数组下标是否使用得当。在C标准中，使用越界下标的结果是未定义的。这意味着程序看上去可以运行，但是运行结果很奇怪，或异常中止。
不检查边界，C 程序可以运行更快。编译器没必要捕获所有的下标错 误，因为在程序运行之前，数组的下标值可能尚未确定。因此，为安全起 见，编译器必须在运行时添加额外代码检查数组的每个下标值，这会降低程 序的运行速度。C 相信程序员能编写正确的代码，这样的程序运行速度更快。

一维数组为一个链式结构。 二维数组为表结构。 三维数组为柱结构。

指针提供一种以符号形式使用地址的方法。因为计算机的硬件指令非常依赖地址指针在某种程度上把程序员想要传达的指令以更接近机器的方式表达。因此，使用指针的程序更有效率。尤其是，指针能有效地处理数组。

系统中，地址按字节编址。`指针加1指的是增加一个存储单元`(对数组和基本数据皆是如此)。对数组而言，这意味 着把加1后的地址是下一个元素的地址，而不是下一个字节的地址。这是为什么必须声明指针所指向对象类型的原因之一。只知道地址不够，因为计算机要知道储存对象需要多少字节（即使指针指向的是标量变量，也要知道变量的类型，否则*pt 就无法正确地取回地址上的值）。

指针的值是它所指向对象的地址。地址的表示方式依赖于计算机内部的硬件。许多计算机（包括PC和Macintosh）都是按字节编址

指针的运算：
	赋值：可以把地址赋给指针。 例如，用数组名、带地址运算符（&）的 变量名、另一个指针进行赋值。
	解引用：*运算符给出指针指向地址上储存的值。
	取址：和所有变量一样，指针变量也有自己的地址和值。对指针而言， &运算符给出指针本身的地址。
	指针与整数相加：可以使用+运算符把指针与整数相加，或整数与指针 相加。无论哪种情况，整数都会和指针所指向类型的大小（以字节为单位） 相乘，然后把结果与初始地址相加。 (指向后 n 个存储单位)
	递增指针：递增指向数组元素的指针可以让该指针移动至数组的下一个元素。
	指针减去一个整数：可以使用-运算符从一个指针中减去一个整数。指 针必须是第1个运算对象，整数是第 2 个运算对象。该整数将乘以指针指向 类型的大小（以字节为单位），然后用初始地址减去乘积
	递减指针：当然，除了递增指针还可以递减指针。
	指针求差：可以计算两个指针的差值。通常，求差的两个指针分别指向同一个数组的不同元素，通过计算求出两元素之间的距离。差值的单位与数 组类型的单位相同。
	比较：使用关系运算符可以比较两个指针的值，前提是两个指针都指向相同类型的对象。
	
在递增或递减指针时还要注意一些问题。编译器不会检查指针是否仍指 向数组元素。C 只能保证指向数组任意元素的指针和指向数组后面第 1 个位 置的指针有效。但是，如果递增或递减一个指针后超出了这个范围，则是未 定义的。另外，可以解引用指向数组任意元素的指针。但是，即使指针指向 数组后面一个位置是有效的，也能解引用这样的越界指针。
千万不要解引用未初始化的指针。
	int * pt;// 未初始化的指针 
	*pt = 5; // 严重的错误
	第2行的意思是把5储存在pt指向的位置。但是pt未被初始 化，其值是一个随机值，所以不知道5将储存在何处。这可能不会出什么 错，也可能会擦写数据或代码，或者导致程序崩溃。切记：创建一个指针 时，系统只分配了储存指针本身的内存，并未分配储存数据的内存。因此， 在使用指针之前，必须先用已分配的地址初始化它。
	
指针基本用法： 函数间传递信息， 用在处理数组的函数中。

通常都是直接传递数值，只有程序需要在函数中改变该数值时，才会传递指针（函数的副作用）。对于数组别无选择，必须传递指针，因为这样 做效率高。如果一个函数按值传递数组，则必须分配足够的空间来储存原数 组的副本，然后把原数组所有的数据拷贝至新的数组中。如果把数组的地址 传递给函数，让函数直接处理原数组则效率要高。

传递地址会导致一些问题。C 通常都按值传递数据，因为这样做可以保 证数据的完整性。如果函数使用的是原始数据的副本，就不会意外修改原始 数据。但是，处理数组的函数通常都需要使用原始数据，因此这样的函数可 以修改原数组。

d对数组使用const并不是要求原数组是常量，而是该函数在处理数组时将其视为常量，不可更改。这样使用const可以保护数组的数据不被修改，就像按值传递可以保护基本数据类型的原始值不被改变一样。一般而言，如果编写的函数需要修改数组，在声明数组形参时则不使用 const；如果编写的函数不用修改数组，那么在声明数组形参时最好使用 const。

const：
	指向const的指针: 不能用于改变值。指向 const 的指针通常用于函数形参中，表明该函数不会使用指针改变数据。const int *a; 把const数据或非const 数据的地址初始化为指向const的指针或为其赋值是合法的; const 数据需要赋给指向const的指针。（对函数的形参使用const不仅能保护数据，还能让函数处理const 数组）
	不能指向别处的指针: 可以用这种指针修改它所指向的值，但是它只能指向初始化时设置的地址。 int *const ptr;
	指针既不能更改它所指 向的地址，也不能修改指向地址上的值: const double * const pc = rates;
	地址的地址或指针的指针是就是双重间接（double indirection）的例子. 增加数组维数会增加指针的复杂度。
	
把const指针赋给非const指针不安全，因为这样可以使用 新的指针改变const指针指向的数据。
C++不允许把const指针赋给非const指针。

int sum4d(int ar[][12][20][30], int rows); => int sum4d(int (*ar)[12][20][30], int rows);
第1对方括号只用于表明这是一个指针，而其他的方括号则用于描述指针所指向数据对象的类型。

C99新增了变长数组（variable-length array，VLA），允许使用变量表示数组的维度。
	int quarters = 4; int regions = 5; double sales[regions][quarters];
变长数组有一些限制。变长数组必须是自动存储类别，这意味着无论在函数中声明还是作为函数形参声明，都不能使用static或extern 存储类别说明符。而且，不能在声明中初始化它们。最终，C11把变长数组作为一个可选特性，而不是必须强制实现的特性。 注意, 变长数组不能改变大小.

变长数组中的“变”不是指可以修改已创建数组的大小。一旦创建了变长数组，它的大小则保持不变。这里的“变”指的是：在创建数组时，可以使用变量指定数组的维度。
int sum2d(int, int, int ar[*][*]);

在函数定义的形参列表中声明的变长数组并未实际创建 数组。和传统的语法类似，变长数组名实际上是一个指针。这说明带变长数 组形参的函数实际上是在原始数组中处理数组，因此可以修改传入的数组。
变长数组还允许动态内存分配，这说明可以在程序运行时指定数组的大 小。普通 C数组都是静态内存分配，即在编译时确定数组的大小。由于数组 大小是常量，所以编译器在编译时就知道了。


字面量是除符号常量外的常量。(int [2]){10, 20} // 复合字面量
初始化有数组名的数组时可以省略数组大小，复合字面量也可以省略大 小，编译器会自动计算数组当前的元素个数： (int []){50, 20, 90} // 内含3个元素的复合字面量.因为复合字面量是匿名的，所以不能先创建然后再使用它，必须在创建 的同时使用它。使用指针记录地址就是一种用法。与有数组名的数组类似，复合字面量的类型名也代表首元素的地 址，所以可以把它赋给指向int的指针。然后便可使用这个指针。

复合字面量是提供只临时需要的值的一种手段。复合字面量具有块作用域，这意味着一旦离开定义复合字面量的块，程序将无法保证该字面量是否存在。也就是说，复合字面量的定义在最内层的花括号中。
数组用于储存相同类型的数据。C 把数组看作是派生类型，因为数组是 建立在其他类型的基础上。也就是说，无法简单地声明一个数组。在声明数 组时必须说明其元素的类型.
通常编写一个函数来处理数组，这样在特定的函数中解决特定的问题， 有助于实现程序的模块化。在把数组名作为实际参数时，传递给函数的不是 整个数组，而是数组的地址（因此，函数对应的形式参数是指针）。为了处 理数组，函数必须知道从何处开始读取数据和要处理多少个数组元素。数组 地址提供了“地址”，“元素个数”可以内置在函数中或作为单独的参数传递。
数组和指针的关系密切，同一个操作可以用数组表示法或指针表示法。 它们之间的关系允许你在处理数组的函数中使用数组表示法，即使函数的形 式参数是一个指针，而不是数组。

数组元素按顺序储存在内存中，通过 整数下标（或索引）可以访问各元素。在C中，数组首元素的下标是0，所 以对于内含n个元素的数组，其最后一个元素的下标是n-1。作为程序员，要 确保使用有效的数组下标，因为编译器和运行的程序都不会检查下标的有效 性。
C把数组名解释为该数组首元素的地址。换言之，数组名与指向该数组 首元素的指针等价。概括地说，数组和指针的关系十分密切。如果ar是一个 数组，那么表达式ar[i]和*(ar+i)等价。
指针加上一个整数或递增指针，指针的值以所指向对象的大小为单位改 变。也就是说，如果pd指向一个数组的8字节double类型值，那么pd加1意味 着其值加8，以便它指向该数组的下一个元素。 
二维数组即是数组的数组。
C 语言传递多维数组的传统方法是把数组名（即数组的地址）传递给类 型匹配的指针形参。声明这样的指针形参要指定所有的数组维度，除了第1 个维度。传递的第1个维度通常作为第2个参数. (第一个维度置空表明其是一个数组类型)
```

### 字符串

```
字符串是以空字符（\0）结尾的char类型数组。
字符串常量属于静态存储类别（static storage class），这说明如果在函数中使用字符串常量，该字符串只会被储存一次，在整个程序的生命期内存 在，即使函数被调用多次。用双引号括起来的内容被视为指向该字符串储存位置的指针。这类似于把数组名作为指向该数组位置的指针。

在指定数组大小时，要确保数组的元素个数至少比字符串长度多1（为 了容纳空字符）。所有未被使用的元素都被自动初始化为0（这里的0指的是 char形式的空字符，不是数字字符0）

定义字符串:
	字符串字面量（字符串常量）: 用双引号括起来的内容称为字符串字面量（string literal），也叫作字符串常量（string constant）。双引号中的字符和编译器自动加入末尾的\0字符，都作为字符串储存在内存中. 指向字符串常量的指针为常量指针。
	字符串数组: 定义字符串数组时，必须让编译器知道需要多少空间。
		用足够空间的数组储存字符串
		让编译器确定初始化字符数组的大小 （让编译器计算数组的大小只能用在初始化数组时。如果创建一个稍后再 填充的数组，就必须在声明时指定大小。声明数组时，数组大小必须是可求值的整数）
	指针表示法创建字符串

字符数组名和其他数组名一样，是该数组首元素的地址。
带双引号的字符串本身决定了预留给字符串的存储空间。

数组形式和指针形式有何不同？以上面的声明为例，数组形式，每个元素被初始化为字符串字面量对0应的字符。通常，字符串都作为可执行文件的一部分储存在数据段中。当把程序载入内存时，也载入了程序中的字符串。字符串储存在静态存储区 （static memory）中。但是，程序在开始运行时才会为该数组分配内存。此时，才将字符串拷贝到数组中。注意，此时字符串有两个副本。一个是在静态内存中的字符串字面量，另一个是储存在ar1数组中的字符串。此后，编译器便把数组名ar1识别为该数组首元素地址（&ar1[0]）的别 名。这里关键要理解，在数组形式中，ar1是地址常量。不能更改ar1，如果 改变了ar1，则意味着改变了数组的存储位置（即地址）。可以进行类似 ar1+1这样的操作，标识数组的下一个元素。但是不允许进行++ar1这样的操作。 指针形式（*pt1）也使得编译器为字符串在静态存储区预留空间。另外，一旦开始执行程序，它会为指针变量pt1留出一个储存位置， 并把字符串的地址储存在指针变量中。该变量最初指向该字符串的首字符， 但是它的值可以改变。因此，可以使用递增运算符。字符串字面量被视为const数据。由于pt1指向这个const数据，所以应该 把pt1声明为指向const数据的指针。这意味着不能用pt1改变它所指向的数 据，但是仍然可以改变pt1的值（即，pt1指向的位置）。如果把一个字符串 字面量拷贝给一个数组，就可以随意改变数据，除非把数组声明为const。 总之，初始化数组把静态存储区的字符串拷贝到数组中，而初始化指针 只把字符串的地址拷贝给指针。

char *name; 
scanf("%s", name); 
虽然可能会通过编译（编译器很可能给出警告），但是在读入name 时，name可能会擦写掉程序中的数据或代码，从而导致程序异常中止。因 为scanf()要把信息拷贝至参数指定的地址上，而此时该参数是个未初始化的 指针，name可能会指向任何地方。
	1. 在声明时显式指明数组的大小. char name[81]; 现在name是一个已分配块（81字节）的地址。
	2. 使用C库 函数来分配内存

如果输入的字符串过长，会导致缓冲区溢出（buffer overflow），即多余的字符超出了指定的目标空间。如果这些多余的字符只是占用了尚未使用的内存，就不会立即出现问题；如果它们擦写掉程序中的其他数据，会导致程序异常中止；
```

### 存储类别、链接和内存管理

```
程序员通过 C的内存管理系统指定变量的作用域和生命期，实现对程序的控制。
从硬件方面来 看，被储存的每个值都占用一定的物理内存，C 语言把这样的一块内存称为 对象（object）。对象可以储存一个或多个值。一个对象可能并未储存实际 的值，但是它在储存适当的值时一定具有相应的大小（面向对象编程中的对 象指的是类对象，其定义包括数据和允许对数据进行的操作，C不是面向对 象编程语言）。

int entity = 3; 该声明创建了一个名为entity的标识符（identifier）。标识符是一个名 称，在这种情况下，标识符可以用来指定（designate）特定对象的内容。标 识符遵循变量的命名规则（第2章介绍过）。在该例中，标识符entity即是软 件（即C程序）指定硬件内存中的对象的方式。该声明还提供了储存在对象 中的值。
变量名不是指定对象的唯一途径。

const char * pc = "Behold a string literal!"; 程序根据该声明把相应的字符串字面量储存在内存中，内含这些字符值 的数组就是一个对象。由于数组中的每个字符都能被单独访问，所以每个字 符也是一个对象。该声明还创建了一个标识符为pc的对象，储存着字符串的 地址。由于可以设置pc重新指向其他字符串，所以标识符pc是一个可修改的 左值。const只能保证被pc指向的字符串内容不被修改，但是无法保证pc不指 向别的字符串。由于*pc指定了储存'B'字符的数据对象，所以*pc 是一个左 值，但不是一个可修改的左值。与此类似，因为字符串字面量本身指定了储 存字符串的对象，所以它也是一个左值，但不是可修改的左值。

可以用存储期（storage duration）描述对象，所谓存储期是指对象在内 存中保留了多长时间。标识符用于访问对象，可以用作用域（scope）和链 接（linkage）描述标识符，标识符的作用域和链接表明了程序的哪些部分可 以使用它。不同的存储类别具有不同的存储期、作用域和链接。标识符可以 在源代码的多文件中共享、可用于特定文件的任意函数中、可仅限于特定函 数中使用，甚至只在函数中的某部分使用。对象可存在于程序的执行期，也 可以仅存在于它所在函数的执行期。对于并发编程，对象可以在特定线程的 执行期存在。可以通过函数调用的方式显式分配和释放内存。

作用域描述程序中可访问标识符的区域。一个C变量的作用域可以是块作用域、函数作用域、函数原型作用域或文件作用域。
	块是用一对花括号括起来的代码区域。
	整个函数体是一个块，函数中的任意复合语句也是一个块。定 义在块中的变量具有块作用域（block scope），块作用域变量的可见范围是 从定义处到包含该定义的块的末尾。另外，虽然函数的形式参数声明在函数 的左花括号之前，但是它们也具有块作用域，属于函数体这个块。所以到目 前为止，我们使用的局部变量（包括函数的形式参数）都具有块作用域。
	
函数原型作用域（function prototype scope）用于函数原型中的形参名 （变量名）. int mighty(int mouse, double large); 函数原型作用域的范围是从形参定义处到原型声明结束。这意味着，编 译器在处理函数原型中的形参时只关心它的类型，而形参名（如果有的话） 通常无关紧要。而且，即使有形参名，也不必与函数定义中的形参名相匹 配。只有在变长数组中，形参名才有用。

通常在源代码（.c扩展名）中包含一个或多个头文件（.h 扩展名）。头文件会依次包含其他头文件，所以会包含多个单独的物理文件。但是，C预处理实际上是用包含的头文件内容替换#include指令。所以，编译器源代码文件和所有的头 文件都看成是一个包含信息的单独文件。这个文件被称为翻译单元 （translation unit）。描述一个具有文件作用域的变量时，它的实际可见范围 是整个翻译单元。如果程序由多个源代码文件组成，那么该程序也将由多个 翻译单元组成。每个翻译单元均对应一个源代码文件和它所包含的文件。

C 变量有 3 种链接属性：外部链接、内部链接 或无链接。具有块作用域、函数作用域或函数原型作用域的变量都是无链接 变量。这意味着这些变量属于定义它们的块、函数或原型私有。具有文件作 用域的变量可以是外部链接或内部链接。外部链接变量可以在多文件程序中 使用，内部链接变量只能在一个翻译单元中使用。

C 标准用“内部链接的文件作用域”描述仅限于一个翻译单元（即一个源 代码文件和它所包含的头文件）的作用域，用“外部链接的文件作用域”描述 可延伸至其他翻译单元的作用域。但是，对程序员而言这些术语太长了。一 些程序员把“内部链接的文件作用域”简称为“文件作用域”，把“外部链接的 文件作用域”简称为“全局作用域”或“程序作用域”。
	int giants = 5; // 文件作用域，外部链接 
	static int dodgers = 3; // 文件作用域，内部链接
作用域和链接描述了标识符的可见性。存储期描述了通过这些标识符访 问的对象的生存期。

C对象有4种存储期：静态存储期、线程存储期、自动存储期、动态分配存储期。
如果对象具有静态存储期，那么它在程序的执行期间一直存在。文件作 用域变量具有静态存储期。注意，对于文件作用域变量，关键字 static表明 了其链接属性，而非存储期。以 static声明的文件作用域变量具有内部链 接。但是无论是内部链接还是外部链接，所有的文件作用域变量都具有静态 存储期。
线程存储期用于并发程序设计，程序执行可被分为多个线程。具有线程 存储期的对象，从被声明时到线程结束一直存在。以关键字_Thread_local声 明一个对象时，每个线程都获得该变量的私有备份。
块作用域的变量通常都具有自动存储期。当程序进入定义这些变量的块 时，为这些变量分配内存；当退出这个块时，释放刚才为变量分配的内存。 这种做法相当于把自动变量占用的内存视为一个可重复使用的工作区或暂存 区。例如，一个函数调用结束后，其变量占用的内存可用于储存下一个被调 用函数的变量。
变长数组稍有不同，它们的存储期从声明处到块的末尾，而不是从块的 开始处到块的末尾。

属于自动存储类别的变量具有自动存储期、块作用域且无链接。默认情况下，声明在块或函数头中的任何变量都属于自动存储类别。为了更清楚地表达你的意图，可以显式使用关键字auto。
块作用域和无链接意味着只有在变量定义所在的块中才能通过变量名访问该变量（当然，参数用于传递变量的值和地址给另一个函数，但是这是间 接的方法）。另一个函数可以使用同名变量，但是该变量是储存在不同内存 位置上的另一个变量。
变量具有自动存储期意味着，程序在进入该变量声明所在的块时变量存 在，程序在退出该块时变量消失。原来该变量占用的内存位置现在可做他 用。
在块中就近定义该变量
如果内层块中声明的变量与外层块中的变量同名时内层块会隐藏外层块的定义。但是离开内层块后，外层块变量的作用域又回到了原来的作用域。
自动变量不会初始化，除非显式初始化它。

变量通常储存在计算机内存中。如果幸运的话，寄存器变量储存在CPU 的寄存器中，或者概括地说，储存在最快的可用内存中。与普通变量相比， 访问和处理这些变量的速度更快。由于寄存器变量储存在寄存器而非内存中，所以无法获取寄存器变量的地址。绝大多数方面，寄存器变量和自动变量都一样。也就是说，它们都是块作用域、无链接和自动存储期。使用存储 类别说明符register便可声明寄存器变量. 说“如果幸运的话”，是因为声明变量为register类别与直接命令相比更像是一种请求。编译器必须根据寄存器或最快可用内存的数量衡量你的请求，或者直接忽略你的请求，所以可能不会如你所愿。在这种情况下， 寄存器变量就变成普通的自动变量。即使是这样，仍然不能对该变量使用地址运算符。可声明为register的数据类型有限。例如，处理器中的寄存器可能没有足 够大的空间来储存double类型的值。

静态的意思是该变量在内存中原地不动，并不是说它的值不变。具 有文件作用域的变量自动具有（也必须是）静态存储期。前面提到过，可以创建具有静态存储期、块作用域的局部变量。这些变量和自动变量一样，具有相同的作用域，但是程序离开它们所在的函数后，这些变量不会消失。也就是说，这种变量具有块作用域、无链接，但是具有静态存储期。计算机在 多次函数调用之间会记录它们的值。在块中（提供块作用域和无链接）以存 储类别说明符static（提供静态存储期）声明这种变量。
每次调用函数时都会初始化局部变量(内部静态存储类别)，但是局部静态变量只在编译时被初始化一次。如果未显式初始化静态变量，它们会被初始化为 0。

void trystat(void) {
    int fade = 1;
    static int stay = 1;
}
第1条声明确实是trystat()函数的一部分，每次调用该函数时都会执行这 条声明。这是运行时行为。第2条声明实际上并不是trystat()函数的一部分。 如果逐步调试该程序会发现，程序似乎跳过了这条声明。这是因为静态变量 和外部变量在程序被载入内存时已执行完毕。把这条声明放在trystat()函数 中是为了告诉编译器只有trystat()函数才能看到该变量。这条声明并未在运 行时执行。 不能在函数的形参中使用static.

外部链接的静态变量具有文件作用域、外部链接和静态存储期。该类别 有时称为外部存储类别（external storage class），属于该类别的变量称为外 部变量（external variable）。把变量的定义性声明（defining declaration）放 在在所有函数的外面便创建了外部变量。当然，为了指出该函数使用了外部 变量，可以在函数中用关键字extern再次声明。如果一个源代码文件使用的 外部变量定义在另一个源代码文件中，则必须用extern在该文件中声明该变 量。在执行块中的语句时，块作用域中的变量将“隐藏”文件作用域中的同名变量。如果不得已要使用与外部变量同名的局部变量，可以在局部变量的声明中使用 auto 存储类别说明符明确表达这种意图.外部变量具有静态存储期。

外部变量和自动变量类似，也可以被显式初始化。与自动变量不同的 是，如果未初始化外部变量，它们会被自动初始化为 0。这一原则也适用于 外部定义的数组元素。与自动变量的情况不同，只能使用常量表达式初始化 文件作用域变量.
只要不是变长数组，sizeof表达式可被视为常量表达式。

C99和C11标准都要求编译器识别局部标识符的前63个字符和外部标识 符的前31个字符。外部变量名比局部变量名的规则严格，是因为外部变量名还要遵循局部环境规则，所受的限制更多。

int tern = 1; /* tern被定义 */ 
main() {
extern int tern; /* 使用在别处定义的tern */
} 
这里，tern被声明了两次。第1次声明为变量预留了存储空间，该声明构成了变量的定义。第2次声明只告诉编译器使用之前已创建的tern变量，所以这不是定义。第1次声明被称为定义式声明（defining declaration），第2次声 明被称为引用式声明（referencing declaration）。关键字extern表明该声明不是定义，因为它指示编译器去别处查询其定义。
extern int tern; int main(void) {}
编译器会假设 tern 实际的定义在该程序的别处，也许在别的文件中。该 声明并不会引起分配存储空间。因此，不要用关键字extern创建外部定义， 只用它来引用现有的外部定义。 外部变量只能初始化一次，且必须在定义该变量时进行。

该存储类别的变量具有静态存储期、文件作用域和内部链接。在所有函数外部（这点与外部变量相同），用存储类别说明符static定义的变量具有这种存储类别： static int svil = 1; // 静态变量，内部链接
只有当程序由多个翻译单元组成时，才体现区别内部链接和外部链接的 重要性。
复杂的C程序通常由多个单独的源代码文件组成。有时，这些文件可能要共享一个外部变量。C通过在一个文件中进行定义式声明，然后在其他文 件中进行引用式声明来实现共享。也就是说，除了一个定义式声明外，其他 声明都要使用extern关键字。而且，只有定义式声明才能初始化变量。
如果外部变量定义在一个文件中，那么其他文件在使用该变量之 前必须先声明它（用 extern关键字）。也就是说，在某文件中对外部变量进 行定义式声明只是单方面允许其他文件使用该变量，其他文件在用extern声 明之前不能直接使用它。
编译器会把文件中一个带初始化的声明视为该变量的定义。

auto说明符表明变量是自动存储期，只能用于块作用域的变量声明中。 由于在块中声明的变量本身就具有自动存储期，所以使用auto主要是为了明 确表达要使用与外部变量同名的局部变量的意图。
register 说明符也只用于块作用域的变量，它把变量归为寄存器存储类 别，请求最快速度访问该变量。同时，还保护了该变量的地址不被获取。
用 static 说明符创建的对象具有静态存储期，载入程序时创建对象，当 程序结束时对象消失。如果static 用于文件作用域声明，作用域受限于该文 件。如果 static 用于块作用域声明，作用域则受限于该块。因此，只要程序 在运行对象就存在并保留其值，但是只有在执行块内的代码时，才能通过标识符访问。块作用域的静态变量无链接。文件作用域的静态变量具有内部链接。
extern 说明符表明声明的变量定义在别处。如果包含 extern 的声明具有 文件作用域，则引用的变量必须具有外部链接。如果包含 extern 的声明具有 块作用域，则引用的变量可能具有外部链接或内部链接，这接取决于该变量 的定义式声明。

自动变量具有块作用域、无链接、自动存储期。它们是局部变量，属于 其定义所在块（通常指函数）私有。寄存器变量的属性和自动变量相同，但 是编译器会使用更快的内存或寄存器储存它们。不能获取寄存器变量的地 址。
具有静态存储期的变量可以具有外部链接、内部链接或无链接。在同一 个文件所有函数的外部声明的变量是外部变量，具有文件作用域、外部链接 和静态存储期。如果在这种声明前面加上关键字static，那么其声明的变量 具有文件作用域、内部链接和静态存储期。如果在函数中用 static 声明一个 变量，则该变量具有块作用域、无链接、静态存储期。
具有自动存储期的变量，程序在进入该变量的声明所在块时才为其分配 内存，在退出该块时释放之前分配的内存。如果未初始化，自动变量中是垃 圾值。程序在编译时为具有静态存储期的变量分配内存，并在程序的运行过 程中一直保留这块内存。如果未初始化，这样的变量会被设置为0。 具有块作用域的变量是局部的，属于包含该声明的块私有。具有文件作 用域的变量对文件（或翻译单元）中位于其声明后面的所有函数可见。具有 外部链接的文件作用域变量，可用于该程序的其他翻译单元。具有内部链接 的文件作用域变量，只能用于其声明所在的文件内。

函数也有存储类别，可以是外部函数（默认）或静态函数。C99 新增了第 3 种类别——内联函数。外部函数可以被其他文件的 函数访问，但是静态函数只能用于其定义所在的文件。
用 extern 关键字声明定义在其他文件中的函数。这样做 是为了表明当前文件中使用的函数被定义在别处。除非使用static关键字， 否则一般函数声明都默认为extern。
保护性程序设计的黄金法则是：“按需知道”原则。尽量在函数内部解决 该函数的任务，只共享那些需要共享的变量。

所有程序都必须预留足够的内存来储存程序 使用的数据。这些内存中有些是自动分配的。或者可以显式指定分配一定数量的内存。静态数据在程序载入内存时分配，而自动数据在程序执行块时分配，并在程序离开该块时销毁。

malloc()函数，该函数接受一个参数：所需的内存字节数。malloc()函数会找到合适的空闲内存块，这样的内存是匿名的。也就是说， malloc()分配内存，但是不会为其赋名。然而，它确实返回动态分配内存块的首字节地址。 因此，可以把该地址赋给一个指针变量，并使用指针访问这块内存。

double * ptd; 
ptd = (double *) malloc(30 * sizeof(double)); 以上代码为30个double类型的值请求内存空间，并设置ptd指向该位置。 注意，指针ptd被声明为指向一个double类型，而不是指向内含30个double类型值的块。回忆一下，数组名是该数组首元素的地址。因此，如果让ptd指向这个块的首元素，便可像使用数组名一样使用它。也就是说，可以使用表达式ptd[0]访问该块的首元素，ptd[1]访问第2个元素，以此类推。

创建数组的方法:
	声明数组时，用常量表达式表示数组的维度，用数组名访问数组的元素。可以用静态内存或自动内存创建这种数组。 
	声明变长数组（C99新增的特性）时，用变量表达式表示数组的维度， 用数组名访问数组的元素。具有这种特性的数组只能在自动内存中创建。 
	声明一个指针，调用malloc()，将其返回值赋给指针，使用指针访问数组的元素。该指针可以是静态的或自动的。
	
malloc()要与free()配套使用。free()函数的参数是之前malloc()返 回的地址，该函数释放之前malloc()分配的内存。因此，动态分配内存的存储期从调用malloc()分配内存到调用free()释放内存为止。设想malloc()和 free()管理着一个内存池。每次调用malloc()分配内存给程序使用，每次调用 free()把内存归还内存池中，这样便可重复使用这些内存。free()的参数应该是一个指针，指向由 malloc()分配的一块内存。不能用 free()释放通过其他方式（如，声明一个数组）分配的内存。 malloc()可能分配不到所需的内存。

静态内存的数量在编译时是固定的，在程序运行期间也不会改变。自动变量使用的内存数量在程序执行期间自动增加或减少。但是动态分配的内存数量只会增加，除非用 free()进行释放。
calloc()函数还有一个特性：它把块中的所有位都设置为0.

变长数组和malloc()：
	变长数组是自动存储类型。因此，程序在离开变长数组定义所在的块时（该例中，即vlamal()函数结束时），变长数组占用的内存空间会被自动释放，不必使用 free()。另一方面，用malloc()创建的数组不必局限在一个函数内访问。例如，可以这样做：被调函数创建一个数组并返回指针，供主调函数访问，然后主调函数在末尾调用free()释放之前被调函数分配的内存。另外，free()所用的指针变量可以与 malloc()的指针变量不同，但是两个指针必须储存相同的地址。但是，不能释放同一块内存两次。
	对多维数组而言，使用变长数组更方便。当然，也可以用 malloc()创建二维数组，但是语法比较繁琐。
	
内存分为3部分：
	一部分供具有外部链接、内部链接和无链接的静态变量使用；
	一部分供自动变量使用；
	一部分供动态内存分配。
静态存储类别所用的内存数量在编译时确定，只要程序还在运行，就可 访问储存在该部分的数据。该类别的变量在程序开始执行时被创建，在程序 结束时被销毁。 然而，自动存储类别的变量在程序进入变量定义所在块时存在，在程序 离开块时消失。因此，随着程序调用函数和函数结束，自动变量所用的内存 数量也相应地增加和减少。这部分的内存通常作为栈来处理，这意味着新创 建的变量按顺序加入内存，然后以相反的顺序销毁。
动态分配的内存在调用 malloc()或相关函数时存在，在调用 free()后释 放。这部分的内存由程序员管理，而不是一套规则。所以内存块可以在一个 函数中创建，在另一个函数中销毁。正是因为这样，这部分的内存用于动态 内存分配会支离破碎。也就是说，未使用的内存块分散在已使用的内存块之 间。另外，使用动态内存通常比使用栈内存慢。
总而言之，程序把静态对象、自动对象和动态分配的对象储存在不同的 区域。

const类型限定符:
	以const关键字声明的对象，其值不能通 过赋值或递增、递减来修改
	在指针和形参声明中使用const: 声明普通变量和数组时使用 const 关键字很简单。指针则复杂一些，因 为要区分是限定指针本身为const还是限定指针指向的值为const
		const float * pf; /* pf 指向一个float类型的const值 */
		float * const pt; /* pt 是一个const指针 */ 
		const float * const ptr; // 表明ptr既不能指向别处，它所指向的值也不能改变。
	const放在*左侧任意位置，限定了指针指向的 数据不能改变；const放在*的右侧，限定了指针本身不能改变。
	const 行参原型保证了数据不会被更改。如果一个指针仅用于给函数访问值，应将其 声明为一个指向const限定类型的指针。如果要用指针更改主调函数中的数 据，就不使用const关键字。
	使用全局变量是一种冒险的方法，因为这样做暴露了数据， 程序的任何部分都能更改数据。如果把数据设置为 const，就可避免这样的危险，因此用 const 限定符声明全局数据很合理。可以创建const变量、const 数组和const结构。
	
	
volatile 限定符告知计算机，代理（而不是变量所在的程序）可以改变 该变量的值。通常，它被用于硬件地址以及在其他程序或同时运行的线程中 共享数据。
	volatile int loc1;/* loc1 是一个易变的位置 */ 
	volatile int * ploc; /* ploc 是一个指向易变的位置的指针 */
	
vall =x; 
/* 一些不使用 x 的代码*/ 
val2 = x
智能的（进行优化的）编译器会注意到以上代码使用了两次 x，但并未 改变它的值。于是编译器把 x的值临时储存在寄存器中，然后在val2需要使 用x时，才从寄存器中（而不是从原始内存位置上）读取x的值，以节约时 间。这个过程被称为高速缓存（caching）。通常，高速缓存是个不错的优化 方案，但是如果一些其他代理在以上两条语句之间改变了x的值，就不能这 样优化了。如果没有volatile关键字，编译器就不知道这种事情是否会发 生。因此，为安全起见，编译器不会进行高速缓存。这是在 ANSI 之前的情 况。现在，如果声明中没有volatile关键字，编译器会假定变量的值在使用 过程中不变，然后再尝试优化代码。

restrict 关键字允许编译器优化某部分代码以更好地支持计算。它只能 用于指针，表明该指针是访问数据对象的唯一且初始的方式。
int ar[10]; 
int * restrict restar = (int *) malloc(10 * sizeof(int)); 
int * par = ar; 
这里，指针restar是访问由malloc()所分配内存的唯一且初始的方式。因 此，可以用restrict关键字限定它。而指针par既不是访问ar数组中数据的初始 方式，也不是唯一方式。所以不用把它设置为restrict。如果未使用restrict关键字，编译器就必须假设最坏的情况 （即，在两次使用指针之间，其他的标识符可能已经改变了数据）。如果用 了restrict关键字，编译器就可以选择捷径优化计算。restrict 限定符还可用于函数形参中的指针。这意味着编译器可以假定在函数体内其他标识符不会修改该指针指向的数据，而且编译器可以尝试对 其优化，使其不做别的用途。
void * memcpy(void * restrict s1, const void * restrict s2, size_t n); 
void * memmove(void * s1, const void * s2, size_t n); 
这两个函数都从位置s2把n字节拷贝到位置s1。memcpy()函数要求两个 位置不重叠，但是memove()没有这样的要求。声明s1和s2为restrict说明这两 个指针都是访问相应数据的唯一方式，所以它们不能访问相同块的数据。这 满足了memcpy()无重叠的要求。memmove()函数允许重叠，它在拷贝数据时 不得不更小心，以防在使用数据之前就先覆盖了数据。 restrict 关键字有两个读者。一个是编译器，该关键字告知编译器可以 自由假定一些优化方案。另一个读者是用户，该关键字告知用户要使用满足 restrict要求的参数。总而言之，编译器不会检查用户是否遵循这一限制，但 是无视它后果自负。


使用自动变量、函数形参和返回值进行函数间的通 信比使用全局变量安全。但是，保持不变的数据适合用全局变量。
静态内存的数量在编译时确定；静态数据在载入程序时被载入内存。在 程序运行时，自动变量被分配或释放，所以自动变量占用的内存数量随着程 序的运行会不断变化。可以把自动内存看作是可重复利用的工作区。动态分 配的内存也会增加和减少，但是这个过程由函数调用控制，不是自动进行 的。
内存用于存储程序中的数据，由存储期、作用域和链接表征。存储期可 以是静态的、自动的或动态分配的。如果是静态存储期，在程序开始执行时 分配内存，并在程序运行时都存在。如果是自动存储期，在程序进入变量定 义所在块时分配变量的内存，在程序离开块时释放内存。如果是动态分配存 储期，在调用malloc()（或相关函数）时分配内存，在调用free()函数时释放 内存。
作用域决定程序的哪些部分可以访问某数据。定义在所有函数之外的变 量具有文件作用域，对位于该变量声明之后的所有函数可见。定义在块或作 为函数形参内的变量具有块作用域，只对该块以及它包含的嵌套块可见。
链接描述定义在程序某翻译单元中的变量可被链接的程度。具有块作用 域的变量是局部变量，无链接。具有文件作用域的变量可以是内部链接或外 部链接。内部链接意味着只有其定义所在的文件才能使用该变量。外部链接 意味着其他文件使用也可以使用该变量。

自动——在块中不带存储类别说明符或带 auto 存储类别说明符声明的 变量（或作为函数头中的形参）属于自动存储类别，具有自动存储期、块作 用域、无链接。如果未初始化自动变量，它的值是未定义的。
寄存器——在块中带 register 存储类别说明符声明的变量（或作为函数 头中的形参）属于寄存器存储类别，具有自动存储期、块作用域、无链接， 且无法获取其地址。把一个变量声明为寄存器变量即请求编译器将其储存到 访问速度最快的区域。如果未初始化寄存器变量，它的值是未定义的。
静态、无链接——在块中带static存储类别说明符声明的变量属于“静 态、无链接”存储类别，具有静态存储期、块作用域、无链接。只在编译时 被初始化一次。如果未显式初始化，它的字节都被设置为0。
静态、外部链接——在所有函数外部且没有使用 static 存储类别说明符 声明的变量属于“静态、外部链接”存储类别，具有静态存储期、文件作用 域、外部链接。只能在编译器被初始化一次。如果未显式初始化，它的字节 都被设置为0。
静态、内部链接——在所有函数外部且使用了 static 存储类别说明符声 明的变量属于“静态、内部链接”存储类别，具有静态存储期、文件作用域、 内部链接。只能在编译器被初始化一次。如果未显式初始化，它的字节都被 设置为0。
动态分配的内存由 malloc()（或相关）函数分配，该函数返回一个指向 指定字节数内存块的指针。这块内存被free()函数释放后便可重复使用， free()函数以该内存块的地址作为参数。

C程序把输入看作是字节流，输入流来源于文件、输入设备（如键 盘），或者甚至是另一个程序的输出。类似地，C程序把输出也看作是字节 流，输出流的目的地可以是文件、视频显示等。
C 如何解释输入流或输出流取决于所使用的输入/输出函数。程序可以 不做任何改动地读取和存储字节，或者把字节依次解释成字符，随后可以把 这些字符解释成普通文本以用文本表示数字。类似地，对于输出，所使用的 函数决定了二进制值是被原样转移，还是被转换成文本或以文本表示数字。 如果要在不损失精度的前提下保存或恢复数值数据，请使用二进制模式以及 fread()和fwrite()函数。如果打算保存文本信息并创建能在普通文本编辑器查 看的文本，请使用文本模式和函数（如getc()和fprintf()）。
要访问文件，必须创建文件指针（类型是FILE *）并把指针与特定文件 名相关联。随后的代码就可以使用这个指针（而不是文件名）来处理该文 件。
。通常，用于读取文件的程序使用一个 循环读取输入，直至到达文件结尾。C 输入函数在读过文件结尾后才会检测 到文件结尾，这意味着应该在尝试读取之后立即判断是否是文件结尾.
ANSI C提供两种文件打开模式：二进制和文本。以二进制模式打开文 件时，可以逐字节读取文件；以文本模式打开文件时，会把文件内容从文本 的系统表示法映射为C表示法。对于UNIX和Linux系统，这两种模式完全相 同。

设计程序时，最重要的步骤之一是选择表示数据的方法。在许多情况 下，简单变量甚至是数组还不够。为此，C提供了结构变量（structure variable）提高你表示数据的能力，它能让你创造新的形式。
使用结构： 
    为结构建立一个格式或样式；
    声明一个适合该样式的变量；
    访问结构变量的各个部分。
结构声明（structure declaration）描述了一个结构的组织布局。
struct book {
    char title[MAXTITL];
    char author[MAXAUTL];
    float value;
};
该声明描述了一个由两个字符数组和一个float类型变量组成的结构。该声明并未创建实际的数据对象，只描述了该对象由什么组成。〔有时，我们 把结构声明称为模板，因为它勾勒出结构是如何储存数据的。）在结构声明中，用一对花括号括起来的是结构成员列表。每个成员都用 自己的声明来描述。例如，title部分是一个内含MAXTITL个元素的char类型 数组。成员可以是任意一种C的数据类型，甚至可以是其他结构！右花括号 后面的分号是声明所必需的，表示结构布局定义结束。可以把这个声明放在 所有函数的外部（如本例所示），也可以放在一个函数定义的内部。如果把 结构声明置于一个函数的内部，它的标记就只限于该函数内部使用。如果把 结构声明置于函数的外部，那么该声明之后的所有函数都能使用它的标记。
结构的两层含义：
	结构布局： 结构布局告诉编译器如何表示数据，但是它并未让编译器为数据分配空间。（创建了一种新的数据类型）
	定义结构变量： 编译器执行创建了一个结构变量， 编译器依据模板为该变量分配空间。
初始化：
	可使用在一对花括号中括起来的初始化列表进行初始化， 各初始化项用逗号分隔。
	指定初始化器：结构的指定初始化器使用点运算符和 成员名（而不是方括号和下标）标识特定的元素。与数组类似，在指定初始化器后面的普通初始化器，为指定成员后面的 成员提供初始值。另外，对特定成员的最后一次赋值才是它实际获得的值。 
结构类似于一个“超级数组”。
.比&的优先级高。
声明结构数组和声明其他类型的数组类似。

指向结构的指针：
	就像指向数组的指针比数组本 身更容易操控（如，排序问题）一样，指向结构的指针通常比结构本身更容易操控。
	在一些早期的C实现中，结构不能作为参数传递给函数，但 是可以传递指向结构的指针。
	即使能传递一个结构，传递指针通常更 有效率。
	一些用于表示数据的结构中包含指向其他结构的指针。
	struct Person *pointer; Person *pointer; // 该声明并未创建一个新的结构，但是指针 pointer 现在可以指向任意现有的 Person 类型的结构

和数组不同的是，结构名并不是结构的地址，因此要在结构名前面加上 & 运算符。
在有些系统中，一个结构的大小可能大于它各成员大小之和。这是因为系统对数据进行校准的过程中产生了一些“缝隙”。例如，有些系统必须把每个成员都放在偶数地址上，或4的倍数的地址上。在这种系统中，结构的内部就存在未使用的“缝隙”。
结构的传递：
	只要结构成员是一个具有单个值的数据类型（即，int及其相关类型、 char、float、double或指针），便可把它作为参数传递给接受该特定类型的 函数
	让被调函数知道自己正在处理一个结构。把结构的地址作为参数。（和数组名不同，结构名只是其地址的别名）
	传递结构本身

现在的C允许把一个结构赋值给另一个结构，但是数组不能这样做；
	o_data = n_data; // 把一个结构赋值给另一个结构。这条语句把n_data的每个成员的值都赋给o_data的相应成员。即使成员 是数组，也能完成赋值。  // 把一个结构初始化为另一个结构

函数不仅能把结构本身作为参数传递，还能 把结构作为返回值返回。把结构作为函数参数可以把结构的信息传送给函 数；把结构作为返回值的函数能把结构的信息从被调函数传回主调函数。结 构指针也允许这种双向通

函数间信息的传递： 函数把信息从自身传回主调函数，函数把信息从主调函数传给自身，函数通过双向传输来传递信息。

用结构指针作为参数，还是用结构作为参数：
	把指针作为参数有两个优点：无论是以前还是现在的C实现都能使用这 种方法，而且执行起来很快，只需要传递一个地址。缺点是无法保护数据。 被调函数中的某些操作可能会意外影响原来结构中的数据。不过，ANSI C 新增的const限定符解决了这个问题。
	把结构作为参数传递的优点是，函数处理的是原始数据的副本，这保护 了原始数据。另外，代码风格也更清楚。
	传递结构的两个缺点是：较老版本的实现可能无法处理这样的代码，而 且传递结构浪费时间和存储空间。尤其是把大型结构传递给函数，而它只使 用结构中的一两个成员时特别浪费。这种情况下传递指针或只传递函数所需 的成员更合理。
	通常，程序员为了追求效率会使用结构指针作为函数参数，如需防止原 始数据被意外修改，使用const限定符。按值传递结构是处理小型结构最常 用的方法

如果使用malloc()分配内存并使用指针储存该地址，那么在结构中使用 指针处理字符串就比较合理。这种方法的优点是，可以请求malloc()为字符 串分配合适的存储空间。应该成对使用malloc()和free()。因此，还要在程序中添加 一个新的函数cleanup()，用于释放程序动态分配的内存。

C99新增了一个特性：伸缩型数组成员（flexible array member），利用这项特性声明的结构，其最后一个数组成员具有一些特性。
	第1个特性是， 该数组不会立即存在。
	第2个特性是，使用这个伸缩型数组成员可以编写合适的代码，就好像它确实存在并具有所需数目的元素一样。
伸缩型数组成员有如下规则：
	伸缩型数组成员必须是结构的最后一个成员；
    结构中必须至少有一个成员；
    伸缩数组的声明类似于普通数组，只是它的方括号中是空的

struct flex
{
    int count;
    double average;
    double scores[];　// 伸缩型数组成员
};
声明一个struct flex类型的结构变量时，不能用scores做任何事，因为没 有给这个数组预留存储空间。实际上，C99的意图并不是让你声明struct flex 类型的变量，而是希望你声明一个指向struct flex类型的指针，然后用 malloc()来分配足够的空间，以储存struct flex类型结构的常规内容和伸缩型 数组成员所需的额外空间。例如，假设用scores表示一个内含5个double类型 值的数组，可以这样做：
    struct flex * pf; // 声明一个指针
    pf = malloc(sizeof(struct flex)+5 * sizeof(double));// 请求为一个结构和一个数组分配存储空间
现在有足够的存储空间储存count、average和一个内含5个double类型值 的数组。可以用指针pf访问这些成员：
    pf->count = 5;　　　　 // 设置 count 成员
    pf->scores[2] = 18.5;　// 访问数组成员的一个元素
    
匿名结构是一个没有名称的结构成员。

由于结构可以储存不同类型的信息，所以它是构建数据库的重要工具。 例如，可以用一个结构储存雇员或汽车零件的相关信息。最终，我们要把这些信息储存在文件中，并且能再次检索。数据库文件可以包含任意数量的此类数据对象。储存在一个结构中的整套信息被称为记录（record），单独的项被称为字段（field）。对于一些结构（如，有 30 个成员的结构），这个方法用起来很不方 便。另外，在检索时还存在问题，因为程序要知道一个字段结束和另一个字 段开始的位置。虽然用固定字段宽度的格式可以解决这个问题.
结构的多种用途之一：创建 新的数据形式。计算机用户已经开发出的一些数据形式比我们提到过的数组 和简单结构更有效地解决特定的问题。这些形式包括队列、二叉树、堆、哈 希表和图表。许多这样的形式都由链式结构（linked structure）组成。通 常，每个结构都包含一两个数据项和一两个指向其他同类型结构的指针。这 些指针把一个结构和另一个结构链接起来，并提供一种路径能遍历整个彼此 链接的结构。

联合（union）是一种数据类型，它能在同一个内存空间中储存不同的 数据类型（不是同时储存）。其典型的用法是，设计一种表以储存既无规 律、事先也不知道顺序的混合类型。使用联合类型的数组，其中的联合都大 小相等，每个联合可以储存各种数据类型。
创建联合和创建结构的方式相同，需要一个联合模板和联合变量。可以 用一个步骤定义联合，也可以用联合标记分两步定义。
union hold { int digit; double bigfl; char letter; }; 根据以上形式声明的结构可以储存一个int类型、一个double类型和char 类型的值。然而，声明的联合只能储存一个int类型的值或一个double类型的 值或char类型的值。
编译器分配足够的空间以便它能储存联合声明中占用最大字节的类型。在本例中，占用空间最大的是double类型的数据。可以初始化联合。需要注意的是，联合只能储存一个值，这与结构不同。
初始化的方法:
	union hold valA; 
	valA.letter = 'R'; 
	union hold valB = valA; // 用另一个联合来初始化 
	union hold valC = {88}; // 初始化联合的digit 成员 
	union hold valD = {.bigfl = 118.2}; // 指定初始化器
	把一个联合初始化为另一个同类型的联合；
	初始化联合的第1个元素；
	使用指定初始化器：
点运算符表示正在使用哪种数据类型。在联合中，一次只储存一个值。 即使有足够的空间，也不能同时储存一个char类型值和一个int类型值。编写 代码时要注意当前储存在联合中的数据类型。 和用指针访问结构使用->运算符一样，用指针访问联合时也要使用->运 算符：
用一个成员把值储存在一个联合中，然后用另一个成员查看内容，这种做法有时很有用。
联合的另一种用法是，在结构中储存与其成员有从属关系的信息。


可以用枚举类型（enumerated type）声明符号名称来表示整型常量。使用enum关键字，可以创建一个新“类型”并指定它可具有的值（实际上，enum 常量是int类型，因此，只要能使用int类型的地方就可以使用枚举类型）。枚举类型的目的是提高程序的可读性。它的语法与结构的语法相同。

enum spectrum {red, orange, yellow, green, blue, violet}; 
enum spectrum color; 
第1个声明创建了spetrum作为标记名，允许把enum spetrum作为一个类型名使用。第2个声明使color作为该类型的变量。第1个声明中花括号内的标识符枚举了spectrum变量可能有的值。因此， color 可能的值是 red、 orange、yellow 等。这些符号常量被称为枚举符（enumerator）。然后，便可这样用： int c; color = blue; if (color == yellow) ...; for (color = red; color <= violet; color++) ...; 虽然枚举符（如red和blue）是int类型，但是枚举变量可以是任意整数类型，前提是该整数类型可以储存枚举常量。例如，spectrum的枚举符范围是 0～5，所以编译器可以用unsigned char来表示color变量。顺带一提，C枚举的一些特性并不适用于C++。例如，C允许枚举变量 使用++运算符，但是C++标准不允许。
默认情况下，枚举列表中的常量都被赋予0、1、2等。
如果只给一个枚举常量赋值，没有对后面的枚举常量赋值，那么后面的常量会被赋予后续的值。例如，假设有如下的声明： enum feline {cat, lynx = 10, puma, tiger}; 那么，cat的值是0（默认），lynx、puma和tiger的值分别是10、11、 12。

C语言使用名称空间（namespace）标识程序中的各部分，即通过名称来识别。作用域是名称空间概念的一部分：两个不同作用域的同名变量不冲突；两个相同作用域的同名变量冲突。名称空间是分类别的。在特定作用域中的结构标记、联合标记和枚举标记都共享相同的名称空间，该名称空间与普通变量使用的空间不同。这意味着在相同作用域中变量和标记的名称可以相同，不会引起冲突，但是不能在相同作用域中声明两个同名标签或同名变量。

typedef工具是一个高级数据特性，利用typedef可以为某一类型自定义名称。这方面与#define类似，但是两者有3处不同： 与#define不同，typedef创建的符号名只受限于类型，不能用于值。 typedef由编译器解释，不是预处理器。 在其受限范围内，typedef比#define更灵活。
定义的作用域取决于typedef定义所在的位置。如果定义在函数中，就 具有局部作用域，受限于定义所在的函数。如果定义在函数外面，就具有文件作用域。通常，typedef定义中用大写字母表示被定义的名称，以提醒用户这个类 型名实际上是一个符号缩写。
typedef的一些特性与#define的功能重合。例如： #define BYTE unsigned char 这使预处理器用BYTE替换unsigned char。但是也有#define没有的功能
	typedef char * STRING; => STRING name, sign; 相当于： char * name, * sign;
	define STRING char *;  => STRING name, sign; 相当于： char * name, sign;
把typedef用于结构:
	typedef struct complex { float real; float imag; } COMPLEX; 然后便可使用COMPLEX类型代替complex结构来表示复数。
	使用typedef 的第1个原因是：为经常出现的类型创建一个方便、易识别的类型名。
	使用typedef的第2个原因是：typedef常用于给复杂的类型命名。
使用typedef时要记住，typedef并没有创建任何新类型，它只是为某个已存在的类型增加了一个方便使用的标签。以前面的STRING为例，这意味着我们创建的STRING类型变量可以作为实参传递给以指向char指针作为形参的函数。
C 允许用户自定义数据形式。

声明示例： 
  int board[8][8]; // 声明一个内含int数组的数组
  int ** ptr; // 声明一个指向指针的指针，被指向的指针指向
  int int * risks[10]; // 声明一个内含10个元素的数组，每个元素都是一个指向int的指针 
  int (* rusks)[10]; // 声明一个指向数组的指针，该数组内含10个int类型的值
  int * oof[3][4]; // 声明一个3×4 的二维数组，每个元素都是指向int 的指针
  int (* uuf)[3][4]; // 声明一个指向3×4二维数组的指针，该数组中内含 int类型值
  int (* uof[3])[4]; // 声明一个内含3个指针元素的数组，其中每个指针都指向一个内含4个int类型元素的数组
1.数组名后面的[]和函数名后面的()具有相同的优先级。它们比*（解引 用运算符）的优先级高。因此下面声明的risk是一个指针数组，不是指向数 组的指针： int * risks[10];
2.[]和()的优先级相同，由于都是从左往右结合，所以下面的声明中， 在应用方括号之前，*先与rusks结合。因此rusks是一个指向数组的指针，该 数组内含10个int类型的元素： int (* rusks)[10];
3.[]和()都是从左往右结合。因此下面声明的goods是一个由12个内含50 个int类型值的数组组成的二维数组，不是一个有50个内含12个int类型值的数 组组成的二维数组： int goods[12][50];


函数指针： 
	函数指针常用作另一个函数的参数，告诉该函数要使用哪一个函数。例如，排序数组涉及比较两个元素，以确定先后。如果 元素是数字，可以使用>运算符；如果元素是字符串或结构，就要调用函数。进行比较。C库中的 qsort()函数可以处理任意类型的数组，但是要告诉 qsort()使用哪个函数来比较元素。为此， qsort()函数的参数列表中，有一个 参数接受指向函数的指针。然后，qsort()函数使用该函数提供的方案进行排 序，无论这个数组中的元素是整数、字符串还是结构。
	首先，什么是函数指针？假设有一个指向 int类型变量的指针，该指针储存着这个int类型变量储存在内存位置的地址。 同样，函数也有地址，因为函数的机器语言实现由载入内存的代码组成。指向函数的指针中储存着函数代码的起始处的地址。其次，声明一个数据指针时，必须声明指针所指向的数据类型。声明一个函数指针时，必须声明指针指向的函数类型。为了指明函数类型，要指明函数签名，即函数的返回类型和形参类型。
	void ToUpper(char *); // ToUpper()函数的类型是“带char * 类型参数、返回类型是void的函数”。 
	void (*pf)(char *);　 // pf 是一个指向函数的指针
		从该声明可以看出，第1对圆括号把*和pf括起来，表明pf是一个指向函 数的指针。因此，(*pf)是一个参数列表为(char *)、返回类型为void的函数。 注意，把函数名ToUpper替换为表达式(*pf)是创建指向函数指针最简单的方 式。所以，如果想声明一个指向某类型函数的指针，可以写出该函数的原型 后把函数名替换成(*pf)形式的表达式，创建函数指针声明。
    声明了函数指针后，可以把类型匹配的函数地址赋给它。既然可以用数据指针访问数据，也可以用函数指针访问函数。
    
指针本身也是一种数据类型： 数据类型存在这自己的存储位置，大小和储存内容， 指针类型储存的值都是具体的内存指针。 指向不同的数据类型（指针，int，double，char...）。
数组和函数的名称都是指向自身首地址的。（可以将数组名和函数名理解为指针， 他们的值为他们的首元素地址）：parr = arr;(参考普通赋值关系， 将arr值赋给parr； parr将指向arr指向的相同位置)

void show(void (* fp)(char *), char * str); // 它声明了两个形参：fp和str。fp形参是一个函数指 针，str是一个数据指针。更具体地说，fp指向的函数接受char * 类型的参 数，其返回类型为void；str指向一个char类型的值

我们在编程中要表示的信息通常不只是一个数字或一些列数字。程序可能要处理具有多种属性的实体。例如，通过姓名、地址、电话号码和其他信 息表示一名客户；或者，通过电影名、发行人、播放时长、售价等表示一部 电影DVD。C结构可以把这些信息都放在一个单元内。在组织程序时这很重 要，因为这样可以把相关的信息都储存在一处，而不是分散储存在多个变量中。设计结构时，开发一个与之配套的函数包通常很有用。（将问题域中的数据封装在一起， 并为封装的数据提供一些列的接口）。
联合声明与结构声明类似。但是，联合的成员共享相同的存储空间，而 且在联合中同一时间内只能有一个成员。实质上，可以在联合变量中储存一个类型不唯一的值。
enum 工具提供一种定义符号常量的方法，typedef 工具提供一种为基本 或派生类型创建新标识符的方法。
指向函数的指针提供一种告诉函数应使用哪一个函数的方法。
```

### 位操作

```


通常都是基于数字10来书写数字。例如2157的千位是2，百位是1，十位 是5，个位是7，可以写成：
    2×1000 + 1×100 + 5×10 + 7×1
注意，1000是10的立方（即3次幂），100是10的平方（即2次幂），10 是10的1次幂，而且10（以及任意正数）的0次幂是1。因此，2157也可以写 成：
    2×10^3+ 1×10^2+ 5×10^1+ 7×10^0
因为这种书写数字的方法是基于10的幂，所以称以10为基底书写2157。姑且认为十进制系统得以发展是得益于我们都有10根手指。从某种意义 上看，计算机的位只有2根手指，因为它只能被设置为0或1，关闭或打开。 因此，计算机适用基底为2的数制系统。它用2的幂而不是10的幂。以2为基 底表示的数字被称为二进制数（binary number）。二进制中的2和十进制中 的10作用相同。例如，二进制数1101可表示为：
    1×2^3+ 1×2^2+ 0×2^1+ 1×2^0
以十进制数表示为：
    1×8 + 1×4 + 0×2 + 1×1 = 13
用二进制系统可以把任意整数（如果有足够的位）表示为0和1的组合。 由于数字计算机通过关闭和打开状态的组合来表示信息，这两种状态分别用 0和1来表示，所以使用这套数制系统非常方便。

描述存储器芯片和数据传输率中所用的字节指的是8位字节。从左 往右给这8位分别编号为7～0。在1字节中，编号是7的位被称为高阶位 （high-order bit），编号是0的位被称为低阶位（low-order bit）。每 1位的 编号对应2的相应指数。
位编号    7 6 5 4 3 2 1 0  		高阶位所能标识的位值越大， 1*2^阶位=位值;(1*10^阶位=位值)
         0 0 0 0 0 0 0 0
位值	 128 64 32 16 8 4 2 1；128 + 64 + 32 + 16 + 8 + 4 + 2 + 1 = 255；(八位能表达的范围：256)

如何表示有符号整数取决于硬件，而不是C语言。也许表示有符号数最简单的方式是用1位（如，高阶位）储存符号，只剩下7位表示数字本身（假设储存在1字节中）。用这种符号量（sign-magnitude）表示法，10000001表示−1，00000001表示1。因此，其表示范围是−127～+127。
	有两个0：+0和-0。这很容易混淆
	用两个位组 合来表示一个值也有些浪费
二进制补码：
	二进制反码（one’s-complement）方法通过反转位组合中的每一位形成 一个负数
	要得到一个二进制补码数的相反数，最简单的方法是反转每一位（即0 变为1，1变为0），然后加1。因为1是00000001，那么−1则是11111110+1， 或11111111

二进制小数
一个普通的浮点数0.527，表示如下：
    5/10 + 2/100 + 7/1000
从左往右，各分母都是10的递增次幂。在二进制小数中，使用2的幂作为分母，所以二进制小数.101表示为：
    1/2 + 0/4 + 1/8
用十进制表示法为：
    0.50 + 0.00 + 0.125 即是0.625。
许多分数（如，1/3）不能用十进制表示法精确地表示。与此类似，许多分数也不能用二进制表示法准确地表示。实际上，二进制表示法只能精确 地表示多个1/2的幂的和。因此，3/4和7/8可以精确地表示为二进制小数，但 是1/3和2/5却不能。
浮点数表示法：
	为了在计算机中表示一个浮点数，要留出若干位（因系统而异）储存二进制分数，其他位储存指数。一般而言，数字的实际值是由二进制小数乘以2的指定次幂组成。例如，一个浮点数乘以4，那么二进制小数不变，其指数 乘以2，二进制分数不变。如果一份浮点数乘以一个不是2的幂的数，会改变 二进制小数部分，如有必要，也会改变指数部分。

计算机界通常使用八进制记数系统和十六进制记数系统。因为8和16都 是2的幂，这些系统比十进制系统更接近计算机的二进制系统。

八进制（octal）是指八进制记数系统。该系统基于8的幂，用0～7表示 数字（正如十进制用0～9表示数字一样）。例如，八进制数451（在C中写 作0451）表示为：4×82+ 5×81+ 1×80= 297（十进制）了解八进制的一个简单的方法是，每个八进制位对应3个二进制位。这种关系使得八进制与二进制之间的转换很容易。例如，八进制数0377的二进制形式是11111111。即，用111代替0377中的最后一个7，再用111代替倒数第2个7，最后用011代替3，并舍去第1位的 0。这表明比0377大的八进制要用多个字节表示。这是八进制唯一不方便的 地方：一个3位的八进制数可能要用9位二进制数来表示。注意，将八进制数 转换为二进制形式时，不能去掉中间的0。

十六进制（hexadecimal或hex）是指十六进制记数系统。该系统基于16 的幂，用0～15表示数字。但是，由于没有单独的数（digit，即0～9这样单独一位的数）表示10～15，所以用字母A～F来表示。例如，十六进制数 A3F（在C中写作0xA3F）表示为： 10×162+3×161+ 15×160= 2623（十进制）由于A表示10，F表示15。在C语言中，A～F既可用小写也可用大写。 因此，2623也可写作0xa3f。每个十六进制位都对应一个4位的二进制数（即4个二进制位），那么两 个十六进制位恰好对应一个8位字节。第1个十六进制表示前4位，第2个十六 进制位表示后4位。因此，十六进制很适合表示字节值。

C 提供按位逻辑运算符和移位运算符.
按位逻辑运算符：
	按位逻辑运算符都用于整型数据，包括char。之所以叫作按位 （bitwise）运算，是因为这些操作都是针对每一个位进行，不影响它左右两 边的位。不要把这些运算符与常规的逻辑运算符（&&、||和！）混淆，常规 的逻辑运算符操作的是整个值。
	二进制反码或按位取反：～（一元运算符～把1变为0，把0变为1， 该运算符不会改变值）
		～(10011010)　// 表达式
        (01100101)　　// 结果
    按位与：& （二元运算符&通过逐位比较两个运算对象，生成一个新值。对于每个位，只有两个运算对象中相应的位都为1时，结果才为1（从真/假方面看，只有当两个位都为真时，结果才为真））
    	(10010011) & (00111101)　　// 表达式
        (00010001)　　// 结果值
	按位或：|(二元运算符|，通过逐位比较两个运算对象，生成一个新值。对于每个位，如果两个运算对象中相应的位为1，结果就为1（从真/假方面看，如果两个运算对象中相应的一个位为真或两个位都为真，那么结果为真）)
        (10010011) | (00111101) // 表达式
        (10111111) // 结果值
    按位异或：^ (二元运算符^逐位比较两个运算对象。对于每个位，如果两个运算对象中相应的位一个为1（但不是两个为1），结果为1（从真/假方面看，如果两个运算对象中相应的一个位为真且不是两个为同为1，那么结果为真）)
		(10010011) ^ (00111101) // 表达式
		(10101110)　　// 结果值
按位逻辑运算符使用：
按位与运算符常用于掩码（mask）。所谓掩码指的是一些设置为开 （1）或关（0）的位组合。要明白称其为掩码的原因，先来看通过&把一个量与掩码结合后发生什么情况。例如，假设定义符号常量MASK为2 （即， 二进制形式为00000010），只有1号位是1，其他位都是0。下面的语句： flags = flags & MASK; 把flags中除1号位以外的所有位都设置为0，因为使用按位与运算符 （&）任何位与0组合都得0。1号位的值不变（如果1号位是1，那么 1&1得1；如果 1号位是0，那么0&1也得0）。这个过程叫作“使用掩码”，因为掩码中的0隐藏了flags中相应的位。可以这样类比：把掩码中的0看作不透明，1看作透明。表达式flags & MASK相当于用掩码覆盖在flags的位组合上，只有MASK为1的位才可见。 （掩码掩盖了掩码非1位的对应数据）
	flag&=0xff;	获取flag的低八位 (例如，有个数字 0x1234,如果只想将低8位写入到内存中 0x1234&0xff
        0x1234 表示为二进制  0001001000110100
        0xff       表示为二进制  11111111
		两个数做与操作，显然将0xff补充到16位，就是高位补0 此时0xff 为 0000000011111111 与操作  1&0 =0 1&1 =1 这样 0x1234只能保留低八位的数 0000000000110100 也就是 0x34)
有时，需要打开一个值中的特定位，同时保持其他位不变。 flag|=MASK; MASK中为1的位，flags与其对应的位也为1。MASK中为0的位，flags与 其对应的位不变。
和打开特定的位类似，有时也需要在不影响其他位的情况下关闭指定的位。flag&=~MASK;（MASK中为1的位在结果中都被设置（清空）为0。flags中与MASK为0的 位相应的位在结果中都未改变。）  
切换位指的是打开已关闭的位，或关闭已打开的位。可以使用按位异或 运算符（^）切换位。也就是说，假设b是一个位（1或0），如果b为1，则 1^b为0；如果b为0，则1^b为1。另外，无论b为1还是0，0^b均为b。因此， 如果使用^组合一个值和一个掩码，将切换该值与MASK为1的位相对应的位，值与MASK为0的位相对应的位不变。（与1做^会切换位，与0做^会保留位）。假设flags是00001111，MASK是10110110。表达式：
	flags ^ MASK即是：(00001111) ^ (10110110)　　// 表达式
其结果为：
	(10111001)　　　　　　　　 // 结果值
flags中与MASK为1的位相对应的位都被切换了，MASK为0的位相对应的位不变。

有时，需要检查某位的值。(flags & MASK) == MASK; 为了避免信息漏过边界，掩码至少要与其覆盖的值宽度相同。

移位运算符: 移位运算符向左或向右移动位。
左移运算符（<<）将其左侧运算对象每一位的值向左移动其右侧运算对象指定的位数。左侧运算对象移出左末端位的值丢失，用0填充空出的位置.该操作产生了一个新的位值，但是不改变其运算对象。
	(10001010) << 2　 // 表达式
    (00101000)　　　　// 结果值
右移运算符（>>）将其左侧运算对象每一位的值向右移动其右侧运算 对象指定的位数。左侧运算对象移出右末端位的值丢。对于无符号类型，用 0 填充空出的位置；对于有符号类型，其结果取决于机器。空出的位置可用 0填充，或者用符号位（即，最左端的位）的副本填
    (10001010) >> 2　　　　// 表达式，有符号值
    (00100010)　　　　　　 // 在某些系统中的结果值
    (10001010) >> 2　　　　// 表达式，有符号值
    (11100010)　　　　　　 // 在另一些系统上的结果值
    (10001010) >> 2　　　　// 表达式，无符号值
    (00100010)　　　　　　 // 所有系统都得到该结果值
用法：移位运算符
移位运算符针对2的幂提供快速有效的乘法和除法：
	number << n　　　 number乘以2的n次幂
	number >> n　　　 如果number为非负，则用number除以2的n次幂 (取整。末尾直接舍弃)
移位运算符还可用于从较大单元中提取一些位。例如，假设用一个 unsigned long类型的值表示颜色值，低阶位字节储存红色的强度，下一个字 节储存绿色的强度，第 3 个字节储存蓝色的强度。

操控位的第2种方法是位字段（bit field）。位字段是一个signed int或 unsigned int类型变量中的一组相邻的位（C99和C11新增了_Bool类型的位字 段）。位字段通过一个结构声明来建立，该结构声明为每个字段提供标签， 并确定该字段的宽度。
struct {
    unsigned int autfd : 1;
    unsigned int bldfc : 1;
    unsigned int undln : 1;
    unsigned int itals : 1;
} prnt;
根据该声明，prnt包含4个1位的字段。现在，可以通过普通的结构成员 运算符（.）单独给这些字段赋值：
    prnt.itals = 0;
    prnt.undln = 1;
由于每个字段恰好为1位，所以只能为其赋值1或0。变量prnt被储存在 int大小的内存单元中，但是在本例中只使用了其中的4位。带有位字段的结构提供一种记录设置的方便途径。许多设置（如，字体 的粗体或斜体）就是简单的二选一。例如，开或关、真或假。如果只需要使用 1 位，就不需要使用整个变量。内含位字段的结构允许在一个存储单元中 储存多个设置。 如果声明的总位数超过了一个unsigned int类型的大小会怎样？会用到下 一个unsigned int类型的存储位置。一个字段不允许跨越两个unsigned int之间 的边界。编译器会自动移动跨界的字段，保持unsigned int的边界对齐。一旦 发生这种情况，第1个unsigned int中会留下一个未命名的“洞”。字段储存在一个int中的顺序取决于机器。在有些机器上，存储的顺序是从左往右，而在另一些机器上，是从右往左。另外，不同的机器中两个字段边界的位置也有区别。由于这些原因，位字段通常都不容易移植。尽管如此，有些情况却要用到这种不可移植的特性。
通常，把位字段作为一种更紧凑储存数据的方式。

在同类型的编程问题中，位字段和按位运算符是两种可替换的方法，用哪种方法都可以。如果不想用结构成员表示法来访问不同的部分，也可以使用按位运算符来操作。一般而言，这种方法比较麻烦。

对齐指的是如何安排对象在内存中的位 置。例如，为了效率最大化，系统可能要把一个 double 类型的值储存在4 字 节内存地址上，但却允许把char储存在任意地址。大部分程序员都对对齐不 以为然。但是，有些情况又受益于对齐控制。例如，把数据从一个硬件位置 转移到另一个位置，或者调用指令同时操作多个数据项。

C 区别于许多高级语言的特性之一是访问整数中单独位的能力。该特性 通常是与硬件设备和操作系统交互的关键。
C有两种访问位的方法。一种方法是通过按位运算符，另一种方法是在 结构中创建位字段。
C11新增了检查内存对齐要求的功能，而且可以指定比基本对齐值更大 的对齐值。

计算硬件与二进制记数系统密不可分，因为二进制数的1和0可用于表示 计算机内存和寄存器中位的开闭状态。虽然C不允许以二进制形式书写数 字，但是它识别与二进制相关的八进制和十六进制记数法。正如每个二进制 数字表示1位一样，每个八进制位代表3位，每个十六进制位代表4位。这种 关系使得二进制转为八进制或十六进制较为简单。
C 提供多种按位运算符，之所以称为按位是因为它们单独操作一个值中 的每个位。～运算符将其运算对象的每一位取反，将1转为0，0转为1。按位 与运算符（&）通过两个运算对象形成一个值。如果两运算对象中相同号位 都为1，那么该值中对应的位为1；否则，该位为0。按位或运算符（|）同样 通过两个运算对象形成一个值。如果两运算对象中相同号位有一个为1或都 为1，那么该值中对应的位为1；否则，该位为0。按位异或运算符（^）也有 类似的操作，只有两运算对象中相同号位有一个为1时，结果值中对应的位 才为1。
C还有左移（<<）和右移（>>）运算符。这两个运算符使位组合中的所 有位都向左或向右移动指定数量的位，以形成一个新值。对于左移运算符， 空出的位置设为 0。对于右移运算符，如果是无符号类型的值，空出的位设 为0；如果是有符号类型的值，右移运算符的行为取决于实现。
可以在结构中使用位字段操控一个值中的单独位或多组位。具体细节因实现而异。
```

### c预处理器和c库

```

C预处理器在程序执行之前查看程序（故称之为预处理器）。根据程序中的预处理器指令，预处理器把符号缩写替换成其表示的内容。预处理器可以包含程序所需的其他文件，可以选择让编译器查看哪些代码。预处理器并不知道 C。基本上它的工作是把一些文本转换成另外一些文本。
在预处理之前，编译器必须对该程序进行一些翻译处理。首先，编译器把源代码中出现的字符映射到源字符集。该过程处理多字节字符和三字符序列——字符扩展让C更加国际.
第二，编译器定位每个反斜杠后面跟着换行符的实例，并删除它们。也就是说，把下面两个物理行（physicalline）：
printf("That's wond\
erful!\n"); 转换成一个逻辑行（logical line）：printf("That's wonderful\n!");由于预处理表达式的长度必须是一个逻辑行，所以这一步为预处理器做好了准备工作。一个逻辑行可以是多个物理行。
第三，编译器把文本划分成预处理记号序列、空白序列和注释序列（记号是由空格、制表符或换行符分隔的项。这里要注意的是， 编译器将用一个空格字符替换每一条注释.

明示常量：#define
#define预处理器指令和其他预处理器指令一样，以#号作为一行的开始。ANSI和后来的标准都允许#号前面有空格或制表符，而且还允许在#和指令的其余部分之间有空格。但是旧版本的C要求指令从一行最左边开始，而且#和指令其余部分之间不能有空格。指令可以出现在源文件的任何地方，其定义从指令出现的地方到该文件末尾有效。我们大量使用#define指令来定义明示常量（manifest constant）（也叫做符号常量），但是该指令还有许多其他用途.
预处理器指令从#开始运行，到后面的第1个换行符为止。也就是说，指令的长度仅限于一行。然而，前面提到过，在预处理开始前，编译器会把多行物理行处理为一行逻辑行。
每行#define（逻辑行）都由3部分组成。第1部分是#define指令本身。第 2部分是选定的缩写，也称为宏。有些宏代表值，这些宏被称为类对象宏（object-like macro）。C 语言还有类函数宏（function-like macro）。宏的名称中不允许有空格，而且必须遵循C变量的命名规则：只能使用字符、数字和下划线（_）字符，而且首字符不能是数字。第3部分（指令行的其余部分）称为替换列表或替换体。 一旦预处理器在程序中找到宏的示实例后，就会用替换体代替该宏。从宏变成最终替换文本的过程称为宏展开（macro expansion）。注意，可以在#define行使用标准C注释。每条注释都会被一个空格代替。
	#define		PX 		printf("this is a test line");
	预处理器指令	宏		替换体	
由于编译器在编译期对所有的常量表达式（只包含常量的表达式）求值，所以预处理器不会进行实际的乘法运算，这一过程在编译时进行。预处理器不做计算，不对表达式求值，它只进行替换。
一般而言，预处理器发现程序中的宏后，会用宏等价的替换文本进行替换。如果替换的字符串中还包含宏，则继续替换这些宏。唯一例外的是双引号中的宏。
对于绝大部分数字常量，应该使用字符常 量。如果在算式中用字符常量代替数字，常量名能更清楚地表达该数字的含 义。如果是表示数组大小的数字，用符号常量后更容易改变数组的大小和循环次数。如果数字是系统代码（如，EOF），用符号常量表示的代码更容易移植（只需改变EOF的定义）。助记、易更改、可移植，这些都是符号常量很有价值的特性。
具有相同的定义意味着替换体中的记号必须相同，且顺序也相同。如果需要重定义 宏，使用#undef 指令。

在#define中使用参数可以创建外形和作用与函数类似的类函数宏。带有 参数的宏看上去很像函数，因为这样的宏也使用圆括号。类函数宏定义的圆 括号中可以有一个或多个参数，随后这些参数出现在替换体中。
	#define 	MEAN(X,Y)		（((X)+(Y))/2）
				宏（x，y位宏参数）	替换体
函数调用和宏调用的重要区别： 函数调用在程序运行时把参 数的值传递给函数。宏调用在编译之前把参数记号传递给程序。这两个不同 的过程发生在不同时期。
    #define sq(x) x*x
    int i = 10;
    sq(i); // 100
    sq(i+1); // 10+1*10+1 = 21
    100/sq(10); // 100/10*10=100
    sq(++i);	// ++10*++10 = 11*12 (标准并未对这类运算规定顺序，所以有些编译器得 11*12。而有些编 译器可能在乘法运算之前已经递增了x，所以12*12. 解决这个问题最简单的方法是，避免用++x 作为宏参数。一般而言，不要在宏中使用递增或递减运算符。但是，++x可作为函数参数，因为编译器 会对++x求值得5后，再把5传递给函数)
因此，必要时要使用足够多的圆括号来确保运算和结合的正确顺序。尽管如此，这样做还是无法避免程序中最后一种情况的问题。 

C允许在字符串中包含宏参数。在类函数宏的替换体中，#号作为一个预处理运算符，可以把记号转换成字符串。例如，如果x是一个宏形参，那么#x就是转换为字符串"x"的形参名。这个过程称为字符串化.
    #define print(x) printf("the square of #x = %d\r\n", ((x)*(x)))
    int i= 10； print(i); // the square of 10 is 100
    print(2+3)  //  square of 2+3 is 25
    
使用宏比使用普通函数复杂一些，稍有不慎会产生奇怪的副作用。一些 编译器规定宏只能定义成一行。不过，即使编译器没有这个限制，也应该这样做。
宏和函数的选择实际上是时间和空间的权衡。宏生成内联代码，即在程 序中生成语句。如果调用20次宏，即在程序中插入20行代码。如果调用函数 20次，程序中只有一份函数语句的副本，所以节省了空间。然而另一方面， 程序的控制必须跳转至函数内，随后再返回主调程序，这显然比内联代码花 费更多的时间。
宏的一个优点是，不用担心变量类型（这是因为宏处理的是字符串，而 不是实际的值）。因此，只要能用int或float类型都可以使用SQUARE(x)宏
	#define MAX(X,Y) ((X) > (Y) ? (X) : (Y))
	#define ABS(X) ((X) < 0 ? -(X) : (X))
	#define ISSIGN(X) ((X) == '+' || (X) == '-' ? 1 : 0)
当预处理器发现#include 指令时，会查看后面的文件名并把文件的内容 包含到当前文件中，即替换源文件中的#include指令。这相当于把被包含文 件的全部内容输入到源文件#include指令所在的位置。#include指令有两种形 式：
    #include <stdio.h>　　　　 ←文件名在尖括号中（告诉预处理器在标准系统目录中查找该文件）
    #include "mystuff.h"　　　←文件名在双引号中（告诉预处理器首先在当前目录中（或文件名中指定的其他目录）查找 该文件，如果未找到再查找标准系统目录）
ANSI C不为文件提供统一的目录模型，因为不同的计算机所用的系统不同。一般而言，命名文件的方法因系统而异，但是尖括号和双引号的规则与系统无关。为什么要包含文件？因为编译器需要这些文件中的信息。
C语言习惯用.h后缀表示头文件，这些文件包含需要放在程序顶部的信息。头文件经常包含一些预处理器指令。有些头文件（如stdio.h）由系统提供，当然你也可以创建自己的头文件。
包含一个大型头文件不一定显著增加程序的大小。在大部分情况下，头文件的内容是编译器生成最终代码时所需的信息，而不是添加到最终代码中的材料（编译器在创建可执行代码时所需的信 息，而不是可执行代码）。可执行代码通常在源代码文件中，而不是在头文件中。
浏览任何一个标准头文件都可以了解头文件的基本信息。头文件中最常用的形式如下：
	明示常量
    宏函数（函数原型形式）
    结构模版定义
    类型定义
其他指令：
	#undef指令用于“取消”已定义的#define指令（，#define宏的作用域从它在文件中的声明处开始，直到用#undef指 令取消宏为止，或延伸至文件尾）。另外还要注意，如果宏通过头文件引入，那么#define在文件中的位置 取决于#include指令的位置。）
	#ifdef、#else和#endif指令。创建条件编译（conditinal compilation）。也就是说，可以使用这些指令告诉编译器根据编译时的条件执行或忽略信息。#ifdef指令说明，如果预处理器已定义了后面的标识符（MAVIS），则 执行#else或#endif指令之前的所有指令并编译所有C代码（先出现哪个指令 就执行到哪里）。如果预处理器未定义MAVIS，且有 #else指令，则执行 #else和#endif指令之间的所有代码。#ifdef #else很像C的if else。两者的主要区别是，预处理器不识别用于标记块的花括号（{}），因此它使用#else（如果需要）和#endif（必须存在） 来标记指令块。这些指令结构可以嵌套。也可以用这些指令标记C语句块.
	通常，包含多个头文件时，其中的文件可能包含了相同宏定义。#ifndef 指令可以防止相同的宏被重复定义。在首次定义一个宏的头文件中用#ifndef 指令激活定义，随后在其他头文件中的定义都被忽略。

为何要多次包含一个文件？最常见的原因是，许多被包含的文件中都包含着其他文件，所以显式包含的文件中可能包含着已经包含的其他文件。这有什么问题？在被包含的文件中有某些项（如，一些结构类型的声明）只能在一个文件中出现一次。C标准头文件使用#ifndef技巧避免重复包含。但是，这存在一个问题：如何确保待测试的标识符没有在别处定义。通常，实现的供应商使用这些方法解决这个问题：用文件名作为标识符、使用大写字母、用下划线字符代替文件名中的点字符、用下划线字符做前缀或后缀（可能使用两条下划线）。
条件编译还有一个用途是让程序更容易移植。改变文件开头部分的几个 关键的定义，即可根据不同的系统设置不同的值和包含不同的文件。

C标准规定了一些预定义宏:
    __FILE__: 当前源代码文件的字符字面量
    __DATE__: 预处理日期
    __TIME__: 翻译代码的时间
    __LINE__: 当前行 （#line 10 "cool.c" // 把行号重置为10，把文件名重置为cool.c）
    __func__: 当前所在函数
	#error 指令让预处理器发出一条错误消息，该消息包含指令中的文本。 如果可能的话，编译过程应该中断。
在现在的编译器中，可以通过命令行参数或IDE菜单修改编译器的一些设置。#pragma把编译器指令放入源代码中。例如，在开发C99时，标准被 称为C9X，可以使用下面的编译指示（pragma）让编译器支持C9X：
    #pragma c9x on

在程序设计中，泛型编程（generic programming）指那些没有特定类型，但是一旦指定一种类型，就可以转换成指定类型的代码。例如，C++在模板中可以创建泛型算法，然后编译器根据指定的类型自动使用实例化代码。C没有这种功能。然而，C11新增了一种表达式，叫作泛型选择表达式 （generic selection expression），可根据表达式的类型（即表达式的类型是 int、double 还是其他类型）选择一个值。泛型选择表达式不是预处理器指令，但是在一些泛型编程中它常用作#define宏定义的一部分。

通常，函数调用都有一定的开销，因为函数的调用过程包括建立调用、 传递参数、跳转到函数代码并返回。使用宏使代码内联，可以避免这样的开销。	
把函数变成内联函数建议尽可能快地调用该函数，其具体效果由实现定义.。因此，把函数变成内联函数，编译器可能会用内联代码替换函数 调用，并（或）执行一些其他的优化，但是也可能不起作用。
创建内联函数的定义有多种方法。标准规定`具有内部链接的函数可以成为内联函数，还规定了内联函数的定义与调用该函数的代码必须在同一个文件中`。因此，最简单的方法是使用函数说明符 inline 和存储类别说明符 static。通常，内联函数应定义在首次使用它的文件中，所以内联函数也相当于函数原型。
由于并未给内联函数预留单独的代码块，所以无法获得内联函数的地址（实际上可以获得地址，不过这样做之后，编译器会生成一个非内联函数）。另外，内联函数无法在调试器中显示。内联函数应该比较短小。把较长的函数变成内联并未节约多少时间，因为执行函数体的时间比调用函数的时间长得多。编译器优化内联函数必须知道该函数定义的内容。这意味着内联函数定义与函数调用必须在同一个文件中。鉴于此，一般情况下内联函数都具有内部链接。因此，如果程序有多个文件都要使用某个内联函数，那么这些文件中都必须包含该内联函数的定义。最简单的做法是，把内联函数定义放入头文件，并在使用该内联函数的文件中包含该头文件即可.一般都不在头文件中放置可执行代码，内联函数是个特例。因为内联函数具有内部链接，所以在多个文件中定义同一个内联函数不会产生什么问题。


如何访问C库：
	自动访问：在一些系统中，只需编译程序，就可使用一些常用的库函数。记住，在使用函数之前必须先声明函数的类型，通过包含合适的头文件即可完成。在描述库函数的用户手册中，会指出使用某函数时应包含哪个头文件。但是在一些旧系统上，可能必须自己输入函数声明。再次提醒读者， 用户手册中指明了函数类型。
	文件包含： 如果函数被定义为宏，那么可以通过#include 指令包含定义宏函数的文件。通常，类似的宏都放在合适名称的头文件中。
	库包含：在编译或链接程序的某些阶段，可能需要指定库选项。即使在自动检查标准库的系统中，也会有不常用的函数库。必须通过编译时选项显式指定这些库。注意，这个过程与包含头文件不同。头文件提供函数声明或原型，而库选项告诉系统到哪里查找函数代码。
	
atexit()函数的用法： 函数使用函数指针。要使用atexit()函数，只需把退出时要调用的函数地址传递给atexit()即可。函数名作为函数参数时相当于该函数的地址。atexit()注册的函数应该不带任何参数且返回类型为void。通常，这些函数会执行一些清理任务，例如更新监视程序的文件或重置环境变量。另外还要注意，最先调用的是最后一个被注册的函数。注意，即使没有显式调用exit()，还是会调用atexit()所注册的函数。
exit()执行完atexit()指定的函数后，会完成一些清理工作：刷新所有输出流、关闭所有打开的流和关闭由标准I/O函数tmpfile()创建的临时文件。然后exit()把控制权返回主机环境，如果可能的话，向主机环境报告终止状态。 通常，UNIX程序使用0表示成功终止，用非零值表示终止失败。UNIX返回的代码并不适用于所有的系统，所以ANSI C为了可移植性的要求，定义了一个名为EXIT_FAILURE的宏表示终止失败。类似地，ANSI C还定义了EXIT_SUCCESS表示成功终止。不过，exit()函数也接受0表示成功终止。在 ANSI C中，在非递归的main()中使用exit()函数等价于使用关键字return。尽管如此，在main()以外的函数中使用exit()也会终止整个程序。

ANSI C允许把指向任何数据类型的指针强制转换成指向void的指针。
	
assert.h 头文件支持的断言库是一个用于辅助调试程序的小型库。它由 assert()宏组成，接受一个整型表达式作为参数。如果表达式求值为假（非零），assert()宏就在标准错误流（stderr）中写入一条错误信息，并调用 abort()函数终止程序（abort()函数的原型在stdlib.h头文件中）。assert()宏是为了标识出程序中某些条件为真的关键位置，如果其中的一个具体条件为假，就用 assert()语句终止程序。通常，assert()的参数是一个条件表达式或逻辑表达式。如果 assert()中止了程序，它首先会显示失败的测试、包含测试的文件名和行号。

不能把一个数组赋给另一个数组，所以要通过循环把数组中的每个元素赋给另一个数组相应的元素。

C标准不仅描述C语言，还描述了组成C语言的软件包、C预处理器和C 标准库。通过预处理器可以控制编译过程、列出要替换的内容、指明要编译的代码行和影响编译器其他方面的行为。C库扩展了C语言的作用范围，为许多编程问题提供现成的解决方案。
C预处理器和C库是C语言的两个重要的附件。C预处理·遵循预处理器指令，在编译源代码之前调整源代码。C 库提供许多有助于完成各种任务的函数，包括输入、输出、文件处理、内存管理、排序与搜索、数学运算、字符串处理等。
```

### 高级数据表示

```
通常，程序开发最重要的部分是`找到程序中表示数据的好方法`。正确地表示数据可以更容易地编写程序其余部分。然而，`找出正确的数据表示不仅仅是选择一种数据类型，还要考虑必须进行哪些操作`。也就是说，必须确定如何储存数据，并且为数据类型定义有效的操作。(C语言为自己的的内置数据类型都定义了数据的储存方式和操作)
不同的数据表示方式往往决定了程序的不同实现逻辑。（开发中为什么要先等待表结构？）
设计一种数据类型包括设计如何储存该数据类型和设计 一系列管理该数据的函数。（类？ 对数据封装的封装并提供操作数据的接口）
面向问题和面向语言。`抽象数据类型以面向问题而不是面向语言的方式，把解决问题的方法和数据表示结合起来。`(编程是为了解决特定的问题，程序编写应当对问题域进行建模而非对语言建模)设计一个 ADT后，可以在不同的环境中复用。

理想的情况是，用户可以不确定地添加数据（或者不断添加数据直到用完内存量），而不是先指定要输入多少项，也不用让程序分配多余的空间。 
比较一下，一种方法是调用malloc() 一次，为300个filem结构请求分配足够的空间；另一种方法是调用malloc()300次，分别为每个file结构请求分配足够的空间。前者分配的是连续的内存块，只需要一个单独的指向struct变量的指针，该指针指向已分配块中的第1个结构。简单的数组表示法让指针访问块中的每个结构。第2种方法的问题是，无法保证每次调用malloc()都能分 配到连续的内存块。这意味着结构不一定被连续储存。因此， 与第1种方法储存一个指向300个结构块的指针相比，你需要储存300个指针，每个指针指向一个单独储存的结构。

结构不能含有与本身类型相同的结构，但是可以含有指向同类型结构的指针。这种定义是定义链表（linked list）的基础，链表中的每一项都包含着在何处能找到下一项的信息。

创建链表涉及下面3步：
    （1）使用malloc()为结构分配足够的空间；
    （2）储存结构的地址；
    （3）把当前信息拷贝到结构中。
    
在编程时，应该根据编程问题匹配合适的数据类型。例如，用int类型代 表你有多少双鞋，用float或 double 类型代表每双鞋的价格。

什么是类型？类型特指两类信息：`属性和操作`。例如，int 类型的属性是它代表一个整数值，因此它共享整数的属性。C的int类型背后是一个更抽象的整数概念。数学家已经用正式的抽象方 式定义了整数的属性。例如，假设N和M是整数，那么N+M=M+N；假设S、 Q也是整数，如果N+M=S，而且N+Q=S，那么M=Q。可以认为数学家提供 了整数的抽象概念，而C则实现了这一抽象概念。注意，实现整数的算术运 算是表示整数必不可少的部分。如果只是储存值，并未在算术表达式中使 用，int类型就没那么有用了.
假设要定义一个新的数据类型。首先，必须提供储存数据的方法，例如 设计一个结构。其次，必须提供操控数据的方法。

定义新类型的方法:
	1.提供类型属性和相关操作的抽象描述。这些描述既不能依赖特定的实现，也不能依赖特定的编程语言。这种正式的抽象描述被称为抽象数据类型 （ADT）。
	2.开发一个实现 ADT 的编程接口。也就是说，指明如何储存数据和执行所需操作的函数。例如在 C中，可以提供结构定义和操控该结构的函数原型。这些作用于用户定义类型的函数相当于作用于 C基本类型的内置运算符。需要使用该新类型的程序员可以使用这个接口进行编程。
	3.编写代码实现接口。这一步至关重要，但是使用该新类型的程序员无需了解具体的实现细节。

具有内部链接的函数只能在其声明所在的文 件夹可见。在实现接口时，有时编写一个辅助函数（不作为正式接口的一部 分）很方便。
对大型编程项目而言，这种把实现和最终接口隔离的做法相 当有用。这称为数据隐藏，因为对终端用户隐藏了数据表示的细节。

使用抽象数据类型方法编程包含以下3个步骤。
    1.以抽象、通用的方式描述一个类型，包括该类型的操作。
    2.设计一个函数接口表示这个新类型。
    3.编写具体代码实现这个接口。

队列（queue）是具有两个特殊属性的链表。第一，新项只能添加到链 表的末尾。从这方面看，队列与简单链表类似。第二，只能从链表的开头移 除项。可以把队列想象成排队买票的人。你从队尾加入队列，买完票后从队 首离开。队列是一种“先进先出”（first in,first out，缩写为FIFO）的数据形.
```

