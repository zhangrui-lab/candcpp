#### try语句块和异常处理

* **异常是指存在于运行时的反常行为，这些行为超出了函数正常功能的范围**。典型的异 常包括失去数据库连接以及遇到意外输入等。处理反常行为可能是设计所有系统最难的一 部分。
* **当程序的某部分检测到一个它无法处理的问题时，需要用到异常处理。此时，检测出问题的部分应该发出某种信号以表明程序遇到了故障，无法继续下去了，而且信号的发出方无须知道故障将在何处得到解决。一旦发出异常信号，检测出问题的部分也就完成了任务。**
* **如果程序中含有可能引发异常的代码，那么通常也会有专门的代码处理问题。**
* 异常处理机制为程序中**异常检测**和**异常处理**这两部分的协作提供支持。在C++语言 中，异常处理包括：
  *  throw表达式(throw expression),**异常检测部分使用throw表达式来表示它遇到了无法处理的问题**。我们说throw引发(raise) 了异常。
  *  try语句块(try block), **异常处理部分使用try语句块处理异常**。try语句块以关键字try开始，并以一个或多个catch子句(catch clause)结束。try语句块中代码抛出的异常通常会被某个catch子句处理。因为catch子句“处理”异常， 所以它们也被称作异常处理代码(exception handler)。 —套异常类(exception class),用于在throw表达式和相关的catch子句之间传递异常的具体信息。

*  throw 表达式
  * 程序的异常检测部分使用throw表达式引发一个异常。**throw表达式包含关键字 throw和紧随其后的一个表达式，其中表达式的类型就是抛出的异常类型**。throw表达式后面通常紧跟一个分号，从而构成一条表达式语句。

* **抛出异常将终止当前的函数，并把控制权转移给能处理该异常的代码。**

* try语句块

  * try语句块的通用语法形式是

    ```
    try {
        program-statements
    ) catch (exception-declaration) {
        handler-statements
    } catch (exception-declaration) (
        handler-statements
    }//...
    ```

    try语句块的一开始是关键字try,随后紧跟着一个块，这个块就像大多数时候那样是花括号括起来的语句序列。

  * 跟在try块之后的是一个或多个catch子句。**catch子句包括三部分：关键字 catch、括号内一个 (可能未命名的) 对象的声明(称作异常声明，exception declaration) 以及一个块**。当选中了某个catch子句处理异常之后，执行与之对应的块。catch 一旦完成，程序跳转到try语句块最后一个catch子句之后的那条语句继续执行
  * try语句块中的 program-statements 组成程序的正常逻辑，像其他任何块一样，program-statements 可以有包括声明在内的任意C++语句。一如往常，**try语句块内声明的变量在块外部无法访问，特别是在catch子句内也无法访问。**

* 每个标准库异常类都定义了名为what的成员函数，这些函数没有参数， 返回值是C风格字符串(即const char* ), 其中，runtime_error的what成员返回的是初始化一个具体对象时所用的string对象的副本。

* 函数在寻找处理代码的过程中退出
  * **在复杂系统中，程序在遇到抛出异常的代码前，其执行路径可能已经经过了多个try 语句块**。例如，一个try语句块可能调用了包含另一个try语句块的函数，新的try语 句块可能调用了包含又一个try语句块的新函数，以此类推。
  * **寻找处理代码的过程与函数调用链刚好相反。当异常被抛出时，首先搜索抛出该异常的函数**。如果没找到匹配的catch子句，终止该函数，并在调用该函数的函数中继续寻找。如果还是没有找到匹配的catch子句，这个新的函数也被终止，继续搜索调用它的 函数。以此类推，**沿着程序的执行路径逐层回退，直到找到适当类型的catch子句为止**。如果最终还是没能找到任何匹配的catch子句，程序转到名为terminate的标准库函数。该函数的行为与系统有关，一般情况下，执行该函数将导致程序非正常退出。
  * 对于那些没有任何try语句块定义的异常，也按照类似的方式处理：毕竟，没有try 语句块也就意味着没有匹配的catch子句。如果一段程序没有try语句块且发生了异常， 系统会调用terminate函数并终止当前程序的执行。

* 提示：编写异常安全的代码非常困难

  * 要好好理解这句话：**异常中断了程序的正常流程**. 异常发生时，**调用者请求的一部 分计算可能已经完成了，另一部分则尚未完成**。通常情况下，略过部分程序意味着**某些对象处理到一半就戛然而止，从而导致对象处于无效或未完成的状态，或者资源没有正 常释放，等等**。那些**在异常发生期间正确执行了 “清理”工作的程序被称作异常安全 (exception safe )的代码**。对于一些程序来说，当异常发生时只是简单地终止程序,，此时，我们不怎么需要担心异常安全的问题。但是对于那些确实要处理异常并继续执行的程序，就要加倍注意了。我们**必须时刻清楚异常何时发生，异常发生后程序应如何确保对象有效、资源无泄漏、程序处于合理状态，等等**。

* 标准异常

  * C++标准库定义了一组类，用于报告标准库函数遇到的问题。这些异常类也可以在用 户编写的程序中使用，它们分别定义在4个头文件中

  * exception头文件定义了最通用的异常类exception。它只报告异常的发生， 不提供任何额外信息。

  * stdexcept头文件定义了几种常用的异常类

    | 异常             | 描述                                           |
    | ---------------- | ---------------------------------------------- |
    | runtime_error    | 只有在运行时才能检测出的问题                   |
    | range_error      | 运行时错误：生成的结果超出了有意义的值域范围   |
    | overflow_error   | 运行时错误：计算上溢                           |
    | underflow_error  | 运行时错误：计算下溢                           |
    | logic_error      | 程序逻辑错误                                   |
    | domain_error     | 逻辑错误：参数对应的结果值不存在               |
    | invalid_argument | 逻辑错误：无效参数                             |
    | length_error     | 逻辑错误：试图创建一个超出该类型最大长度的对象 |
    | out of range     | 逻辑错误：使用个超出有效范围的值               |
    | exception        | 常见的问题                                     |

  * new头文件定义了 bad_alloc异常类型

  * type_info头文件定义了 bad_cast异常类型

* 标准库异常类只定义了几种运算，包括创建或拷贝异常类型的对象，以及为异常类型 的对象赋值。

* 我们**只能以默认初始化的方式初始化exception, bad_alloc和bad_cast对象，不允许为这些对象提供初始值。其他异常类型的行为则恰好相反：应该使用string对象或者C风格字符串初始化这些类型的对象，但是不允许使用默认初始化的方式。**当创建此类对象时，必须提供初始值， 该初始值含有错误相关的信息。

* **异常类型只定义了一个名为what的成员函数**，该函数没有任何参数，返回值是一个 指向C风格字符串的 const char* .该字符串的目的是提供关于异常的一些文本信息。**what函数返回的C风格字符串的内容与异常对象的类型有关**。如果异常类型有一个字符串初始值，则what返回该字符串。对于其他无初始值的异常类型来说，what返回的内容由编译器决定。

####  小结

* C++语言仅提供了有限的语句类型，它们中的大多数会影响程序的控制流程：
  * while、for和do while语句，执行**迭代操作**。
  * if和switch语句，提供条件**分支结构**。
  * continue语句，终止循环的当前一次迭代。
  * break语句，退出循环或者switch语句。
  * goto 语句，将**控制权转移到一条带标签的语句**。
  * try和catch,将一段可能抛出异常的语句序列括在花括号里构成try语句块。 catch子句负责处理代码抛出的异常。
  * throw表达式语句，存在于代码块中，将控制权转移到相关的catch子句。
  * return语句，终止函数的执行。