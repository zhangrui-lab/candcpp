##### 写容器元素的算法

* 一些算法**将新值赋予序列中的元素**。当我们使用这类算法时，必须注意**确保序列原大小至少不小于我们要求算法写入的元素数目**。记住，算法不会执行容器操作，因此它们自身不可能改变容器的大小。
* 一些算法会自己向输入范围写入元素。这些算法本质上并不危险，它们最多写入与给 定序列一样多的元素。

* 关键概念：迭代器参数 
  * **一些算法从两个序列中读取元素。 构成这两个序列的元素可以来自于不同类型的容器**。例如，第一个序列可能保存于一个vector中，而第二个序列可能保存于一个list,  deque、内置数组或其他容器中。而且，**两个序列中元素的类型也不要求严格匹配**。算 法要求的只是能够比较两个序列中的元素，例如，对equal算法，元素类型不要求相同，但是我们必须能使用==来比较来自两个序列中的元素.
  * 操作两个序列的算法之间的区别在于**我们如何传递第二个序列**。一些算法，例如 equal,接受三个迭代器：**前两个表示第一个序列的范围，第三个表示第二个序列中的 首元素其他算法接受四个迭代器：前两个表示第一个序列的元素范围，后两个表示第二个序列的范围。**
  * **用一个单一迭代器表示第二个序列的算法都假定第二个序列至少与第一个一样长。 确保算法不会试图访问第二个序列中不存在的元素是程序员的责任。**例如，算法equal 会将其第一个序列中的每个元素与第二个序列中的对应元素进行比较。如果第二个序列 是第一个序列的一个子集，则程序会产生一个严重错误——equal会试图访问第二个序 列中末尾之后(不存在)的元素。

* 算法不检查写操作
  * **一些算法接受一个迭代器来指出一个单独的目的位置。这些算法将新值赋予一个序列 中的元素，该序列从目的位置迭代器指向的元素开始。**例如，函数fill_n接受一个单迭 代器、一个计数值和一个值。它将给定值赋予迭代器指向的元素开始的指定个元素。
* **向目的位置迭代器写入数据的算法假定目的位置足够大，能容纳要写入的元素**

* 介绍 back_inserter
  * 一种**保证算法有足够元素空间来容纳输出数据的方法是使用插入迭代器(insert iterator)。**插入迭代器是一种**向容器中添加元素的迭代器**。通常情况，当我们通过一个迭代器向容器元素赋值时，值被赋予迭代器指向的元素。而当我们通过一个插入迭代器赋值时，一个与赋值号右侧值相等的元素被添加到容器中。
  * back_inserter 接受一个指向容器的引用，返回一个与该容器绑定的插入迭代器。 当我们通过此迭代器赋值时，赋值运算符会调用push_back将一个具有给定值的元素添加到容器中
* 拷贝算法
  * **拷贝(copy)算法是另一个向目的位置迭代器指向的输出序列中的元素写入数据的算法。**此算法接受三个迭代器，前两个表示一个输入范围，第三个表示目的序列的起始位 置。此算法将输入范围中的元素拷贝到目的序列中。传递给copy的目的序列至少要包含 与输入序列一样多的元素，这一点很重要。

##### 重排容器元素的算法

* **某些算法会重排容器中元素的顺序**，一个明显的例子是sort。调用sort会重排输 入序列中的元素，使之有序，**它是利用元素类型的 < 运算符来实现排序的。**
* 消除重复单词	
  * 为了消除重复单词，首先**将vector排序，使得重复的单词都相邻出现**。一旦 vector 排序完毕，我们就可以使用另一个称为**unique的标准库算法来重排vector,使得不重复的元素出现在vector的开始部分**。由于算法不能执行容器的操作，我们将**使用vector 的erase成员来完成真正的删除操作**
* **标准库算法对迭代器而不是容器进行操作。因此，算法不能(直接)添加或删除元素。**

##### 定制操作

* 很多算法都会比较输入序列中的元素。默认情况下，这类算法使用元素类型的＜ 或 = 运算符完成比较。标准库还为这些算法定义了额外的版本，允许我们提供自己定义的操作来代替默认运算符。
  * 例如，sort算法默认使用元素类型的 < 运算符。但可能我们希望的排序顺序与 < 所定 义的顺序不同，或是我们的序列可能保存的是未定义〈运算符的元素类型。在这两种情况下，都需要重载sort的默认行为。
* 谓词
  * **谓词是一个可调用的表达式，其返回结果是一个能用作条件的值**。标准库算法所使用的谓词分为两类：**一元谓词**（unary predicate, 意味着它们只接受单一参数）和**二元谓词** （binary predicate,意味着它们有两个参数）。**接受谓词参数的算法对输入序列中的元素调用谓词。因此，元素类型必须能转换为谓词的参数类型。**
* 排序算法
  * 在我们将words按大小重排的同时，还希望具有相同长度的元素按字典序排列。为 了保持相同长度的单词按字典序排列，可以使用stable_sort算法。这种**稳定排序算法维持相等元素的原有顺序**。

##### lambda 表达式

* 根据算法接受一元谓词还是二元谓词，我们传递给算法的谓词必须严格接受一个或两 个参数。但是，有时我们希望进行的操作需要更多参数，超出了算法对谓词的限制。
* 我们可以向一个算法传递任何类别的**可调用对象(callable object)**。**对于一个对象或一个表达式，如果可以对其使用调用运算符，则称它为可调用的**。即，如果e是一个可调用的表达式，则我们可以编写代码 e(args) ,其中 args 是一 个逗号分隔的一个或多个参数的列表。到目前为止，我们使用过的仅有的两种可调用对象是**函数和函数指针**。还有其他两种可调用对象：**重载了函数调用运算符的类**，以及 ** lambda 表达式(lambda expression)**。
* **一个lambda表达式表示一个可调用的代码单元。我们可以将其理解为一个未命名的内联函数**。与任何函数类似，一个lambda具有一个返回类型、一个参数列表和一个函数 体。但与函数不同，**lambda可能定义在函数内部**。一个lambda表达式具有如下形式 `[capture list] (parameter list) -> return type { function body }` 其中，**capture_list (捕获列表)**是一个lambda所在函数中定义的局部变量的列表(通常为 空)；**return type、parameter list**和**function body**与任何普通函数一样，分别表示返回类型、 参数列表和函数体。但是，与普通函数不同，**lambda必须使用尾置返回来指定返回类型**。
* **我们可以忽略参数列表和返回类型，但必须永远包含捕获列表和函数体**

* lambda的调用方式与普通函数的调用方式相同，都是使用调用运算符
* 在lambda中**忽略括号和参数列表等价于指定一个空参数列表**。如果**忽略返回类型，lambda根据函数体中的代码推断出返回类型**。 如果函数体只是一个return语句，则返回类型从返回的表达式的类型推断而来。否则， 返回类型为void
* 向lambda传递参数
  * 与一个普通函数调用类似，调用一个lambda时给定的实参被用来初始化lambda的形参。通常，实参和形参的类型必须匹配。但与普通函数不同，**lambda不能有默认参数**。因此，**一个lambda调用的实参数冃永远与形参数目相等**。一旦 形参初始化完毕，就可以执行函数体了。
* 使用捕获列表
  * 虽然一个lambda可以出现在一个函数中，使用其局部变量，但它**只能使用那些明确指明的变量**。一个**lambda通过将局部变量包含在其捕获列表中来指岀将会使用这些变量。 捕获列表指引lambda在其内部包含访问局部变量所需的信息。**
* for_each算法
  * 此算法接受一个可调用对象，并对输入序列中每个元素调用此对象
* **捕获列表只用于局部非static变量，lambda可以直接使用局部static变量和在它所在函数之外声明的名字。**

* lambda捕获和返回
  * **当定义一个lambda时，编译器生成一个与lambda对应的新的(未命名的)类类型。 当向一个函数传递一个lambda时，同时定义了一个新类型和该类型的一个对象：传递的参数就是此编译器生成的类类型的未命名对象。类似的，当使用auto定义一个用lambda初始化的变量时，定义了一个从lambda生成的类型的对象。**
  * **默认情况下，从lambda生成的类都包含一个对应该lambda所捕获的变量的数据成员。** 类似任何普通类的数据成员，lambda的数据成员也在lambda对象创建时被初始化。

* 值捕获
  * **类似参数传递，变量的捕获方式也可以是值或引用。**到目前为止，我们的lambda釆用值捕获的方式。与传值参数类似，采用值捕获的前提是变量可以拷贝。**与参数不同，被捕获的变量的值是在 lambda 创建时拷贝，而不是调用时拷贝**。由于被捕获变量的值是在lambda创建时拷贝，因此随后对其修改不会影响到lambda内对 应的值。
* 引用捕获
  * 我们定义lambda时可以采用引用方式捕获变量。
  * 一个以引用方式捕获的变量与其他任何类型的 引用的行为类似。当我们在lambda函数体内使用此变量时，实际上使用的是引用所绑定的对象。
  * **引用捕获与返回引用有着相同的问题和限制**。如果我们釆用引用方式捕获一个变量，就**必须确保被引用的对象在lambda执行的时候是存在的**。 lambda捕获的都是局部变量，这些变量在函数结束后就不复存在了。如果lambda可能在函数结束后执行，捕获的引用指向的局部变量已经消失。
  * 我们也**可以从一个函数返回lambda。函数可以直接返回一个可调用对象，或者返回一个类对象，该类含有可调用对象的数据成员**。如果函数返回一个lambda, 则与函数不能返回一个局部变量的引用类似，此lambda也不能包含引用捕获。
  * **当以引用方式捕获一个变量时，必须保证在lambda执行时变量是存在的；**
* 尽量保持 lambda 的变量捕获简单化
  * 一个lambda捕获从lambda被创建(即，定义lambda的代码执行时)到lambda自 身执行(可能有多次执行)这段时间内保存的相关信息。**确保lambda每次执行的时候这些信息都有预期的意义，是程序员的责任。**
  * 捕获一个普通变量，如int、string或其他非指针类型，通常可以采用简单的值捕获方式。在此情况下，只需关注变量在捕获时是否有我们所需的值就可以了。
  * 如果我们捕获一个指针或迭代器，或采用引用捕获方式，就必须确保在lambda执行时，**绑定到迭代器、指针或引用的对象仍然存在。而且，需要保证对象具有预期的值**， 在**lambda 从创建到它执行的这段时间内，可能有代码改变绑定的对象的值**。也就是说， 在指针(或引用)被捕获的时刻，绑定的对象的值是我们所期望的，但在lambda执行 时，该对象的值可能已经完全不同了。
  * **一般来说，我们应该尽量减少捕获的数据量，来避免潜在的捕获导致的问题。而且， 如果可能的话，应该避免捕获指针或引用。**
* 隐式捕获
  * 除了显式列出我们希望使用的来自所在函数的变量之外，还可以让编译器根据lambda 体中的代码来推断我们要使用哪些变量。为了指示编译器推断捕获列表，应在捕获列表中写一个&或=。&告诉编译器采用捕获引用方式，=则表示釆用值捕获方式。
  * 如果我们希望对一部分变量采用值捕获，对其他变量釆用引用捕获，可以混合使用隐式捕获和显式捕获
  * **当我们混合使用隐式捕获和显式捕获时，捕获列表中的第一个元素必须是一个&或=**。此符 号指定了默认捕获方式为引用或值。
  * **当混合使用隐式捕获和显式捕获时，显式捕获的变量必须使用与隐式捕获不同的方式**。即，如果隐式捕获是引用方式(使用了&),则显式捕获命名变量必须采用值方式，因此不能在其名字前使用&。类似的，如果隐式捕获釆用的是值方式(使用了=),则显式捕 获命名变量必须釆用引用方式，即，在名字前使用&。
*  可变lambda
  * 默认情况下，对于一个值被拷贝的变量，lambda不会改变其值。如果我们希望能改变 一个被捕获的变量的值，就必须在参数列表首加上关键字mutable。因此，可变lambda 能省略参数列表
  * 一个引用捕获的变量是否(如往常一样)可以修改依赖于此引用指向的是一个const 类型还是一个非const类型

* 指定lambda返回类型

  * 到目前为止，我们所编写的 lambda 都只包含单一的return语句。因此，我们还未遇到必须指定返回类型的情况。默认情况下，**如果一个lambda体包含return之外的任何语句，则编译器假定此lambda返回void**。与其他返回void的函数类似，被推断返回 void的lambda不能返回值。

* 参数绑定

  * 对于那种**只在一两个地方使用的简单操作，lambda表达式是最有用的**。如果我们**需要在很多地方使用相同的操作，通常应该定义一个函数**，而不是多次编写相同的lambda表 达式。类似的，**如果一个操作需要很多语句才能完成，通常使用函数更好**。
  * **如果lambda的捕获列表为空，通常可以用函数来代替它。**但是，对于捕获局部变量的lambda,用函数来替换它就不是那么容易了。

* 标准库bind函数

  * **使用一个新的名为 bind 的标准库函数，它定义在头文件functional中。可以将bind函数看作一个通用 的函数适配器，它接受一个可调用对象，生成一个新的可调用对象来"适应”原对象的参数列表。**
  * 调用bind的一般形式为：`auto newCallable = bind(callable, arg_list);`其中，**newCallable**本身是一个可调用对象，**arg_list**是一个逗号分隔的参数列表，对应给 定的**callable**的参数。即，当我们调用newCallable , newCallable会调用callable并传 递给它arg_list中的参数。
  * **function是一个template，定义于头文件functional中**。通过function<int(int, int)> 声明一个function类型，它是“接受两个int参数、返回一个int类型”的可调用对象，这里可调用对象可以理解为函数指针（指针指向一个函数，该函数有两个int类型参数，返回int类型，即：int (*p)(int, int) ）。
  * 可调用对象：对于一个对象或表达式，如果可以对其使用调用运算符，则称该对象或表达式为可调用对象。
  * C++语言中有几种可调用对象：函数、函数指针、lambda表达式、bind创建的对象以及重载了函数调用运算符的类。和其他对象一样，**可调用对象也有类型**。例如，**每个lambda有它自己唯一的（未命名）类类型**；函数及函数指针的类型则由其返回值类型和实参类型决定。

* 使用placeholders名字

  * 名字 \_n 都定义在一个名为placeholders的命名空间中，而这个命名空间本身定义在std命名空间中。为了使用这些名字，两个命名空间都要写 上。与我们的其他例子类似，对bind的调用代码假定之前己经恰当地使用了 using声 明。例如，对应的using声明为：`using std::placeholders::\_1;`此声明说明我们要使用的名字\_1定义在命名空间placeholders中，而此命名空间又定 义在命名空间std中。
  * 对每个占位符名字，我们都必须提供一个单独的using声明。编写这样的声明很烦 人，也很容易出错。可以使用另外一种不同形式的using语句，而不是分别声明每个占位符，如下所示：`using namespace namespace name;`这种形式说明希望所有来自namespace_name的名字都可以在我们的程序中直接使用。例 如：`using namespace std::placeholders;` 使得由placeholders定义的所有名字都可用。与bind函数一样,placeholders命名空间也定义在functional头文件中。

* bind的参数

  * 如前文所述，我们可以用bind修正参数的值。更一般的，可以**用bind绑定给定可调用对象中的参数或重新安排其顺序**。

* ```c++
  #include <iostream>
  #include <functional>
  using namespace std;
  class A
  {
  public:
      void fun_3(int k,int m)
      {
          cout<<"print: k="<<k<<",m="<<m<<endl;
      }
  };
  
  void fun_1(int x,int y,int z)
  {
      cout<<"print: x=" <<x<<",y="<< y << ",z=" <<z<<endl;
  }
  
  void fun_2(int &a,int &b)
  {
      a++;
      b++;
      cout<<"print: a=" <<a<<",b="<<b<<endl;
  }
  
  int main(int argc, char * argv[])
  {
      //f1的类型为 function<void(int, int, int)>
      auto f1 = std::bind(fun_1,1,2,3); //表示绑定函数 fun 的第一，二，三个参数值为： 1 2 3
      f1(); //print: x=1,y=2,z=3
  
      auto f2 = std::bind(fun_1, placeholders::_1,placeholders::_2,3);
      //表示绑定函数 fun 的第三个参数为 3，而fun 的第一，二个参数分别由调用 f2 的第一，二个参数指定
      f2(1,2);//print: x=1,y=2,z=3
   
      auto f3 = std::bind(fun_1,placeholders::_2,placeholders::_1,3);
      //表示绑定函数 fun 的第三个参数为 3，而fun 的第一，二个参数分别由调用 f3 的第二，一个参数指定
      //注意： f2  和  f3 的区别。
      f3(1,2);//print: x=2,y=1,z=3
  
      int m = 2;
      int n = 3;
      auto f4 = std::bind(fun_2, placeholders::_1, n); //表示绑定fun_2的第一个参数为n, fun_2的第二个参数由调用f4的第一个参数（_1）指定。
      f4(m); //print: m=3,n=4
      cout<<"m="<<m<<endl;//m=3  说明：bind对于不事先绑定的参数，通过std::placeholders传递的参数是通过引用传递的,如m
      cout<<"n="<<n<<endl;//n=3  说明：bind对于预先绑定的函数参数是通过值传递的，如n
      
      A a;
      //f5的类型为 function<void(int, int)>
      auto f5 = std::bind(&A::fun_3, a,placeholders::_1,placeholders::_2); //使用auto关键字
      f5(10,20);//调用a.fun_3(10,20),print: k=10,m=20
  
      std::function<void(int,int)> fc = std::bind(&A::fun_3, a,std::placeholders::_1,std::placeholders::_2);
      fc(10,20);   //调用a.fun_3(10,20) print: k=10,m=20 
      return 0; 
  }
  ```

* 绑定引用参数
  * **默认情况下，bind的那些不是占位符的参数被拷贝到bind返回的可调用对象中**。 但是，与lambda类似，有时对有些绑定的参数我们希望以引用方式传递，或是要绑定参数的类型无法拷贝。
  * **bind拷贝其参数。如果我们希望传递给bind 一个对象而又不拷贝它，就必须使用标准库 ref 函数**
  * **函数ref返回一个对象，包含给定的引用，此对象是可以拷贝的。**标准库中还有一个 cref 函数，生成一个保存 const 引用的类。与bind —样，函数ref和cref也定义在头文 件 functional中。

* 向后兼容：参数绑定

  * 旧版本C++提供的绑定函数参数的语言特性限制更多，也更复杂。标准库定义了两个分 别名为bindlst和bind2nd的函数。类似bind,这两个函数接受一个函数作为参数， 生成一个新的可调用对象，该对象调用给定函数，并将绑定的参数传递给它。但是，这 些函数分别只能绑定第一个或第二个参数。由于这些函数局限大强，在新标准中已被弃 用(deprecated)。所谓被弃用的特性就是在新版本中不再支持的特性。新的C++程序应 该使用bind。

  ```c++
  #include <iostream>
  #include <functional>
  using namespace std;
  class A
  {
  public:
      void fun_3(int k,int m)
      {
          cout<<"print: k="<<k<<",m="<<m<<endl;
      }
  };
  
  void fun_1(int x,int y,int z)
  {
      cout<<"print: x=" <<x<<",y="<< y << ",z=" <<z<<endl;
  }
  
  void fun_2(int &a,int &b)
  {
      a++;
      b++;
      cout<<"print: a=" <<a<<",b="<<b<<endl;
  }
  
  int main(int argc, char * argv[])
  {
      //f1的类型为 function<void(int, int, int)>
      auto f1 = std::bind(fun_1,1,2,3); //表示绑定函数 fun 的第一，二，三个参数值为： 1 2 3
      f1(); //print: x=1,y=2,z=3
  
      auto f2 = std::bind(fun_1, placeholders::_1,placeholders::_2,3);
      //表示绑定函数 fun 的第三个参数为 3，而fun 的第一，二个参数分别由调用 f2 的第一，二个参数指定
      f2(1,2);//print: x=1,y=2,z=3
   
      auto f3 = std::bind(fun_1,placeholders::_2,placeholders::_1,3);
      //表示绑定函数 fun 的第三个参数为 3，而fun 的第一，二个参数分别由调用 f3 的第二，一个参数指定
      //注意： f2  和  f3 的区别。
      f3(1,2);//print: x=2,y=1,z=3
  
      int m = 2;
      int n = 3;
      auto f4 = std::bind(fun_2, placeholders::_1, n); //表示绑定fun_2的第一个参数为n, fun_2的第二个参数由调用f4的第一个参数（_1）指定。
      f4(m); //print: m=3,n=4
      cout<<"m="<<m<<endl;//m=3  说明：bind对于不事先绑定的参数，通过std::placeholders传递的参数是通过引用传递的,如m
      cout<<"n="<<n<<endl;//n=3  说明：bind对于预先绑定的函数参数是通过值传递的，如n
      
      A a;
      //f5的类型为 function<void(int, int)>
      auto f5 = std::bind(&A::fun_3, a,placeholders::_1,placeholders::_2); //使用auto关键字
      f5(10,20);//调用a.fun_3(10,20),print: k=10,m=20
  
      std::function<void(int,int)> fc = std::bind(&A::fun_3, a,std::placeholders::_1,std::placeholders::_2);
      fc(10,20);   //调用a.fun_3(10,20) print: k=10,m=20 
      return 0; 
  }
  ```

#### 再探迭代器

* 除了为每个容器定义的迭代器之外，标准库在头文件iterator中还定义了额外几 种迭代器。这些迭代器包括以下几种：
  * **插入迭代器(insert iterator)**：这些迭代器被绑定到一个容器上，可用来向容器插入 元素。
  * **流迭代器(stream iterator)**：这些迭代器被绑定到输入或输出流上，可用来遍历所 关联的IO流。
  * **反向迭代器(reverse iterator )**:这些迭代器向后而不是向前移动。除了 forward_list之外的标准库容器都有反向迭代器。
  * **移动迭代器(move iterator)**：这些专用的迭代器不是拷贝其中的元素，而是移动它们。

##### 插入迭代器

* **插入器是一种迭代器适配器，它接受一个容器，生成一个迭代器，能实现向给定容器添加元素**。当我们通过一个插入迭代器进行赋值时，该迭代器调 用容器操作来向给定容器的指定位置插入一个元素。

* 插入器有三种类型，差异在于元素插入的位置：
  * back_inserter 创建一个使用 push_back 的迭代器。
  * front_inserter创建一个使用 push_f_front的迭代器。
  *  inserter 创建一个使用insert的迭代器。此函数接受第二个参数，这个参数必须是一个指向给定容器的迭代器。元素将被插入到给定迭代器所表示的元素之前。
* **只有在容器支持push_front的情况下，我们才可以使用front_inserter ; 类似的，只有在容器支持push_back的情况下，我们才能使用 back_inserter**
* 当调用 front_inserter(c) 时，我们得到一个插入迭代器，接下来会调用 push_fronto当每个元素被插入到容器c中时，它变为c的新的首元素。因此， **front_inserter生成的迭代器会将插入的元素序列的顺序颠倒过来，而inserter和 back_inserter 则不会**。

```c++
list<string> names = {"a", "aa", "aaa", "aaaa", "aaaaa"};
list<string> chars1, chars2;
copy(names.cbegin(), names.cend(), front_inserter(chars1));
copy(names.cbegin(), names.cend(), inserter(chars2, chars2.begin()));
for_each(names.cbegin(), names.cend(), [](const string&s) {cout << s << '\t';}); cout << endl;
for_each(chars1.cbegin(), chars1.cend(), [](const string&s) {cout << s << '\t';}); cout << endl;
for_each(chars2.cbegin(), chars2.cend(), [](const string&s) {cout << s << '\t';}); cout << endl;
```

#####  iostream 迭代器

* 虽然iostream类型不是容器，但标准库定义了可以用于这些 IO 类型对象的迭代器。istream_iterator 读取输入流， ostream_iterator 向一个输出流写数据。这些**迭代器将它们对应的流当作一个特定类型的元素序列来处理**。通过使用流迭代器，我们可以用泛型算法从流对象读取数据以及向其写入数据。

* istream_iterator 操作

  * **当创建一个流迭代器时，必须指定迭代器将要读写的对象类型**。一个 istream_iterator 使用 >> 来读取流。因此，**istream_iterator要读取的类型必须定义了输入运算符**。当创建一个 istream_iterator 时，我们可以将它绑定到一个流。 当然，我们还可以**默认初始化迭代器，这样就创建了一个可以当作尾后值使用的迭代器**。
  * **对于一个绑定到流的迭代器，一旦其关联的流遇到文件尾或遇到IO错误，迭代器的值就与尾后迭代器相等。**

  ```c++
  vector<int> nums;
  istream_iterator<int> intit(cin), eof;
  while (intit != eof)
      nums.push_back(*intit++);
  for (int i = 0; i < nums.size(); ++i) {
      cout << nums[i] << '\t';
  }
  // ------
  ifstream ifs("1.log");
  istream_iterator<string> strit(ifs), eof;
  vector<string> lines(strit, eof);
  for_each(lines.begin(), lines.end(), [](const string& s) { cout << s << endl;});
  ```

* 使用算法操作流迭代器

  * **由于算法使用迭代器操作来处理数据，而流迭代器又至少支持某些迭代器操作，因此 我们至少可以用某些算法来操作流迭代器。**
  * istream_iterator允许使用懒惰求值
    * 当我们将一个istream_iterator绑定到一个流时，标准库并不保证迭代器立即从流读取数据。具体实现可以推迟从流中读取数据，直到我们使用迭代器时才真正读取。**标准库中的实现所保证的是，在我们第一次解引用迭代器之前，从流中读取数据的操作已经完成了**。对于大多数程序来说，立即读取还是推迟读取没什么差别。但是，如果我们创建 了一个istream_iterator,没有使用就销毁了,或者我们正在从两个不同的对象同步读取同一个流，那么何时读取可能就很重要了

* ostream_iterator操作

  * 我们可以对任何具有输出运算符（ << 运算符）的类型定义ostream_iterator。当创建一个ostream_iterator时，我们可以提供（可选的）第二参数，它是一个字符串， 在输出每个元素后都会打印此字符串。此字符串必须是一个C风格字符串（即，一个字符串字面常量或者一个指向以空字符结尾的字符数组的指针）。必须将ostream_iterator绑定到一个指定的流，不允许空的或表示尾后位置的ostream_iterator

    ```c++
    vector<int> nums = {1,3,5,7,9};
    ostream_iterator<int> oi(cout , " ");
    for(auto i: nums) *oi++ = i; // 1 3 5 7 9
    ```

  * **运算符*和++实际上对ostream_iterator对象不做任何事情，因此忽略它们对我们的 程序没有任何影响**。但是，推荐上述形式。在这种写法中，流迭代器的使用与其他迭代 器的使用保持一致。如果想将此循环改为操作其他迭代器类型，修改起来非常容易。而且，对于读者来说，此循环的行为也更为清晰。

    ```c++
    copy(nums.cbegin(), nums.cend(), oi);
    // 可以通过调用copy来打印vec中的元素，这比编写循环更为简单
    ```

* 使用流迭代器处理类类型

  * **我们可以为任何定义了输入运算符（>>）的类型创建 istream_iterator 对象。类似的，只要类型有输出运算符（<<），我们就可以为其定义ostream_iterator**

##### 反向迭代器

* **反向迭代器就是在容器中从尾元素向首元素反向移动的迭代器。对于反向迭代器，递 增（以及递减）操作的含义会颠倒过来**。递增一个反向迭代器（++it）会移动到前一个元素；递减一个迭代器（--it）会移动到下一个元素。

* **虽然颠倒递增和递减运算符的含义可能看起来令人混淆，但这样做使我们可以用算法透明地向前或向后处理容器**。例如，可以通过向sort传递一对反向迭代器来将vector 整理为递减序

* 反向迭代器

* 递减运算符

  * 不必惊讶，**我们只能从既支++也支持--的迭代器来定义反向迭代器**。毕竟**反向迭代器的目的是在序列中反向移动**。除了 forward_list之外，标准容器上的其他迭代器都既支持递增运算又支持递减运算。但是，流迭代器不支持递减运算，因为不可能在一个流中反向移动。因此，不可能从一个forward_list或一个流迭代器创建反向迭代器。

* 反向迭代器和其他迭代器间的关系

  * 通过调用reverse_iterator的 base成员函数转换，此成员函数会返回其对应的普通迭代器
  * 从技术上讲，**普通迭代器与反向迭代器的关系反映了左闭合区间的特性**。关键点在于**`［container.crbegin (), rit)`和`［rit.base (), container.cend() )`指向line中相同的元素范围**。为了实现这一点，rit 和 rit.base ()必须生成相邻位置而不是相同位置，crbegin ()和cend ()也是如此。
  * $rit = rit.base() - 1; container.rbegin() = container.cend() -1;$ 

* 反向迭代器的目的是表示元素范围，而这些范围是不对称的，这导致一个重要 的结果：当我们从一个普通迭代器初始化一个反向迭代器，或是给一个反向迭 代器赋值时，结果迭代器与原迭代器指向的并不是相同的元素

  ```c++
  string line = "jack,tom,zhangsan, wangwu, jordorn";
  cout << "first Nmae: " << string(line.cbegin(), find(line.cbegin(), line.cend(), ',')) << endl;     // first Nmae: jack
  cout << "last Name: " << string(line.crbegin(), find(line.crbegin(), line.crend(), ',')) << endl;   // last Name: nrodroj
  cout << "last Name: " << string(find(line.crbegin(), line.crend(), ',').base(), line.cend()) << endl;   // last Name: jordorn
  ```

#### 泛型算法结构

* **任何算法的最基本的特性是它要求其迭代器提供哪些操作**。某些算法，如find,只要求通过迭代器访问元素、递增迭代器以及比较两个迭代器是否相等这些能力。其他一些 算法，如sort,还要求读、写和随机访问元素的能力。算法所要求的迭代器操作可以分为5个**迭代器类别(iterator category)**。每个算法都会对它的每个迭代器参数指明须提供哪类迭代器。

* | 迭代器类别     | 描述                                 |
  | -------------- | ------------------------------------ |
  | 输出迭代器     | 只写，不读；单遍扫描，只能递增       |
  | 前向迭代器     | 可读写；多遍扫描，只能递增           |
  | 双向迭代器     | 可读写；多遍扫描，可递增递减         |
  | 随机访问迭代器 | 可读写，多遍扫描，支持全部迭代器运算 |
  | 输入迭代器     | 只读，不写；单遍扫描，只能递增       |

* 第二种算法分类的方式是按照是否读、写或是重排序列中的元素来分类。
* 算法还共享一组**参数传递规范**和一组**命名规范**，我们在介绍迭代器类别之后将介绍这些内容。

##### 类迭代器

* 类似容器，迭代器也定义了一组公共操作。一些操作所有迭代器都支持，另外一些只 有特定类别的迭代器才支持。

* **迭代器是按它们所提供的操作来分类的，而这种分类形成了一种层次**。除了输出迭代器之外，一个高层类别的迭代器支持低层类别迭代器的所有操作。
* **C++标准指明了泛型和数值算法的每个迭代器参数的最小类别**。例如，find算法在一个序列上进行一遍扫描，对元素进行只读操作，因此至少需要输入迭代器。replace 函数需要一对迭代器，至少是前向迭代器。类似的，replace_copy 的前两个迭代器参数也要求至少是前向迭代器。其第三个迭代器表示目的位置，必须至少是输出迭代器。其他的例子类似。对每个迭代器参数来说，其能力必须与规定的最小类别至少相当。**向算法传递一个能力更差的迭代器会产生错误**。
* 对于向一个算法传递错误类别的迭代器的问题，很多编译器不会给出任何警告 或提示

###### 迭代器类别

* **输入迭代器（input iterator）**：可以读取序列中的元素。一个输入迭代器必须支持
  * 用于**比较两个迭代器**的相等和不相等运算符（==、!=）
  * 用于**推进迭代器**的前置和后置递增运算（++）
  * 用于**读取元素的解引用运算符**（\*）；**解引用只会出现在赋值运算符的右侧\***
  * 箭头运算符（-＞）,等价于 (\*)it.member, 即，解引用迭代器，并提取对象的成员
  * 输入迭代器只用于顺序访问。对于一个输入迭代器，*it++保证是有效的，但递增它可能导致所有其他指向流的迭代器失效。其结果就是，不能保证输入迭代器的状态可以保存下来并用来访问元素。因此**，输入迭代器只能用于单遍扫描算法**。算法find和accumulate 要求输入迭代器；而istream_iterator是一种输入迭代器。
* **输出迭代器（output iterator）**：可以看作输入迭代器功能上的补集——只写而不读元素。输 出迭代器必须支持
  * 用于**推进迭代器**的前置和后置递增运算（++）
  * **解引用运算符**（\*）,**只出现在赋值运算符的左侧**（向一个已经解引用的输出迭代器赋值，就是将值写入它所指向的元素）
  * 我们**只能向一个输出迭代器赋值一次**。类似输入迭代器，**输出迭代器只能用于单遍扫描算法**。**用作目的位置的迭代器通常都是输出迭代器**。例如，copy函数的第三个参数就是输出迭代器。ostream_iterator类型也是输出迭代器。
* **前向迭代器（forward iterator）**：可以读写元素。这类迭代器**只能在序列中沿一个方向移动**。 前向迭代器支持所有输入和输出迭代器的操作，而且**可以多次读写同一个元素**。因此，我们可以保存前向迭代器的状态，使用前向迭代器的算法**可以对序列进行多遍扫描**。算法 replace 要求前向迭代器，forward_list ±的迭代器是前向迭代器。
* **双向迭代器（bidirectional iterator）**：可以正向/反向读写序列中的元素。除了支持所有前向迭代器的操作之外，双向迭代器还支持前置和后置递减运算符。算法reverse要求双向迭代器，除了 forward_list之外，其他标准库都提供符合双向迭代器要求的迭代器。

* **随机访问迭代器（random-access iterator）**：提供在常量时间内访问序列中任意元素的能力。 此类迭代器支持双向迭代器的所有功能，此外还的操作：
  * 用于**比较两个迭代器相对位置**的关系运算符（＜、＜=、＞和＞=）
  * **迭代器和一个整数值的加减运算**（+、+=、-和=）,计算结果是迭代器在序列中前 进（或后退）给定整数个元素后的位置
  * 用于**两个迭代器上的减法运算符**（-）,得到两个迭代器的距离
  * **下标运算符**（iter [n]）, 与 \* (iter[n])等价
  * 算法sort要求随机访问迭代器。array、deque、string和vector的迭代器都是随 机访问迭代器，用于访问内置数组元素的指针也是。

* C++输入迭代器为何只能用于单边扫描

  ```c++
  std::istream_iterator<int> a(std::cin); // 定义一个bai istream_iterator 对象，名叫 a
  std::istream_iterator<int> b = a; // b 是 a 的一个副本
  int x = *a;
  ++a;
  int y = *a;
  ```

  * 如果输入 1 2 3，那么 x 的值是第一个数 1，y 的值是第二个数 2
    但如果在 ++a 前面加一句 ++b，那么虽然 ++b 不会改变 a 的值，却会导致 y 的值变成第三个数 3 ，所以说递增一个 istream_iterator 可能会导致其他的迭代器以奇怪的方式变化。因此虽然可以创建 istream_iterator 的副本，但必须保证只对一个迭代器做递增操作，并且递增之后不能访问另一个副本的值（另一个副本可能具有奇异的值）

###### 算法形参模式

* 在任何其他算法分类之上，还有一组**参数规范**。理解这些参数规范对学习新算法很有 帮助——通过理解参数的含义，你可以将注意力集中在算法所做的操作上。大多数算法具有如下4种形式之一：
  * `alg(beg, end, other args)`
  * `alg(beg, end, dest, other args)`
  * `alg(beg, end, beg2, other args)`
  * `alg(beg, end, beg2, end2, other args)`
  * 其中**alg是算法的名字**，**beg和end表示算法所操作的输入范围**。几乎所有算法都接受一 个输入范围，**是否有其他参数依赖于要执行的操作**。这里列出了常见的一种. **dest、 beg2和end2,都是迭代器参数。顾名思义，如果用到了这些迭代器参数，它们分别承担指定目的位置和第二个范围的角色**。除了这些迭代器参数，**一些算法还接受额外的、非迭代器的特定参数**。
* 接受单个目标迭代器的算法
  * dest参数是一个表示算法可以写入的目的位置的迭代器。算法假定（assume）：按其需要写入数据，不管写入多少个元素都是安全的。
  * **向输出迭代器写入数据的算法都假定目标空间足够容纳写入的数据.**
  * 如果dest是一个直接指向容器的迭代器，那么算法将输出数据写到容器中已存在的元素内。**更常见的情况是，dest被绑定到一个插入迭代器 或是一个ostream_iterator **。插入迭代器会将新元素添加 到容器中，因而保证空间是足够的。ostream_iterator会将数据写入到一个输出流， 同样不管要写入多少个元素都没有问题。
* 接受第二个输入序列的算法
  * 接受单独的beg2或是接受beg2和end2的算法用这些迭代器表示第二个输入范围。 这些算法通常使用第二个范围中的元素与第一个输入范围结合来进行一些运算。
  * 如果一个算法接受beg2和end2,这两个迭代器表示第二个范围。这类算法接受两 个完整指定的范围：［beg, end）表示的范围和［beg2, end2）表示的第二个范围。
  * **只接受单独的beg2（不接受end2）的算法将beg2作为第二个输入范围中的首元素。 此范围的结束位置未指定，这些算法假定从beg2开始的范围与beg和end所表示的范围至少一样大。**

##### 算法命名规范

* 除了参数规范，算法还遵循一套**命名和重载规范**。这些规范处理诸如：如何提供一个操作代替默认的 ＜或 == 运算符以及算法是将输出数据写入输入序列还是一个分离的目的位置等问题。
* 一些算法使用重载形式传递一个谓词
  * **接受谓词参数来代替＜或 == 运算符的算法，以及那些不接受额外参数的算法，通常都是重载的函数**。函数的一个版本用元素类型的运算符来比较元素；另一个版本接受一个额外谓词参数，来代替＜或 ==
* _if 版本的算法_
  * **接受一个元素值的算法通常有另一个不同名的（不是重载的）版本，该版本接受一个谓词代替元素值**。接受谓词参数的算法都有附加的\_if前缀
  * 这两个算法**提供了命名上差异的版本，而非重载版本**，因为两个版本的算法都接受相同数目的参数。因此可能产生重载歧义，虽然很罕见，但为了避免任何可能的歧义，标准库选择提供不同名字的版本而不是重载。

* **区分拷贝元素的版本和不拷贝的版本**
  * 默认情况下，重排元素的算法将重排后的元素写冋给定的输入序列中。这些算法还提供另一个版本，将元素写到一个指定的输出目的位置。如我们所见，写到额外目的空间的算法都在名字后面附加一个\_copy 
* **—些算法同时提供_copy和_if版本。这些版本接受一个目的位置迭代器和一个谓词**

#### 特定容器算法

* 与其他容器不同，链表类型list和forward_list定义了几个成员函数形式的算法。特别是，它们定义了独有的sort、merge, remove, reverse和 unique. **通用版本的sort要求随机访问迭代器，因此不能用于list和forward_list. 因为这两个类型分别提供双向迭代器和前向迭代器。**
* 链表类型定义的其他算法的通用版本可以用于链表，但代价太高。这些算法需要交换输入序列中的元素。一个链表可以通过改变元素间的链接而不是真的交换它们的值来快速  “交换” 元素。
* **对于list和forward_list,应该优先使用成员函数版本的算法而不是通用算法。**
* splice 成员
  * 链表类型还定义了 splice算法，其描述见表10.7。此算法是链表数据结构所特有的, 因此不需要通用版本。

* **链表特有的操作会改变容器**
  * 多数链表特有的算法都与其通用版本很相似，但不完全相同。**链表特有版本与通用版本间的一个至关重要的区别是链表版本会改变底层的容器**。例如，remove的链表版本会删除指定的元素。unique的链表版本会删除第二个和后继的重复元素。
  * 类似的，merge和splice会销毁其参数。例如，通用版本的merge将合并的序列写到一个给定的目的迭代器；两个输入序列是不变的。而链表版本的merge函数会销毁给定的链表——元素从参数指定的链表中删除，被合并到调用merge的链表对象中。在 merge之后，来自两个链表中的元素仍然存在，但它们都已在同一个链表中。

#### 小节

* 标准库定义了大约100个类型无关的对序列进行操作的算法。**序列可以是标准库容器类型中的元素、一个内置数组或者是(例如)通过读写一个流来生成的。算法通过在迭代 器上进行操作来实现类型无关。**
* 多数算法接受的前两个参数是一对迭代器，表示一个元素范围。额外的迭代器参数可能包括一个表示目的位置的输出迭代器，或是表示第二个输入范围的另一个或另一对迭代器。
* 根据支持的操作不同，迭代器可分为五类：输入、输出、前向、双向以及随机访问迭代器。**如果一个迭代器支持某个迭代器类别所要求的操作，则属于该类别。**
* 如同迭代器根据操作分类一样，**传递给算法的迭代器参数也按照所要求的操作进行分类**。仅读取序列的算法只要求输入迭代器操作。写入数据到目的位置迭代器的算法只要求 输出迭代器操作，依此类推。
* **算法从不直接改变它们所操作的序列的大小**。它们会将元素从一个位置拷贝到另一个位置，但不会直接添加或删除元素。
* 虽然算法不能向序列添加元素，但插入迭代器可以做到。一个插入迭代器被绑定到一 个容器上。当我们将一个容器元素类型的值赋予一个插入迭代器时，迭代器会将该值添加到容器中。
* 容器forward_list和list对一些通用算法定义了自己特有的版本。与通用算法不同，这些**链表特有版本会修改给定的链表**。