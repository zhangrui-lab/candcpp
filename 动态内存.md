* 到目前为止，我们编写的程序中所使用的**对象都有着严格定义的生存期**。全局对象在程序启动时分配，在程序结束时销毁。对于局部自动对象，当我们进入其定义所在的程序块时被创建，在离开块时销毁。局部static对象在第一次使用前分配，在程序结束时销毁。
* 除了自动和static对象外，C++还支持动态分配对象。**动态分配的对象的生存期与它们在哪里创建是无关的，只有当显式地被释放时，这些对象才会销毁。**
* 动态对象的正确释放被证明是编程中极其容易出错的地方。为了更安全地使用动态对 象，标准库定义了两个智能指针类型来管理动态分配的对象。当一个对象应该被释放时， 指向它的智能指针可以确保自动地释放它。
* **静态内存用来保存局部static对象、类static数据成员以及定义在任何函数之外的变量。栈内存用来保存定义在函数内的非static对象。分配在静态或栈内存中的对象由编译器自动创建和销毁**。对于栈对象，仅在其定义的程序块运行时才存在；static对象在使用之前分配，在程序结束时销毁。
* 除了静态内存和栈内存，每个程序还拥有一个内存池。这部分内存被称作**自由空间 （free store）或堆（heap）**。程序用堆来存储动态分配（dynamically allocate）的对象	即，那些在程序运行时分配的对象。动态对象的生存期由程序来控制，也就是说，当动态对象 不再使用时，我们的代码必须显式地销毁它们。
* 虽然使用动态内存有时是必要的，但众所周知，正确地管理动态内存是非常棘手的

#### 动态内存与智能指针

* 在C++中，**动态内存的管理是通过一对运算符来完成的**：new,在动态内存中为对象 分配空间并返回一个指向该对象的指针，我们可以选择对对象进行初始化；delete,接 受一个动态对象的指针，销毁该对象，并释放与之关联的内存。
* 动态内存的使用很容易出问题，因为确保在正确的时间释放内存是极其困难的。**有时我们会忘记释放内存，在这种情况下就会产生内存泄漏**；有时**在尚有指针引用内存的情况 下我们就释放了它，在这种情况下就会产生引用非法内存的指针**。
* 为了更容易（同时也更安全）地使用动态内存，新的标准库提供了两种**智能指针（smart pointer）**类型来管理动态对象。智能指针的行为类似常规指针，重要的区别是它负责自动释放所指向的对象。新标准库提供的这两种智能指针的区别在于管理底层指针的方式： shared_ptr允许多个指针指向同一个对象；unique_ptr则"独占”所指向的对象。 标准库还定义了一个名为weak_ptx的伴随类，它是一种弱引用，指向 shared_ptr 所 管理的对象。这三种类型都定义在memory 头文件中。

##### shared_ptr 类

* 智能指针也是模板。因此，当我们创建一个智能指针时，必须提供额外的信息一一**指针可以指向的类型**。我们在尖 括号内给出类型，之后是所定义的这种智能指针的名字

* **默认初始化的智能指针中保存着一个空指针**

* 智能指针的使用方式与普通指针类似。解引用一个智能指针返回它指向的对象。如果 在一个条件判断中使用智能指针，效果就是检测它是否为空

* make_shared 函数

  * 最安全的分配和使用动态内存的方法是调用一个名为make_shared的标准库函数。 此函数**在动态内存中分配一个对象并初始化它，返回指向此对象的 shared_ptr**。与智能 指针一样，make_shared也定义在头文件memory中。
  * 当要用make_shared时，必须**指定想要创建的对象的类型**。定义方式与模板类相同
  * 类似顺序容器的emplace成员，make_shared用其参数来 构造给定类型的对象。例如，调用make_shared\<string\>时传递的参数必须与string 的某个构造函数相匹配，调用make_shared\<int\>时传递的参数必须能用来初始化一个 int,依此类推。如果我们不传递任何参数，对象就会进行值初始化。
  * 当然，我们通常用 auto 定义一个对象来保存make_shared 的结果，这种方式较为简单

* shared_ptr的拷贝和赋值

  * 当进行拷贝或赋值操作时，**每个 shared_ptr 都会记录有多少个其他shared_ptr 指向相同的对象**

  * 我们可以认为**每个shared_ptr都有一个关联的计数器，通常称其为引用计数(reference count) **。无论何时我们**拷贝一个shared_ptr，计数器都会递增**。例如，当用一个 shared_ptr初始化另一个shared_ptr,或将它作为参数传递给一个函数以及作为函数的返回值时，它所关联的计数器就会递増。当我们**给shared_ptr赋予一个新值或是shared_ptr被销毁(例如一个局部的shared_ptr离开其作用域时)，计数器就会递减。**

  * **—旦一个shared_ptr的计数器变为0,它就会自动释放自己所管理的对象**

    ```
    auto r = make_shared<int> (42) ; / / r 指向的 int 只有一个引用者
    r = q; 	//给r赋值，令它指向另一个地址
            //递增q指向的对象的引用计数
            //递减r原来指向的对象的引用计数
            // r原来指向的对象已没有引用者，会自动释放
    ```

* 到底是用一个计数器还是其他数据结构来记录有多少指针共享对象，完全由标 准库的具体实现来决定。**关键是智能指针类能记录有多少个shared_ptr指向相同的对象，并能在恰当的时候自动释放对象**

* shared_ptr自动销毁所管理的对象

  * **当指向一个对象的最后一个shared_ptr 被销毁时，shared_ptr 类会自动销毁此对象**。它是通过另一个特殊的成员函数一析构函数(destructor)完成销毁工作的。类似于构造函数，每个类都有一个析构函数。就像构造函数控制初始化一样，析构函数控制此类型的对象销毁时做什么操作。
  * **析构函数一般用来释放对象所分配的资源**。例如，String的构造函数(以及其他string成员)会分配内存来保存构成string的字符。string的析构函数就负责释放 这些内存。类似的，vector的若干操作都会分配内存来保存其元素。vector的析构函数就负责销毁这些元素，并释放它们所占用的内存。
  * **shared_ptr的析构函数会递减它所指向的对象的引用计数。如果引用计数变为0, shared_ptr的析构函数就会销毁对象，并释放它占用的内存**。

* shared_ptr还会自动释放相关联的内存

  * 当动态对象不再被使用时，shared_ptr 类会自动释放动态对象，这一特性使得动态内存的使用变得非常容易。

    ```c++
    template<typename T>
    void useFactory(T arg) {
        shared_ptr<T> p = new T;
        return p;
    }
    /*在此版本中，useFactory中的return语句向此函数的调用者返回一个p的拷贝。拷 贝一个shared_ptr会增加所管理对象的引用计数值。现在当p被销毁时，它所指向的 内存还有其他使用者。对于一块内存，shared_ptr类保证只要有任何shared_ptr对 象引用它，它就不会被释放掉。*/
    ```

  * **由于在最后一个shared_ptr销毁前内存都不会释放，保证shared_ptr在无用之后不再保留就非常重要了**。如果你忘记了销毁程序不再需要的shared_ptr,程序仍会正确执行，但会浪费内存。share_ptr在无用之后仍然保留的一种可能情况是，你将 shared_ptr 存放在一个容器中，随后重排了容器，从而不再需要某些元素。在这种情况 下，你应该确保用erase删除那些不再需要的shared_ptr元素。

* **如果你将shared_ptr存放于一个容器中，而后不再需要全部元素，而只使 用其中一部分，要记得用 erase 删除不再需要的那些元素.**

* 使用了动态生存期的资源的类； 程序使用动态内存出于以下三种原因之一:

  1. **程序不知道自己需要使用多少对象**
  2. **程序不知道所需对象的准确类型**
  3.  **程序需要在多个对象间共享数据**

* **由一个vector分配的元素只有当这个vector存在时才存在。当一个vector被销毁时，这个vector中的元素也都被销毁。**

* **但某些类分配的资源具有与原对象相独立的生存期**。例如，假定我们希望定义一个名 为 Blob 的类，保存一组元素。与容器不同，我们希望 Blob 对象的不同拷贝之间共享相同的元素。即，当我们拷贝一个Blob时，原Blob对象及其拷贝应该引用相同的底层元素。

* 一般而言，**如果两个对象共享底层的数据，当某个对象被销毁时，我们不能单方面地 销毁底层数据**

* **使用动态内存的一个常见原因是允许多个对象共享相同的状态。**

##### 直接管理内存

* C++语言定义了两个运算符来分配和释放动态内存。运算符new分配内存，delete 释放 new 分配的内存。

* 相对于智能指针，使用这两个运算符管理内存非常容易出错。而且，自己直接管理内存的类与使用智能指针的类不同，它们不能依赖类对象拷贝、赋值和销毁操作的任何默认定义。因此，使用智能指针的程序更容易编写和调试。

* **除非使用智能指针来管理内存，否则不要分配动态内存**

* 使用new动态分配和初始化对象

  * **在自由空间分配的内存是无名的，因此new无法为其分配的对象命名，而是返回一个指向该对象的指针**
  * 默认情况下，**动态分配的对象是默认初始化的**，这意味着**内置类型或组合类型的对象的值将是未定义的**，而**类类型对象将用默认构造函数进行初始化**
  * 对定义了自己的构造函数的类类型（例如string）来说， 要求值初始化是没有意义的：不管釆用什么形式，对象都会通过默认构造函数来初始化。 但对于内置类型，两种形式的差别就很大了；值初始化的内置类型对象有着良好定义的值, 而默认初始化的对象的值则是未定义的。类似的，对于类中那些依赖于编译器合成的默认构造函数的内置类型成员，如果它们未在类内被初始化，那么它们的值也是未定义的
  * **出于与变量初始化相同的原因，对动态分配的对象进行初始化通常是个好主意。**

* **如果我们提供了一个括号包围的初始化器，就可以使用auto. 从此初始化器来推断我们想要分配的对象的类型。但是，由于编译器要用初始化器的类型来推断要分配的类型，只有当括号中仅有单一初始化器时才可以使用auto**

  ```
      auto ptr1 = new auto(10);
      auto ptr2 = new auto({1,2,2.01});// error
  ```

* 动态分配的const对象

  * 用new分配const对象是合法的
  * **类似其他任何const对象，一个动态分配的const对象必须进行初始化**。对于一个定义了默认构造函数的类类型，其const动态对象可以隐式初始 化，而其他类型的对象就必须显式初始化。由于分配的对象是const的，new返回的指 针是一个指向const的指针

* 内存耗尽

  * 虽然现代计算机通常都配备大容量内存，但是自由空间被耗尽的情况还是有可能发 生。一旦一个程序用光了它所有可用的内存，new表达式就会失败。默认情况下，如果 new不能分配所要求的内存空间，它会抛出一个类型为bad_alloc的异常。我们可以改变使用new的方式来阻止它抛岀异常

    ```
        int *pInt1 = new int;
        int *pInt2 = new(nothrow) int; // 如果分配失败，new返回一个空指针
    ```

  * 我们称这种形式的new为**定位new（placement new）**。定位new表达式允许我们向new传递额外的参数。在此例中，我们传递给它一个由标准库定义的名为nothrow的对象。如果将nothrow传递给new,我们的意图是告诉它不能抛出异常。如果这种形式的new不能分配所需内存，它会返回一个空指+针。bad_alloc和nothrow都定义在头文件new中。

* 释放动态内存

  * 为了防止内存耗尽**，在动态内存使用完毕后，必须将其归还给系统**。我们通过delete表达式（delete expression）来将动态内存归还给系统。delete表达式接受一个指针，指 向我们想要释放的对象：`delete p; // p必须指向一个动态分配的对象或是一个空指针`。 与new类型类似，**delete表达式也执行两个动作：销毁给定的指针指向的对象；释放对应的内存。**

* 指针值和delete
  * **我们传递给delete的指针必须指向动态分配的内存，或者是一个空指针。释放一块并非new分配的内存，或者将相同的指针值释放多次，其行为是未定义的**
* **虽然一个const对象的值不能被改变，但它本身是可以被销毁的。如同任何其他动态对象一样，想要释放一个const动态对象，只要delete指向它的指针即可**：`const int *pci = new const int (1024); delete pci; //正确：释放一个const对象`
* **动态对象的生存期直到被释放时为止**
  * 由shared_ptr管理的内存在最后一个shared_ptr 销毁时会被自动释放。但对于通过内置指针类型来管理的内存，就不是这样了。对这个由内置指针管理的动态对象，直到被显式释放之前它都是存在的。
  * 返回指向动态内存的指针（而不是智能指针）的函数给其调用者增加了一个额外负担—— **调用者必须记得释放内存。 不幸的是，调用者经常忘记释放对象**
* **与类类型不同，内置类型的对象被销毁时什么也不会发生**。特别是，当一个指针离开其作用域时，它所指向的对象什么也不会发生。如果这个指针指向的是动态内存，那么内存将不会被自动释放。
* **由内置指针(而不是智能指针)管理的动态内存在被显式释放前一直都会存在。**
* 使用new和delete管理动态内存存在三个常见问题
  * **忘记delete内存**。忘记释放动态内存会导致人们常说的“内存泄漏”问题， 因为这种内存永远不可能被归还给自由空间了。查找内存泄露错误是非常困难的，因为 通常应用程序运行很长时间后，真正耗尽内存时，才能检测到这种错误。
  * **使用已经释放掉的对象**。通过在释放内存后将指针置为空，有时可以检测出这种错误。
  * **同一块内存释放两次**。当有两个指针指向相同的动态分配对象时，可能发生这种错误。如果对其中一个指针进行了 delete操作，对象的内存就被归还给自由空间了。 如果我们随后又delete第二个指针，自由空间就可能被破坏。 相对于查找和修正这些错误来说，制造出这些错误要简单得多。

* delete之后重置指针值

  * 当我们delete一个指针后，指针值就变为无效了。虽然指针已经无效，但在很多机 器上指针仍然保存着（已经释放了的）动态内存的地址。在delete之后，指针就变成了 人们所说的**空悬指针（dangling pointer）**,即，**指向一块曾经保存数据对象但现在己经无效的内存的指针**。
  * **未初始化指针的所有缺点空悬指针也都有**。有一种方法可以避免空悬指针的问题：**在指针即将要离开其作用域之前释放掉它所关联的内存**。这样， 在指针关联的内存被释放掉之后，就没有机会继续使用指针了。**如果我们需要保留指针， 可以在delete之后将nullptr赋予指针，这样就清楚地指出指针不指向任何对象**。

* 这只是提供了有限的保护

  * **动态内存的一个基本问题是可能有多个指针指向相同的内存。在delete内存之后重置指针的方法只对这个指针有效,对其他任何仍指向（已释放的）内存的指针是没有作用**

    ```
        int *p = new int(42);
        int *q = p;
        delete p;
        p = nullptr;
        // 本例中p和q指向相同的动态分配的对象。我们delete此内存，然后将p置为nullptr, 指出它不再指向任何对象。但是，重置p对q没有任何作用，在我们释放p所指向的（同 时也是q所指向的！）内存时，q也变为无效了。在实际系统中，查找指向相同内存的所 有指针是异常困难的。
    ```

* shared_ptr 和 new 结合使用

  * 如果我们不初始化一个智能指针，它就会被初始化为一个空指针。我们还可以**用new返回的指针来初始化智能指针**
  * 接受指针参数的智能指针构造函数是explicit的。因此， 我们**不能将一个内置指针隐式转换为一个智能指针，必须使用直接初始化形式来初始化一个智能指针**
  * 出于相同的原因，一个返回 shared_ptr 的函数不能在其返回语句中隐式转换一个普通指针。我们**必须将shared_pt显式绑定到一个想要返回的指针上**

* 默认情况下，**一个用来初始化智能指针的普通指针必须指向动态内存，因为智能指针默认使用delete释放它所关联的对象。我们可以将智能指针绑定到一个指向其他类型的资源的指针上，但是为了这样做，必须提供自己的操作来替代delete， 定义自己的释放操作。**

* 不要混合使用普通指针和智能指针

  * **shared_ptr 可以协调对象的析构，但这仅限于其自身的拷贝(也是shared_ptr) 之间**。这也是什么我们推荐使用 make_shared 而不是 new 的原因。这样，我们就能在分配对象的同时就将 shared_ptr  与之绑定，从而避免了无意中将同一块内存绑定到多个独立创建的 shared_ptr  上。

    ```
    void process(shared_ptr<int> ptr) {
    }
    
    shared_ptr<int> iptr = make_shared<int>(32);
    process(iptr);
    cout << *iptr << endl;
    
    int *x(new int(32));
    //process(x); // error, no match
    process(shared_ptr<int>(x));
    cout << *x << endl;	// x所指向的地址已被释放
    ```

  * **当将一个 shared_ptr 绑定到一个普通指针时，我们就将内存的管理责任交给了这个shared_ptr , 一旦这样做了，我们就不应该再使用内置指针来访问shared_ptr所 指向的内存了。**

* **使用一个内置指针来访问一个智能指针所负责的对象是很危险的，因为我们无法点知道对象何时会被销毁**

* 不要使用get初始化另一个智能指针或为智能指针赋值

  * **智能指针类型定义了一个名为get的函数,它返回一个内置指针， 指向智能指针管理的对象**。此函数是为了这样一种情况而设计的：我们需要向不能使用智 能指针的代码传递一个内置指针。使用get返回的指针的代码不能delete此指针。

  * 虽然编译器不会给出错误信息，但**将另一个智能指针也绑定到get返回的指针上是错误的**

  * **get用来将指针的访问权限传递给代码，你只有在确定代码不会delete指针 的情况下，才能使用get。特别是，永远不要用get初始化另一个智能指针或者为另一个智能指针赋值。**

    ```c++
        shared_ptr<int> iptr = make_shared<int>(32);
        int *ptr = iptr.get();
        {
            shared_ptr<int> q(ptr);	// error
        }
        cout << *iptr << endl; // iptr, ptr成为空悬指针
    ```

* 其他shared_ptr操作

  * shared_ptr还定义了其他一些操作。我们可以用 reset 来将一个新的指针赋予一个shared_ptr：

    ```c++
    p = new int (1024) ;	//错误：不能将一个指针赋予shared_ptr
    p.reset (new int (1024 ) ) ;	//正确：p指向一个新对象
    ```

    与赋值类似，reset会更新引用计数，如果需要的话，会释放p指向的对象。reset成员经常与unique —起使用，来控制多个shared_ptr共享的对象。**在改变底层对象之 前，我们检查自己是否是当前对象仅有的用户。如果不是，在改变之前要制作一份新的拷贝**

    ```c++
    shared_ptr<int> iptr1 = make_shared<int>(32);
    iptr1.reset(new int(20));
    cout << *iptr1 << endl;  //20
    shared_ptr<int> iptr2 = iptr1;
    *iptr1+=20;
    cout << *iptr2 << endl; // 40
    if (!iptr1.unique())
        iptr1.reset(new int (*iptr1));
    *iptr1+=20;
    cout << *iptr2 << endl; // 40
    ```

* 智能指针和异常

  * 程序需要确保在异常发生后资源能被正确地释放。一个简单的确保资源被释放的方法是使用智能指针。

  * 如果使用智能指针，即使程序块过早结束，智能指针类也能确保在内存不再需要时将其释放

    ```c++
    void f() {
        shared_ptr<int> sp (new int (42) ) ; // 分配一个新对象
        //这段足码抛出一个异常，且在f中未被捕获
    } //在函数结束时shared_ptr自动释放内存
    /*。在上面的程序中，sp是一个shared_ptr,因此sp销毁时会检査引用计数。在 此例中，sp是指向这块内存的唯一指针，因此内存会被释放掉。*/
    ```

  * 函数的退出有两种可能，正常处理结束或者发生了异常，无论哪种情况，局部对象都会被销毁。

  * 与之相对的，当发生异常时，我们直接管理的内存是不会自动释放的。如果使用内置 指针管理内存，且在new之后在对应的delete之前发生了异常，则内存不会被释放

    ```c++
    void f() {
        int *ip = new int (42) ;	// 动态分配一个新对象
        //这段代码抛出一个异常，且在f中未被捕获 
        delete ip;	//在退出之前释放内存
    }
    /*如果在new和delete之间发生异常，且异常未在f中被捕获，则内存就永远不会被释 放了。在函数f之外没有指针指向这块内存，因此就无法释放它了。*/
    ```

* 智能指针和哑类

  * **包括所有标准库类在内的很多C++类都定义了析构函数， 负责清理对象使用的资源**。但是，不是所有的类都是这样良好定义的。特别是那些为C和 C++两种语言设计的类，通常都要求用户显式地释放所使用的任何资源。
  * **那些分配了资源，而又没有定义析构函数来释放这些资源的类，可能会遇到与使用动态内存相同的错误——程序员非常容易忘记释放资源**。类似的，如果在资源分配和释放之间发生了异常，程序也会发生资源泄漏。
  * 与管理动态内存类似，我们通常可以使用类似的技术来管理不具有良好定义的析构函数的类。例如，假定我们正在使用一个C和C++都使用的网络库，使用这个库的代码可能 是这样的

* 使用我们自己的释放操作

  * 默认情况下，shared_ptr 假定它们指向的是动态内存。因此，当一个shared_ptr被销毁时，它默认地对它管理的指针进行delete操作。为了用shared_ptr 来管理一个connection,我们必须首先定义一个函数来代替delete， 这个**删除器（deleter）函数**必须能够完成**对shared_ptr中保存的指针进行释放的操作**。
  * 当我们创建一个shared_ptr时，可以传递一个（可选的）指向删除器函数的参数

* 注意：智能指针陷阱。智能指针可以提供对动态分配的内存安全而又方便的管理，但这建立在正确使用的前提下。为了正确使用智能指针，我们必须坚持一些基本规范：

  * **不使用相同的内置指针值初始化(或reset)多个智能指针**
  * **不delete get ()返回的指针**
  * **不使用get ()初始化或reset另一个智能指针**
  * **如果你使用get()返回的指针，记住当最后一个对应的智能指针销毁后，你的指针就变为无效了**
  * **如果你使用智能指针管理的资源不是new分配的内存，记住传递给它一个删除 器**

#####  unique_ptr

* **一个unique_ptr “拥有”它所指向的对象**。与 shared_ptr 不同，**某个时刻只能 有一个unique_ptr指向一个给定对象。当unique_ptr被销毁时，它所指向的对象也 被销毁。**

* 与shared_ptr不同，没有类似make_shared的标准库函数返回一个 unique_ptro当我们定义一个unique_ptr时，需要将其绑定到一个new返回的指针 上。类似shared_ptr,初始化unique_ptr必须采用直接初始化形式：

  ```c++
  unique_ptr<double> pl; // 可以指向一个 double 的 unique_ptr unique_ptr<int> p2(new int (42) ) ; //p2 指向一个值为 42 的 int
  ```

* **由于一个unique_ptr拥有它指向的对象，因此unique_ptr不支持普通的拷贝或赋值操作**

  ```c++
  unique_ptr<string> pl(new string("Stegosaurus"));
  unique_ptr<string> p2 (pl) ;	// 错误：unique_ptr 不支持拷贝
  unique_ptr<string> p3;
  p3 = p2;	//错误：unique_ptr不支持赋值
  ```

* 虽然我们不能拷贝或赋值unique_ptr，但可以通过调用release或reset将指针的所有权从一个(非const) unique_ptr转移给另一个unique

  ```
  //将所有权从pl (指向string Stegosaurus )转移给p2
  unique_ptr<string> p2 (pl .release () ) ; // release 将 pl 置为空 
  unique_ptr<string> p3(new string(MTrexn));
  //将所有权从p3转移给p2
  p2 . reset (p3 . release () ) ; // reset 释放了 p2 原来指向的内存
  ```
  * release成员返回unique_ptr当前保存的指针并将其置为空。

  * reset 成员接受一个可选的指针参数，令 unique_ptr 重新指向给定的指针。如果 unique_ptr 不为空，它原来指向的对象被释放。

  * **调用release会切断unique_ptr和它原来管理的对象间的联系**。release返回的指针通常被用来初始化另一个智能指针或给另一个智能指针赋值。

  * **如果我们不用另一个智能指针来保存 release返回的指针，我们的程序就要负责资源的释放**

    ```
    p2.release() ;	//错误：p2不会释放内存，而且我们丢失了指针
    auto p = p2 . release () ;	// 正确，但我们必须记得 delete (p)
    ```

* 传递 unique_ptr 参数和返回 unique_ptr

  * 不能拷贝unique_ptr的规则有一个例外：我们可以拷贝或赋值一个将要被销毁的 unique_ptr

    ```c++
    //从函数返回一个unique_ptr：
    unique_ptr<int> clone1 (int p) (
        // 正确：从 int*创建一个 unique_ptr<int> 
        return unique_ptr<int>(new int(p));
    }
     
    // 可以返回一个局部对象的拷贝
    unique_ptr<int> clone2 (int p) {
        unique_ptr<int> ret(new int (p))；
        // ...
        return ret;
    }  
    // 对于两段代码，编译器都知道要返回的对象将要被销毁。在此情况下，编译器执行一种特 殊的“拷贝”
    ```

* 向后兼容：auto_ptr

  * 标准库的较早版本包含了 一个名为auto_ptr的类，它具有unique_ptr的部分特性，但不是全部。特别是，我们不能在容器中保存auto_ptr,也不能从函数中返回 auto_ptr
  * 虽然auto_ptr仍是标准库的一部分，但编写程序时应该使用unique_ptr

* 向unique_ptr传递删除器

  * 类似shared_ptr, unique_ptr默认情况下用delete释放它指向的对象。与 shared_ptr ―样，我们可以重载一个unique_ptr中默认的删除器。但是，unique_ptr管理删除器的方式与shared_ptr不同。

  * **重载一个unique_ptr中的删除器会影响到unique_ptr类型以及如何构造（或 reset）该类型的对象**。与重载关联容器的比较操作类似， 我们必须在尖括号中unique_ptr指向类型之后提供删除器类型。在创建或reset 一个 这种unique_ptr类型的对象时，必须提供一个指定类型的可调用对象（删除器）

    ```
    // p指向一个类型为objT的对象，并使用一个类型为delT的对象释放objT对象
    //它会调用一个名为fen的delT类型对象
    unique_ptr<objT, delT> p （new objT, fen）;
    ```

##### weak_ptr

* **weak_ptr 是一种不控制所指向对象生存期的智能指针，它指向由一个shared_ptr管理的对象**。将一个 weak_ptr 绑定到一个 shared_ptr 不会改变  shared_ptr 的引用计数。一旦最后一个指向对象的 shared_ptr 被销毁，对象就会被释放。即使有 weak_ptr 指向对象，对象也还是会被释放，因此， weak_ptr 的名字抓住了这种智能指针 “弱' 共享对象的特点。

* 当我们创建一个weak_ptr时，要用一个shared_ptr来初始化它

  ```
  auto p = make_shared<int>(42);
  weak_ptr<int> wp (p) ; // wp弱共享p； p的引用计数未改变
  // 本例中wp和p指向相同的对象。由于是弱共享，创建wp不会改变p的引用计数；wp指向的对象可能被释放掉。
  ```

* **由于对象可能不存在，我们不能使用weak_ptr直接访问对象**，而必须调用lock。 此函数检査weak_ptr指向的对象是否仍存在。如果存在，lock返回一个指向共享对象的shared_ptr。与任何其他shared_ptr类似，只要此shared_ptr存在，它所指向的底层对象也就会一直存在。

  ```c++
  if (shared_ptr<int> np = wp. lock() ) ( // 如果 np 不为空则条件成立
      //在if中，np与p共享对象
  }
  //在这段代码中，只有当lock调用返回true时我们才会进入if语句体。在if中，使用 np访问共享对象是安全的。
  ```

* 核查指针类
  * **通过使用weak_ptr, 不会影响一个给定的shared_ptr所指向的对象的生存期。但是，可以阻止用户访问一个不再存在的对象的企图。**

#### 动态数组

* **new和delete运算符一次分配/释放一个对象，但某些应用需要一次为很多对象分配内存的功能。**
  * 例如，vector和string都是在连续内存中保存它们的元素，因此，当容器需要重新分配内存时，必须一次性为很多元素分配内存。
* 为了支持这种需求，C++语言和标准库提供了两种一次分配一个对象数组的方法。C++ 语言定义了另一种new表达式语法，可以分配并初始化个对象数组。标准咋中包含一 个名为allocator的类，允许我们将分配和初始化分离。使用allocator通常会提供 更好的性能和更灵活的内存管理能力
* **大多数应用应该使用标准库容器而不是动态分配的数组**。使用容器更为简单、更不容易出现内存管理错误并且可能有更好的性能
* 如前所述，使用容器的类可以使用默认版本的拷贝、赋值和析构操作。分配动态数组的类则必须定义自己版本的操作，在拷贝、复制以及销毁对象 时管理所关联的内存。

##### new和数组

* 为了让new分配一个对象数组，我们要在类型名之后跟一对方括号，在其中指明要分配的对象的数目。**方括号中的大小必须是整型，但不必是常量。**

  ```c++
  //调用get_size确定分配多少个int
  int *pia = new int [get_size ()] ; // pia 指向第一个 int
  ```

* 也可以**用一个表示数组类型的类型别名来分配一个数组**， 这样，new表达式中就不需要方括号了

  ```c++
  typedef int arr[20];
  int *ptr1 = new arr;
  ```

* 分配一个数组会得到一个元素类型的指针

  * 虽然我们通常称new T\[]分配的内存为“动态数组”，但这种叫法某种程度上有些误导。**当用new分配一个数组时，我们并未得到一个数组类型的对象，而是得到一个数组元素类型的指针**。即使我们使用类型别名定义了一个数组类型，new也不会分配一个数组类型的对象。在上例中，我们正在分配一个数组的事实甚至都是不可见的一一连[num]都没有。new返回的是一个元素类型的指针。
  * **由于分配的内存并不是一个数组类型，因此不能对动态数组调用begin或end 。这些函数使用数组维度（回忆一下，维度是数组类型的一部分）来返回指向首元素和尾后元素的指针。出于相同的原因，也不能用范围for语句来处理 （所谓的）动态数组中的元素。**

* **要记住我们所说的动态数组并不是数组类型，这是很重要的。**

* 初始化动态分配对象的数组

  * 默认情况下，new分配的对象，不管是单个分配的还是数组中的，都是默认初始化的。**可以对数组中的元素进行值初始化，方法是在大小之后跟一对空括号。**

    ```c++
    int *pia = new int[10];		// 10个未初始化的int
    int *pia2 = new int[10](); 	// 10个值初始化为0的int
    string *psa = new string[10]; 	 // 10 个空 string
    string *psa2 = new string[10](); // 10 个空 string
    ```

  * 在新标准中，我们还可以提供一个元素初始化器的花括号列表

    ```
    // 10个int分别用列表中对应的初始化器初始化
    int *pia3 = new int[10]{0,1,2,3,4,5,6,7,8,9};
    // 10个string,前4个用给定的初始化器初始化，剩余的进行值初始化 string *psa3 = new string [10]{"a*', "an”，"the”，"3frx"};
    ```

    与内置数组对象的列表初始化一样，**初始化器会用来初始化动态数组中开始部分的元素。如果初始化器数目小于元素数目，剩余元素将进行值初始化。 如果初始化器数目大于元素数目，则new表达式失败，不会分配任何内存**。

  * 虽然我们用空括号对数组中元素进行值初始化，但不能在括号中给出初始化器，这意味着不能用auto分配数组

* 动态分配一个空数组是合法的

  * **虽然我们不能创建一个大小为0的静态数组对象，但当n等于0时，调用new[n] 是合法的**

    ```c++
    char arr[0] ;	//错误：不能定义长度为0的数组
    char *cp = new char [0 ] ;	//正确：但cp不能解引用
    ```

  * **当我们用new分配一个大小为0的数组时，new返回一个合法的非空指针**, 此指针保证与new返回的其他任何指针都不相同。。对于零长度的数组来说，此指针就像尾后指针一 样，我们**可以像使用尾后迭代器一样使用这个指针**。可以用此指针进行比较操作，就像上面循环代码中那样。可以向此指针加上（或从此指针减去）0, 也可以从此指针减去自身从而得到0。但此指针不能解引用一一毕竟它不指向任何元素。

* 释放动态数组

  * 为了释放动态数组，我们使用一种特殊形式的delete—在指针前加上一个空方括号对：

    ```c++
    delete p;	// p必须指向一个动态分配的对象或为空
    delete [] pa; // pa必须指向一个动态分配的数组或为空
    ```

  * **如果我们在delete 一个指向数组的指针时忽略了方括号 （或者在delete 一个指向单一对象的指针时使用了方括号），其行为是未定义的。**

* 智能指针和动态数组

  * 标准库提供了一个可以管理new分配的数组的unique_ptr版本。为了用一个 unique_ptr管理动态数组，我们必须在对象类型后面跟一对空方括号

    ```c++
    // up指向一个包含10个未初始化int的数组
    unique_ptr<int[]> up（new int[10]）;
    up. release （） ; //自动用delete []销毁其指针
    // 类型说明符中的方括号（<int[]>）指出up指向一个int数组而不是一个int. 由于 up指向一个数组，当up销毁它管理的指针时，会自动使用deleted
    ```

  * **指向数组的unique_ptr提供的操作有一些不同。当一个unique_ptr指向一个数组 时，我们不能使用点和箭头成员运算符。毕竟unique_ptr指向的是一个数组而不是单个对象，因此这些运算符是无意义的。另一方面，当一个unique_ptr指向一个数组时, 我们可以使用下标运算符来访问数组中的元素**

    ```c++
    for （size_t i = 0; i != 10; ++i）
        up [i] = i; //为每个元素赋予一个新值
    ```

* 与unique_ptr不同，shared_ptr不直接支持管理动态数组。**如果希望使用 shared_ptr管理一个动态数组，必须供自己定义的删除器**

  ```c++
  /为了使用shared_ptr,必须提供一个删除器 
  shared_ptr<int> sp(new int[10], [](int *p) { delete[] p; });
  sp.reset () ; //使用我们提供的lambda释放数组，它使用delete []
  ```
  * 如果未提供删除器，这段代码将是未定义的。

  * 默认情况下，shared_ptr使用delete 销毁它指向的对象。**如果此对象是一个动态数组，对其使用delete味产生的问题与释放一个动态数组指针时忘记\[\]产生的问题一样**

    ```c++
    // shared_ptr未定义下标运算符，并且不支持指针的算术运算
    for(size_t i = 0; i != 10; ++i)
    	*(sp.get() + i) = i; //使用get获取一个内置指针 /*shared_Ptr未定义下标运算符，而且智能指针类型不支持指针算术运算。因此，为了访 问数组面的元素，必须用get获取一个内置指针，然后用它来访问数组元素。*/
    ```

##### allocator 类

* new有一些灵活性上的局限，其中一方面表现在**它将内存分配和对象构造组合在了一 起**。类似的，**delete将对象析构和内存释放组合在了一起**。我们分配单个对象时，通常 希望将内存分配和对象初始化组合在一起。因为在这种情况下，我们几乎肯定知道对象应 有什么值。
* **当分配一大块内存时，我们通常计划在这块内存上按需构造对象。在此情况下，我们希望将内存分配和对象构造分离**。这意味着我们可以分配大块内存，但只在真正需要时才真正执行对象创建操作（同时付出一定开销）。
* —般情况下，**将内存分配和对象构造组合在一起可能会导致不必要的浪费**。

* 更重要的是，那些没有默认构造函数的类就不能动态分配数组了。

* allocator 类

  * 标准库allocator类定义在头文件memory中，它帮助我们**将内存分配和对象构造分离开来**。

  * **它提供一种类型感知的内存分配方法，它分配的内存是原始的、未构造的。**

  *  allocator是一个模板。为了定义一个 allocator对象，我们必须指明这个allocator可以分配的对象类型。**当一个 allocator对象分配内存时，它会根据给定的对象类型来确定恰当的内存大小和对齐位置**

    ```c++
    allocator<string> alloc;	// 可以分配 string 的 allocator 对象
    auto const p = alloc.allocate（n）;	//分配 n 个未初始化的 string
    // 这个allocate调用为n个string分配了内存。
    ```

* allocator分配未构造的内存

  * **allocator分配的内存是未构造的(unconstructed)**。我们按需要在此内存中构造对象。在新标准库中，construct成员函数接受一个指针和零个或多个额外参数，在给定位置构造一个元素。额外参数用来初始化构造的对象。类似make_shared的参数, 这些**额外参数必须是与构造的对象的类型相配的合法的初始化器**：

    ```c++
    auto q = p; // q指向最后构造的元素之后的位置
    alloc.construct (q++) ;	// *q 为空字符串
    alloc.construct(q++, 10, 'c');	// *q 为 cccccccccc
    alloc.construct(q++, "hi”)；	// *q 为 hi!
    ```

  * **还未构造对象的情况下就使用原始内存是错误的：**

    ```c++
    cout << *p << endl; //正确：使用string的输出运算符
    cout << *q << endl; //灾难：q指向未构造的内存！
    ```

  * **为了使用allocate返回的内存，我们必须用construct构造对象。使用未构造的内存，其行为是未定义的，**

  * 当我们用完对象后，必须对每个构造的元素调用destroy来销毁它们。函数destroy 接受一个指针，对指向的对象执行析构函数

    ```c++
    alloc.destroy(p);
    ```

  * **我们只能对真正构造了的元素进行destroy操作。**

  * 一旦元素被销毁后，就可以重新使用这部分内存来保存其他string,也可以将其归还给系统。释放内存通过调用deallocate来完成

    ```c++
    alloc.deallocate(p, n);
    ```

    * 我们传递给deallocate的指针不能为空，它**必须指向由allocate分配的内存**。而且, 传递给deallocate的**大小参数必须与调用allocated分配内存时提供的大小参数具有一样的值**。

* 拷贝和填充未初始化内存的算法

  * 标准库还为allocator类定义了两个伴随算法，可以在未初始化内存中创建对象。

    ```c++
    vector<string> users = {"jack", "tom", "zhangsan", "lisi"};
    allocator<string> alloc;
    alloc.allocate(users.size() << 1);
    auto q = uninitialized_copy(users.cbegin(), users.cend(), alloc);
    uninitialized_fill_n(q, users.size(), "unknow");
    ```

    * 类似copy, uninitialized_copy返回（递增后的）目的位置迭代器。因此，一 次uninitialized_copy调用会返回一个指针，指向最后一个构造的元素之后的位置。

#### 小结

* 在C++中，内存是通过new表达式分配，通过delete表达式释放的。标准库还定 义了—个allocator类来分配动态内存块。

* 分配动态内存的程序应负责释放它所分配的内存。内存的正确释放是非常容易出错的地方：要么内存永远不会被释放，要么在仍有指针引用它时就被释放了。

* 新的标准库定义了智能指针类型 shared_ptr， unique_ptr和weak_ptr, 可令动态内存管理更为安全。对于一块内存，当没看任何用户使用时，智能指针会自动释放它。现代C++程序应尽可能使用智能指针。

  

