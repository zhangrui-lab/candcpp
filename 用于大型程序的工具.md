* 与仅需几个程序员就能开发完成的系统相比，大规模编程对程序设计语言的要求更高。大规模应用程序的特殊要求包括：
  * 在独立开发的子系统之间协同处理错误的能力。
  * 使用各种库（可能包含独立开发的库）进行协同开发的能力。
  * 对比较复杂的应用概念建模的能力。

#### 异常处理

* 异常处理（exception handling）机制允许程序中独立开发的部分能够在运行时就出现的问题进行通信并做出相应的处理。异常使得我们能够将问题的检测与解决过程分离开来。程序的一部分负责检测问题的岀现，然后解决该问题的任务传递给程序的另一部分。 检测环节无须知道问题处理模块的所有细节，反之亦然。

##### 抛出异常

* 在C++语言中，我们通过抛出（throwing）—条表达式来引发（raised） 一个异常。被 抛出的表达式的类型以及当前的调用链共同决定了哪段处理代码（handler）将被用来处理该异常。被选中的处理代码是在调用链中与抛出对象类型匹配的最近的处理代码。其中， 根据抛出对象的类型和内容，程序的异常抛出部分将会告知异常处理部分到底发生了什么 错误。

* 当执行一个throw, 跟在throw后面的语句将不再被执行。相反，程序的控制权从throw转移到与之匹配的catch模块。该catch可能是同一个函数中的局部catch也可能位于直接或间接调用了发生异常的函数的另一个函数中。控制权从一处转移到另一 处，这有两个重要的含义：

  * 沿着调用链的函数可能会提早退出。
  * 一旦程序开始执行异常处理代码，则沿着调用链创建的对象将被销毁。

  因为跟在throw后面的语句将不再被执行，所以throw语句的用法有点类似于return 语句：它通常作为条件语句的一部分或者作为某个函数的最后（或者唯一）一条语句。

* 栈展开
  * 当抛出一个异常后，程序暂停当前函数的执行过程并立即开始寻找与异常匹配的catch子句。当throw出现在一个try语句块（try block）内时，检查与该try块关联的catch子句。如果找到了匹配的catch,就使用该catch处理异常。如果这一步没找到匹配的catch且该try语句嵌套在其他try块中，则继续检查与外层try匹配的 catch子句。如果还是找不到匹配的catch,则退出当前的函数，在调用当前函数的外层函数中继续寻找。如果对抛出异常的函数的调用语句位于一个try语句块内，则检査与该try块关联的catch子句。如果找到了匹配的catch,就使用该catch处理异常。否则，如果该 try语句嵌套在其他try块中，则继续检査与外层try匹配的catch子句。如果仍然没 有找到匹配的catch,则退出当前这个主调函数，继续在调用了刚刚退出的这个函数的其 他函数中寻找，以此类推。
  * 上述过程被称为栈展开(stack unwinding)过程。栈展开过程沿着嵌套函数的调用链 不断查找，直到找到了与异常匹配的catch子句为止；或者也可能一直没找到匹配的 catch,则退出主函数后查找过程终止。
  * 假设找到了一个匹配的catch子句，则程序进入该子句并执行其中的代码。当执行完这个catch子句后，找到与try块关联的最后一个catch子句之后的点，并从这里继续执行。
  * 如果没找到匹配的catch子句，程序将退出。因为异常通常被认为是妨碍程序正常执行的事件，所以一旦引发了某个异常，就不能对它置之不理。当找不到匹配的catch 时，程序将调用标准库函数terminate,顾名思义，terminate负责终止程序的执行过程。
* 一个异常如果没有被捕获，则它将终止当前的程序。
* 栈展开过程中对象被自动销毁
  * 在栈展开过程中，位于调用链上的语句块可能会提前退出。通常情况下，程序在这些 块中创建了一些局部对象。我们已经知道，块退出后它的局部对象也将随之销毁，这条规 则对于栈展开过程同样适用。如果在栈展开过程中退出了某个块，编译器将负责确保在这 个块中创建的对象能被正确地销毁。如果某个局部对象的类型是类类型，则该对象的析构 函数将被自动调用。与往常一样，编译器在销毁内置类型的对象时不需要做任何事情。
  * 如果异常发生在构造函数中，则当前的对象可能只构造了一部分。有的成员已经初始 化了，而另外一些成员在异常发生前也许还没有初始化。即使某个对象只构造了一部分， 我们也要确保已构造的成员能被正确地销毁。
  * 类似的，异常也可能发生在数组或标准库容器的元素初始化过程中。与之前类似，如 果在异常发生前已经构造了一部分元素，则我们应该确保这部分元素被正确地销毁。
* 析构函数与异常
  * 析构函数总是会被执行的，但是函数中负责释放资源的代码却可能被跳过，这一特点 对于我们如何组织程序结构有重要影响。如果 一个块分配了资源，并且在负责释放这些资源的代码前面发生了异常，则释放资源的代码将不会被执行。另一方面，类对象分配的资源将由类的析构函数负责释放。因此，如果我们使用类来控制资源的分配，就能确保无论函数正常结束还是遭遇异常，资源都能被正确地释放。
  * 析构函数在栈展开的过程中执行，这一事实影响着我们编写析构函数的方式。在栈展 开的过程中，已经引发了异常但是我们还没有处理它。如果异常抛出后没有被正确捕获， 则系统将调用terminate函数。因此，岀于栈展开可能使用析构函数的考虑，**析构函数不应该抛出不能被它自身处理的异常**。换句话说，如果析构函数需要执行某个可能抛出异 常的操作，则该操作应该被放置在一个try语句块当中，并旦在析构函数内部得到处理。
  * 在实际的编程过程中，因为析构函数仅仅是释放资源，所以它不太可能抛出异常。所 有标准库类型都能确保它们的析构函数不会引发异常。
  * 在栈展开的过程中，运行类类型的局部对象的析构函数. 因为这些析构函数是自动执行的，所以它们不应该抛出异常：一旦在栈展开的过程中析构函数抛出了异常，并且析构函数自身没能捕获到该异常，则程序将被终止

* 异常对象
  * 异常对象(exception object)是一种特殊的对象，编译器使用异常抛出表达式来对异 常对象进行拷贝初始化。因此，throw语句中的表达式必须拥有完全类型。而且如果该表达式是类类型的话，则相应的类必须含有一个可访问的析构函数和一个可访问的拷贝或移动构造函数。如果该表达式是数组类型或函数类型，则表达式将被转换成与之对应的指针类型。
  * **异常对象位于由编译器管理的空间中，编译器确保无论最终调用的是哪个catch子句都能访问该空间。当异常处理完毕后，异常对象被销毁**。
  * 如我们所知，当一个异常被抛出时，沿着调用链的块将依次退出直至找到与异常匹配 的处理代码。如果退出了某个块，则同时释放块中局部对象使用的内存。因此，抛出一个指向局部对象的指针几乎肯定是一种错误的行为。出于同样的原因，从函数中返回指向局部对象的指针也是错误的。如果指针所指的对象位于某个块中， 而该块在catch语句之前就已经退出了，则意味着在执行catch语句之前局部对象已经被销毁了。
  * **当我们抛出一条表达式时，该表达式的静态编译时类型决定了异常对象的类型**，因为很多情况下程序抛出的表达式类型来自于某个继承体系。如果一条throw表达式解引用一个基类指针，而该指针实际指向的是派生类对象，则抛出的对象将被切掉一部分，只有基类部分被抛出。
  * 抛出指针要求在任何对应的处理代码存在的地方，指针所指的对象都必须存在

##### 捕获异常

* catch子句（catch clause）中的异常声明（exception declaration）看起来像是只包含 一个形参的函数形参列表。像在形参列表中一样，如果catch无须访问抛出的表达式的 话，则我们可以忽略捕获形参的名字。
* 声明的类型决定了处理代码所能捕获的异常类型。这个类型必须是完全类型，它可以是左值引用，但不能是右值引用
* 当进入一个catch语句后，通过异常对象初始化异常声明中的参数。和函数的参数类似，如果catch的参数类型是非引用类型，则该参数是异常对象的一个副本，在catch 语句内改变该参数实际上改变的是局部副本而非异常对象本身；相反，如果参数是引用类 型，则和其他引用参数一样，该参数是异常对象的一个别名，此时改变参数也就是改变异常对象。
* catch的参数还有一个特性也与函数的参数非常类似：如果catch的参数是基类类型，则我们可以使用其派生类类型的异常对象对其进行初始化。此时，如果catch的参数是非引用类型，则异常对象将被切掉一部分，这与将派生类对象以值传递的方式传给一个普通函数差不多。另一方面，如果catch的参数是基类的引用，则该参数将以常规方式绑定到异常对象上。
* 最后一点需要注意的是，异常声明的静态类型将决定catch语句所能执行的操作。 如果catch的参数是基类类型，则catch无法使用派生类特有的任何成员。
* 通常情况下，如果catch接受的异常与某个继承体系有关，则最好将该catch 的参数定义成引用类型
* 查找匹配的处理代码
  * 在搜寻catch语句的过程中，我们最终找到的catch未必是异常的最佳匹配。相反， 挑选岀来的应该是第一个与异常匹配的catch语句。因此，越是专门的catch越应该置 于整个catch列表的前端。
  * 因为catch语句是按照其出现的顺序逐一进行匹配的，所以当程序使用具有继承关系的多个异常时必须对catch语句的顺序进行组织和管理，使得派生类异常的处理代码 出现在基类异常的处理代码之前。
  * 与实参和形参的匹配规则相比，异常和catch异常声明的匹配规则受到更多限制。 此时，绝大多数类型转换都不被允许，除了一些极细小的差别之外，要求异常的类型和 catch声明的类型是精确匹配的：
    * 允许从非常量向常量的类型转换，也就是说，一条非常量对象的throw语句可以 匹配一个接受常量引用的catch语句。
    * 允许从派生类向基类的类型转换。
    * 数组被转换成指向数组（元素）类型的指针，函数被转换成指向该函数类型的指针。 除此之外，包括标准算术类型转换和类类型转换在内，其他所有转换规则都不能在匹配catch的过程中使用。
  * 如果在多个catch语句的类型之间存在着继承关系，则我们应该把继承链最底端的类(most derived type )放在前面，而将继承链最顶端的美(least derived type )放在后面。

* 重新抛出
  * 有时，**一个单独的catch语句不能完整地处理某个异常。在执行了某些校正操作之 后，当前的catch可能会决定由调用链更上一层的函数接着处理异常**。一条catch语句 通过重新抛出(rethrowing)的操作将异常传递给另外一个catch语句。这里的重新抛出 仍然是一条throw语句，只不过不包含任何表达式： `throw;`
  * 空的throw语句只能出现在catch语句或catch语句直接或间接调用的函数之内。如 果在处理代码之外的区域遇到了空throw语句，编译器将调用terminate。
  * 一个重新抛岀语句并不指定新的表达式，而是将当前的异常对象沿着调用链向上传递。
  * 很多时候，catch语句会改变其参数的内容。如果在改变了参数的内容后catch语 句重新抛出异常，则**只有当catch异常声明是引用类型时我们对参数所做的改变才会被 保留并继续传播**
* 捕获所有异常的处理代码
  * 有时我们希望不论抛出的异常是什么类型，程序都能统一捕获它们。要想捕获所有可 能的异常是比较有难度的，毕竟有些情况下我们也不知道异常的类型到底是什么。即使我 们知道所有的异常类型，也很难为所有类型提供唯一一个catch语句。为了一次性捕获 所有异常，我们使用省略号作为异常声明，这样的处理代码称为捕获所有异常(catch-all) 的处理代码，形如catch (...)。一条捕获所有异常的语句可以与任意类型的异常匹配。
  * catch (...)通常与重新抛出语句一起使用，其中catch执行当前局部能完成的工 作，随后重新抛岀异常
  * catch (...)既能单独出现，也能与其他几个catch语句一起出现。
  *  如果catch (...)与其他几个catch语句一起出现，则catch (...)必须在最后的位置出现。在捕获所有异常语句后面的catch语句将永远不会被匹配

##### 函数try语句块与构造函数

* 通常情况下，程序执行的任何时刻都可能发生异常，特别是异常可能发生在处理构造函数初始值的过程中。构造函数在进入其函数体之前首先执行初始值列表。因为在初始值列表抛出异常时构造函数体内的try语句块还未生效，所以构造函数体内的catch语句无法处理构造函数初始值列表抛出的异常。

* 要想处理构造函数初始值抛出的异常，我们必须将构造函数写成函数try语句块(也称为函数测试块，function try block)的形式。函数try语句块使得一组catch语句既能处理构造函数体(或析构函数体)，也能处理构造函数的初始化过程(或析构函数的析构过程)。

  ```c++
  className(parameter list) try: init {} catch(...) { /*exce hand*/ }
  ```

  注意：关键字try出现在表示构造函数初始值列表的冒号以及表示构造函数体的花括号之前。与这个try关联的catch既能处理构造函数体抛出的异常，也能处理成员初始化列表抛岀的异常。

* 还有一种情况值得读者注意，在初始化构造函数的参数时也可能发生异常，这样的异常不属于函数try语句块的一部分。函数try语句块只能处理构造函数开始执行后发生的异常。和其他函数调用一样，如果在参数初始化的过程中发生了异常，则该异常属于调用表达式的一部分，并将在调用者所在的上下文中处理。

##### noexcept 异常说明

* 对于用户及编译器来说，预先知道某个函数不会抛出异常显然大有裨益。首先，知道 函数不会抛岀异常有助于简化调用该函数的代码；其次，如果编译器确认函数不会抛出异 常，它就能执行某些特殊的优化操作，而这些优化操作并不适用于可能出错的代码。

* 在C++11新标准中，我们可以通过提供noexcept说明(noexcept specification)指定某个函数不会抛出异常。其形式是关键字noexcept紧跟在函数的参数列表后面, **不抛岀说明(nonthrowing specification)**

  ```c++
  retType funcName(parameter list) noexcept;
  ```

* 对于一个函数来说，noexcept说明要么出现在该函数的所有声明语句和定义语句中，要么一次也不出现。该说明应该在函数的尾置返回类型之前。我们也可以在函数指针的声明和定义中指定noexcepto在typedef或类型别名 中则不能出现noexcepto在成员函数中，noexcept说明符需要跟在const及引用限 定符之后，而在final、override或虚函数的=0之前。

* 违反异常说明

  * 编译器并不会在编译时检查noexcept说明。实际上， 如果一个函数在说明了 noexcept的同时又含有throw语句或者调用了可能抛出异常的其他函数，编译器将顺利编译通过，并不会因为这种违反异常说明的情况而报错(不排除个别编译器会对这种用法提出警告)
  * 因此可能出现这样一种情况：尽管函数声明了它不会抛岀异常，但实际上还是抛出了。 一旦一个noexcept函数抛出了异常，程序就会调用terminate以确保遵守不在运行时抛出异常的承诺。上述过程对是否执行栈展开未作约定，因此noexcept可以用在两种情况下：一是我们确认函数不会抛出异常，二是我们根本不知道该如何处理异常。
  * 指明某个函数不会抛出异常可以令该函数的调用者不必再考虑如何处理异常。无论是 函数确实不抛岀异常，还是程序被终止，调用者都无须为此负责。
  * 通常情况下，编译器不能也不必在编译时验证异常说明

* 异常说明的实参

  * noexcept说明符接受一个可选的实参，该实参必须能转换为bool类型：如果实参是true,则函数不会抛出异常；如果实参是false,则函数可能抛出异常：

    ```c++
    void recoup (int) noexcept (true) ;	// recoup 不会抛出异常
    void alloc (int) noexcept (false) ;	// alloc 可能抛出异常
    ```

* noexcept运算符

  * noexcept说明符的实参常常与noexcept运算符(noexcept operator)混合使用。noexcept运算符是一个一元运算符，它的返回值是一个bool类型的右值常量表达式，用于表示给定的表达式是否会抛出异常。和sizeof类似，noexcept也不会求其运算对象的值。
  * noexcept(e); 当e调用的所有函数都做了不抛出说明且e本身不含有throw语句时，上述表达式为 true；否则 noexcept (e)返回 false。
  * 我们可以使用noexcept运算符得到如下的异常说明：`void f () noexcept (noexcept (g () ) ) ； // f 和 g 的异常说明一致` 如果函数g承诺了不会抛出异常，则f也不会抛出异常；如果g没有异常说明符，或者g 虽然有异常说明符但是允许抛出异常，则f也可能抛出异常。
  * noexcept有两层含义：当跟在函数参数列表后面时它是异常说明符；而当作为noexcept异常说明的bool实参出现时，它是一个运算符。

* 异常说明与指针、虚函数和拷贝控制

  * 尽管noexcept说明符不属于函数类型的一部分，但是函数的异常说明仍然会影响函数的使用。

  * **函数指针及该指针所指的函数必须具有一致的异常说明**。也就是说，如果我们为某个 指针做了不抛出异常的声明，则该指针将只能指向不抛出异常的函数。相反，如果我们显式或隐式地说明了指针可能抛出异常，则该指针可以指向任何函数，即使是承诺了不抛出异常的函数也可以

  * 如果一个虚函数承诺了它不会抛出异常，则后续派生出来的虚函数也必须做出同样的 承诺；与之相反，如果基类的虚函数允许抛出异常，则派生类的对应函数既可以允许抛出异常，也可以不允许抛出异常

    ```c++
    class Base {
    public:
        virtual double f1(double) noexcept ;
        virtual double f2(double) noexcept(false) ;
        virtual double f3(double);
    };
    class Derived:Base {
    public:
        virtual double f1(double) ;	// 错误：Base::fl承诺不会抛出异常
        virtual double f2(double) ; // 正确：与Base::f2的异常说明一致
        virtual double f3(double) noexcept(false) ; // 正确：Derived的f3做了更严格的限定， 这是允许的
    };
    ```

##### 异常类层次

* 标准库异常类构成了下图所示的继承体系

* ![image](E:\Learn\repository\Learning-C\1.png)

* 类型exception仅仅定义了拷贝构造函数、拷贝赋值运算符、一个虚析构函数和一 个名为what的虚成员。其中what函数返回一个const char*,该指针指向一个以unll 结尾的字符数组，并且确保不会抛出任何异常。

  ```c++
    class exception
    {
    public:
      exception() _GLIBCXX_USE_NOEXCEPT { }
      virtual ~exception() _GLIBCXX_TXN_SAFE_DYN _GLIBCXX_USE_NOEXCEPT;
  
      /** Returns a C-style character string describing the general cause
       *  of the current error.  */
      virtual const char*
      what() const _GLIBCXX_TXN_SAFE_DYN _GLIBCXX_USE_NOEXCEPT;
    };
  ```

* 类exception、bad_cast和 bad_alloc定义了默认构造函数。类 runtime_error 和logic_error没有默认构造函数，但是有一个可以接受C风格字符串或者标准库string类型实参的构造函数，这些实参负责提供关于错误的更多信息。 在这些类中，what负责返回用于初始化异常对象的信息。因为what是虚函数，所以当我们捕获基类的引用时，对what函数的调用将执行与异常对象动态类型对应的版本。

* 书店应用程序的异常类

  * 实际的应用程序通常会自定义exception （或者exception的标准库派生类）的 派生类以扩展其继承体系。这些面向应用的异常类表示了与应用相关的异常条件。如果我们构建的是一个真实的书店应用程序，则其中的类将比之前所示的复杂得多。复杂性的一个方面就是如何处理异常。实际上，我们很可能需要建立一个自己的异常类体系，用它来表示与应用相关的各种问题。我们设计的异常类可能如下所示：

    ```c++
    class out_of_stock: public std::runtime_error {
    public:
        explicit out_of_stock(const std::string &s):std::runtime_error(s) {}
    };
    class isbn_mismatch: public std::logic_error {
    public:
        using string=std::string;
        explicit isbn_mismatch(const std::string &s): std::logic_error(s) {}
        isbn_mismatch(const string &s, const string &lhs, const std::string &rhs):
        std::logic_error(s), left(lhs), right(rhs) {}
        const std::string left, right;
    };
    ```

  * 由上可知，我们的**面向应用的异常类继承自标准异常类**。和其他继承体系一样，异常类也可以看作按照层次关系组织的。层次越低，表示的异常情况就越特殊。例如，在异常类继承体系中位于最顶层的通常是exception, **exception表示的含义是某处出错了，至于错误的细节则未作描述**。

  * 继承体系的第二层将exception划分为两个大的类別：**运行时错误和逻辑错误。运行时错误表示的是只有在程序运行时才能检测到的错误；而逻辑错误一般指的是我们可以在程序代码中发现的错误。**

* 使用我们自己的异常类型

  * 我们使用自定义异常类的方式与使用标准异常类的方式完全一样。程序在某处抛出异 常类型的对象，在另外的地方捕获并处理这些出现的问题。

#### 命名空间

* 大型程序往往会使用多个独立开发的库，这些库又会定义大量的全局名字，如类、函 数和模板等。当应用程序用到多个供应商提供的库时，不可避免地会发生某些名字相互冲 突的情况。多个库将名字放置在全局命名空间中将引发命名空间污染(namespace pollution )
* 传统上，程序员通过将其定义的全局实体名字设得很长来避免命名空间污染问题，这样的名字中通常包含表示名字所属库的前缀部分。这种解决方案显然不太理想：对于程序员来说，书写和阅读这么长的名字费时费力且过于烦琐。
* 命名空间(namespace)为防止名字冲突提供了更加可控的机制。命名空间分割了全局命名空间，其中每个命名空间是一个作用域。通过在某个命名空间中定义库的名字，库的作者(以及用户)可以避免全局名字固有的限制。

#### 命名空间定义

* 一个命名空间的定义包含两部分：首先是关键字namespace, 随后是命名空间的名字。在命名空间名字后面是一系列由花括号括起来的声明和定义。只要能出现在全局作用域中的声明就能置于命名空间内，主要包括：类、变量(及其初始化操作)、函数(及其定义)、模板和其他命名空间； `namespace name {};`

* 和其他名字一样，命名空间的名字也必须在定义它的作用域内保持唯一。命名空间既可 以定义在全局作用域内，也可以定义在其他命名空间中，但是不能定义在函数或类的内部。

* 每个命名空间都是一个作用域

  * 和其他作用域类似，**命名空间中的每个名字都必须表示该空间内的唯一实体**。因为不 同命名空间的作用域不同，所以在不同命名空间内可以有相同名字的成员。
  * 定义在某个命名空间中的名字可以被该命名空间内的其他成员直接访问，也可以被这 些成员内嵌作用域中的任何单位访问。位于该命名空间之外的代码则必须明确指出所用的名字属于哪个命名空间

* 命名空间可以是不连续的

  * 命名空间可以定义在几个不同的部分，这一 点与其他作用域不太一样。编写如下的命名空间定义：

    ```c++
    namespace nsp (
    //相关声明
    }
    ```

    可能是定义了一个名为nsp的新命名空间，也可能是为巳经存在的命名空间添加一些新成员。如果之前没有名为nsp的命名空间定义，则上述代码创建一个新的命名空间；否则,上述代码打开已经存在的命名空间定义并为其添加一些新成员的声明。

    命名空间的定义可以不连续的特性使得我们可以**将几个独立的接口和实现文件组成 一个命名空间**。此时，命名空间的组织方式类似于我们管理自定义类及函数的方式：

    * 命名空间的一部分成员的作用是定义类，以及声明作为类接口的函数及对象，则这些成员应该置于头文件中，这些头文件将被包含在使用了这些成员的文件中。
    * 命名空间成员的定义部分则置于另外的源文件中。

    在程序中某些实体只能定义一次：如非内联函数、静态数据成员、变量等，命名空间中定义的名字也需要满足这一要求，我们可以通过上面的方式组织命名空间并达到目的。这种接口和实现分离的机制确保我们所需的函数和其他名字只定义一次，而只要是用到这些实体的地方都能看到对于实体名字的声明。

* 定义多个类型不相关的命名空间应该使用单独的文件分别表示每个类型(或关联类型构成的集合)

* **在通常情况下，我们不把#include放在命名空间内部。如果我们 这么做了，隐含的意思是把头文件中所有的名字定义成该命名空间的成员。**

* 定义命名空间成员

  * 假定作用域中存在合适的声明语句，则命名空间中的代码可以使用同一命名空间定义 的名字的简写形式
  * 也可以在命名空间定义的外部定义该命名空间的成员。命名空间对于名字的声明必须 在作用域内，同时该名字的定义需要明确指出其所属的命名空间; `namespaceName::retType namespaceName::funcName(param list) {}`
    * 尽管命名空间的成员可以定义在命名空间外部，但是**这样的定义必须出现在所属命名空间的外层空间中**。换句话说，我们可以在全局作用域中定义成员,但是不能在一个不相关的作用域中定义这个运算符。

* 模板特例化

  * 模板特例化必须定义在原始模板所属的命名空间中。和其他命名空间名字类似，只要我们在命名空间中声明了特例化，就能在命名空间外部定义它了

    ```c++
    //我们必须将模板特例化声明成std的成员
    namespace std {
        template <> struct hash<Sales_data>;
    }
    //在std中添加了模板特例化的声明后，就可以在命名空间std的外部定义它了
    template <> struct std::hash<Sales_data> {
        size_t operator()(const Sales_data &s) const {
            return hash<string>()(s.isbn());
        }
    };
    ```

* 全局命名空间

  * 全局作用域中定义的名字(即在所有类、函数及命名空间之外定义的名字)也就是定义在全局命名空间(global namespace)中。全局命名空间以隐式的方式声明，并且在所有 程序中都存在。全局作用域中定义的名字被隐式地添加到全局命名空间中。
  * 作用域运算符同样可以用于全局作用域的成员，因为全局作用域是隐式的，所以它并 没有名字。下面的形式`::member_name`表示全局命名空间中的一个成员。

* 嵌套的命名空间

  * 嵌套的命名空间是指定义在其他命名空间中的命名空间：

    ```c++
    namespace A {
        namespace B {
            struct Test {
                void operator()() {
                    cout << "A::B::Test()";
                }
            };
        }
    }
    int main() {
        A::B::Test()(); // A::B::Test()
    }
    ```

  * 嵌套的命名空间同时是一个嵌套的作用域，它嵌套在外层命名空间的作用域中。嵌套的命名空间中的名字遵循的规则与往常类似：内层命名空间声明的名字将隐藏外层命名空间声明的同名成员。在嵌套的命名空间中定义的名字只在内层命名空间中有效，外层命名空间中的代码要想访问它必须在名字前添加限定符。

* 内联命名空间

  * C++11新标准引入一种新的嵌套命名空间，称为内联命名空间(inline namespace)。和普通的嵌套命名空间不同，内联命名空间中的名字可以被外层命名空间直接使用。也就是说，我们无须在内联命名空间的名字前添加表示该命名空间的前缀，通过外层命名空间的名字就可以直接访问它。

  * 定义内联命名空间的方式是在关键字namespace前添加关键字inline

  * 关键字inline必须出现在命名空间第一次定义的地方，后续再打开命名空间的时候可以 写inline,也可以不写。

  * 当应用程序的代码在一次发布和另一次发布之间发生了改变时，常常会用到内联命名 空间。

    ```c++
    namespace A {
        inline namespace B {
            struct Test {
                void operator()() {
                    cout << "A::B::Test()";
                }
            };
        }
    }
    int main() {
        A::Test()(); // A::B::Test()
    }
    ```

* 未命名的命名空间

  * 未命名的命名空间(unnamed namespace)是指关键字namespace后紧跟花括号括起 来的一系列声明语句。**未命名的命名空间中定义的变量拥有静态生命周期**：它们在第一次使用前创建，并且直到程序结束才销毁。

  * 一个未命名的命名空间可以在某个给定的文件内不连续，但是不能跨越多个文件。每 个文件定义自己的未命名的命名空间，如果两个文件都含有未命名的命名空间，则这两个空间互相无关。在这两个未命名的命名空间中可以定义相同的名字，并且这些定义表示的是不同实体。如果一个头文件定义了未命名的命名空间，则该命名空间中定义的名字将在每个包含了该头文件的文件中对应不同实体。

  * 和其他命名空间不同，未命名的命名空间仅在特定的文件内部有效，其作用范围不会横跨多个不同的文件。

  * 定义在未命名的命名空间中的名字可以直接使用，毕竟我们找不到什么命名空间的名 字来限定它们；同样的，我们也不能对未命名的命名空间的成员使用作用域运算符。

  * 未命名的命名空间中定义的名字的作用域与该命名空间所在的作用域相同。如果未命 名的命名空间定义在文件的最外层作用域中，则该命名空间中的名字一定要与全局作用域中的名字有所区别

    ```c++
    int i;	// i的全局声明
    namespace {
        int i;
    }
    //二义性：i的定义既出现在全局作用域中，又出现在未嵌套的未命名的命名空间中
    i = 10;
    ```

    其他情况下，未命名的命名空间中的成员都属于正确的程序实体。和所有命名空间类似， 一个未命名的命名空间也能嵌套在其他命名空间当中。此时，未命名的命名空间中的成员可以通过外层命名空间的名字来访问：

    ```c++
    namespace local {
        namespace {
            int i;
        }
    }
    //正确：定义在嵌套的未命名的命名空间中的i与全局作用域中的i不同
    local::i = 42;
    ```

* 未命名的命名空间取代文件中的静态声明
  * 在标准C++引入命名空间的概念之前，程序需要将名字声明成static的以使得其对于整个文件有效。在文件中进行静态声明的做法是从C语言继承而来的。在C语言中, 声明为static的全局实体在其所在的文件外不可见。(**C中的静态存储期，内部链接**)
  * 在文件中进行静态声明的做法已经被C++标准取消了，现在的做法是使用未命名的命名空间。

##### 使用命名空间成员

* 像`namespace_name::member_name`这样使用命名空间的成员显然非常烦琐，特 别是当命名空间的名字很长时尤其如成。幸运的是，我们可以通过一些其他更简便的方法使用命名空间的成员。
* 命名空间的别名
  * 命名空间的别名(namespace alias)使得我们可以为命名空间的名字设定一个短得多 的同义词。例如，一个很长的命名空间的名字形如 `namespace cplusplus_primer ( /*...*/ };` 我们可以为其设定一个短得多的同义词： `namespace primer = cplusplus_primer;`
  * 命名空间的别名声明以关键字namespace开始，后面是别名所用的名字、=符号、命名 空间原来的名字以及一个分号。不能在命名空间还没有定义前就声明别名，否则将产生错误。
  * 命名空间的别名也可以指向一个嵌套的命名空间
  * 一个命名空间可以有好几个同义词或别名，所有别名都与命名空间原来的名字等价

* using声明：扼要概述

  * 一条using声明(using declaration)语句一次只引入命名空间的一个成员。它使得我们可以清楚地知道程序中所用的到底是哪个名字。
  * using声明引入的名字遵守与过去一样的作用域规则：它的有效范围从using声明的地方开始，一直到using声明所在的作用域结束为止。在此过程中，外层作用域的同名实体将被隐藏。未加限定的名字只能在using声明所在的作用域以及其内层作用域中使用。在有效作用域结束后，我们就必须使用完整的经过限定的名字了。
  * 一条using声明语句可以出现在全局作用域、局部作用域、命名空间作用域以及类 的作用域中。在类的作用域中，这样的声明语句只能指向基类成员。

* using指示

  * using指示(using directive)和using声明类似的地方是，我们可以使用命名空间名字的简写形式；和using声明不同的地方是，我们无法控制哪些名字是可见的，因为所有名字都是可见的。
  * using指示以关键字using开始，后面是关键字namespace以及命名空间的名字。 如果这里所用的名字不是一个已经定义好的命名空间的名字，则程序将发生错误。using 指示可以出现在全局作用域、局部作用域和命名空间作用域中，但是不能出现在类的作用域中。
  * using指示使得某个特定的命名空间中所有的名字都可见，这样我们就无须再为它们 添加任何前缀限定符了。简写的名字从using指示开始，一直到using指示所在的作用 域结束都能使用。
  * 如果我们提供了 一个对std等命名空间的using指示而未做任何特殊控制的话，将重新引入由于使用了多个库而造成的名字冲突问题

* using指示与作用域

  * using指示引入的名字的作用域远比using声明引入的名字的作用域复杂。如我们所知，using声明的名字的作用域与using声明语句本身的作用域一致，从效果上看就 好像using声明语句为命名空间的成员在当前作用域内创建了一个别名一样。

  * using指示所做的绝非声明别名这么简单。相反，它具有将命名空间成员提升到包含命名空间本身和using指示的最近作用域的能力。

  * using声明和using指示在作用域上的区别直接决定了它们工作方式的不同。对于 using声明来说，我们只是简单地令名字在局部作用域内有效。相反，using指示是令 整个命名空间的所有内容变得有效。通常情况下，命名空间中会含有一些不能出现在局部作用域中的定义，因此，**using指示一般被看作是出现在最近的外层作用域中**。在最简单的情况下，假定我们有一个命名空间A和一个函数f,它们都定义在全局作 用域中。如果f含有一个对A的using指示，则在f看来，A中的名字仿佛是出现在全局作用域中f之前的位置一样：

    ```c++
    //命名空间A和函数f定义在全局作用域中
    namespace A {
        int i, j;
    }
    
    void f()
    {
        using namespace A;	//把A中的名字注入到全局作用域中
        cout << i * j << endl;	//使用命名空间A中的i和j
        int i; //覆盖A::i
        i++; // 当前局部作用域中的i++; 要想使用A::i则显示声明
        // ...
    }
    ```

* **using声明引入命令空间成员所导致的二义性冲突是被程序所允许的， 只是我们需要在后续的使用中进行显示指定**
* 头文件与using声明或指示
  * 头文件如果在其顶层作用域中含有using指示或using声明，则会将名字注入到所有包含了该头文件的文件中。通常情况下，头文件应该只负责定义接口部分的名字，而不 定义实现部分的名字。因此，头文件最多只能在它的函数或命名空间内使用using指示或using声明。
* 提示： 避免 using 指示
  * using指示一次性注入某个命名空间的所有名字，这种用法看似简单实则充满了风 险：只使用一条语句就突然将命名空间中所有成员的名字变得可见了。如果应用程序使用了多个不同的库，而这些库中的名字通过using指示变得可见，则全局命名空间污染的问题将重新出现。
  * 而且，当引入库的新版本后，正在工作的程序很可能会编译失败。如果新版本引入 了一个与应用程序正在使用的名字冲突的名字，就会出现这个问题。
  * 另一个风险是由using指示引发的二义性错误只有在使用了冲突名字的地方才能被发现。这种延后的检测意味着可能在特定库引入很久之后才爆发冲突。直到程序开始 使用该库的新部分后，之前一直未被检测到的错误才会出现。
  * 相比于使用using指示，在程序中对命名空间的每个成员分别使用using声明效果更好，这么做可以减少注入到命名空间中的名字数量。using声明引起的二义性问题在声明处就能发现，无须等到使用名字的地方，这显然对检测并修改错误大有益处。  using指示也并非一无是处，例如在命名空间本身的实现文件中就可以使用 using 指示。

##### 类、命名空间与作用域