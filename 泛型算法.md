* 标准库容器定义的操作集合惊人得小。标准库并未给每个容器添加大量功能，而是提供了一组算法，这些算法中的大多数都独立于任何特定的容器。这些算法是通用的 （generic,或称泛型的）：它们可用于不同类型的容器和不同类型的元素。
* 顺序容器只定义了很少的操作：在多数情况下，我们可以添加和删除元素、访问首尾元素、确定容器是否为空以及获得指向首元素或尾元素之后位置的迭代器。
* 我们可以想象用户可能还希望做其他很多有用的操作：査找特定元素、替换或删除一 个特定值、重排元素顺序等。
* 标准库并未给每个容器都定义成员函数来实现这些操作，而是定义了一组泛型算法 (generic algorithm)：称它们为“算法”，是因为它们实现了一些经典算法的公共接口，如 排序和搜索；称它们是“泛型的”，是因为它们可以用于不同类型的元素和多种容器类型 (不仅包括标准库类型，如vector或list,还包括内置的数组类型)，以及我们将看到的，还能用于其他类型的序列。

#### 概述

* 大多数算法都定义在头文件algorithm中。标准库还在头文件numeric中定义了 一组数值泛型算法。
* 一般情况下，这些算法并不直接操作容器，而是遍历由两个迭代器指定的一个元素范围来进行操作。通常情况下，算法遍历范围，对其中每个元素进行一些处理。
* **迭代器令算法不依赖于容器**

  * 利用迭代器解引用运算符可以实现元素访问；如果发现匹配元素，find可以返回指向该元素的迭代器；用迭代器递增运算符可以移动到下一个元素；尾后迭代器可以用来判断 find 是否到达给定序列的末尾；find可以返回尾后迭代器来表示 未找到给定元素。
* **算法依赖于元素类型的操作**

  * 虽然迭代器的使用令算法不依赖于容器类型，但大多数算法都使用了一个（或多个） 元素类型上的操作。例如，find用元素类型的==运算符完成每个元素与给定值的比较。其他算法可能要求元素类型支持 < 运算符。不过，我们将会看到大多数算法提供了一种方法，允许我们使用自定义的操作来代替默认的运算符。
* 关键概念：**算法永远不会执行容器的操作**

  * 泛型算法本身不会执行容器的操作，它们只会运行于迭代器之上，执行迭代器的操作。泛型算法运行于迭代器之上而不会执行容器操作的特性带来了一个令人惊讶但非常必要的编程假定：算法永远不会改变底层容器的大小。算法可能改变容器中保存的元素的值，也可能在容器内移动元素，但永远不会直接添加或删除元素。
* 初识泛型算法
* 除了少数例外，标准库算法都对一个范围内的元素进行操作。我们将此元素范围称为 “**输入范围**”。**接受输入范围的算法总是使用前两个参数来表示此范围，两个参数分别是指向要处理的第一个元素和尾元素之后位置的迭代器**。
  * 虽然大多数算法遍历输入范围的方式相似，但它们使用范围中元素的方式不同。理解算法的最基本的方法就是了解它们是否读取元素、改变元素或是重排元素顺序。
* 只读算法
  * 一些算法只会读取其输入范围内的元素，而从不改变元素。
* 对于只读取而不改变元素的算法，通常最好使用cbegin ()和cend ()。但是，如果你计划使用算法返回的迭代器来改变元素的值，就需要使用 begin () 和 end() 的结果作为参数
* 