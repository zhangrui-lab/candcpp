* 当定义一个类时，我们显式地或隐式地指定在此类型的对象拷贝、移动、赋值和销毁时做什么。
* 一个类通过定义五种特殊的成员函数来控制这些操作，包括：
  * 拷贝构造函数 (copy constructor)
  * 拷贝赋值运算符(copy-assignment operator)
  * 移动构造函数(move constructor)
  * 移动赋值运算符(move-assignment operator)
  * 析构函数(destructor)

* **拷贝和移动构造函数定义了当用同类型的另一个对象初始化本对象时做什么。拷贝和移动赋值运算符定义了将一个对象赋予同类型的另一个对象时做什么。析构函数定义了当此类型对象销毁时做什么**。我们称这些操作为**拷贝控制操作(copy control)**。
* 如果一个类没有定义所有这些拷贝控制成员，编译器会自动为它定义缺失的操作。因 此，很多类会忽略这些拷贝控制操作。但是，对一些类来说， 依赖这些操作的默认定义会导致灾难。通常，实现拷贝控制操作最困难的地方是首先认识到什么时候需要定义这些操作。
* 在定义任何 C++ 类时，拷贝控制操作都是必要部分。对初学 C++ 的程序员来说，必须定义对象拷贝、移动、赋值或销毁时做什么，这常常令他们感到困惑。这种困扰很复杂，因为如果我们不显式定义这些操作，编译器也会为我们定义，但**编译器定义的版本的行为可能并非我们所想**。

#### 拷贝、赋值与销毁

##### 拷贝构造函数

* 如果一个构造函数的**第一个参数是自身类类型的引用**，且**任何额外参数都有默认值**， 则此构造函数是拷贝构造函数。

* 虽然我们可以定义 —个接受非const引用的拷贝构造函数，但此参数**几乎总是一个const的引用**。

* **拷贝构造函数通常不应该是explicit 的**

* 合成拷贝构造函数

  * 如果我们没有为一个类定义拷贝构造函数，编译器会为我们定义一个。与合成默认构 造函数不同，即使我们定义了其他构造函数，编译器也会为我们合成一个拷贝构造函数。
  * 对某些类来说，合成拷贝构造函数(synthesized copy constructor)用来阻止我们拷贝该类类型的对象。
  * **而一般情况，合成的拷贝构造函数会将其参数的成员逐个拷贝到正在创建的对象中**。
  * **编译器从给定对象中依次将每个非static成员拷贝到正在创建的对象中。**
  * 每个**成员的类型决定了它如何拷贝**：对**类类型的成员，会使用其拷贝构造函数来拷贝**； **内置类型的成员则直接拷贝**。虽然我们不能直接拷贝一个数组， 但合成拷贝构造函数会逐元素地拷贝一个数组类型的成员。如果数组元素是类类型，则使 用元素的拷贝构造函数来进行拷贝。

* 拷贝初始化

  * 直接初始化和拷贝初始化之间的差异

    ```c++
    string dots(10,'');	//直接初始化
    string s(dots);	//直接初始化
    string s2 = dots;	//拷贝初始化
    string null_book = '9-999-99999-9'; //拷贝初始化
    string nines = string(100, '9');//拷贝初始化
    ```

  * 当使用直接初始化时，我们实际上是要求编译器**使用普通的函数匹配来选择与我们提供的参数最匹配的构造函数**。
  * 当我们使用拷贝初始化（copy initialization）时，我们要求编译器**将右侧运算对象拷贝到正在创建的对象中，如果需要的话还要进行类型转换**
  * 拷贝初始化通常使用拷贝构造函数来完成。但是，如果一个类有一个移动构造函数，则拷贝初始化有时会使用移动构造函数而非拷贝构造函数来完成。但现在，我们只需了解拷贝初始化何时发生，以及拷贝初始化是依靠拷贝构造函数或移动构造函数来完成的就可以了。

* 拷贝初始化不仅在我们**用=定义变量时**会发生，在下列情况下也会发生

  * **将一个对象作为实参传递给一个非引用类型的形参**
  * **从一个返回类型为非引用类型的函数返回一个对象**
  * **用花括号列表初始化一个数组中的元素或一个聚合类中的成员**

* 某些类类型还会对它们所分配的对象使用拷贝初始化。

  * 例如，当我们初始化标准库容器或是调用其 insert 或 push 成员时，容器会对其元素进行拷贝初始化。与之相对，用 emplace 成员创建的元素都进行直接初始化。

* 参数和返回值

  * 在函数调用过程中，具有非引用类型的参数要进行拷贝初始化， **初始化函数形参**
  * 当一个函数具有非引用的返回类型时，**返回值会被用来初始化调用方的结果**

* **拷贝构造函数被用来初始化非引用类类型参数**，这一特性解释了为什么拷贝构造函数自己的参数必须是引用类型。如果其参数不是引用类型，则调用永远也不会成功一一为了 调用拷贝构造函数，我们必须拷贝它的实参，但为了拷贝实参，我们又需要调用拷贝构造函数，如此无限循环。

* 拷贝初始化的限制

  * 如果我们使用的初始化值要求通过一个explicit的构造函数来进行类 型转换，那么使用拷贝初始化还是直接初始化就不是无关紧要 的了

    ```c++
    vector<int> vl(10) ;	//正确：直接初始化
    vector<int> v2 = 10; //错误：接受大小参教的构造函数是explicit的 void f(vector<int>) ; // f的参数进行拷贝初始化
    f(10) ; //错误：不能用一个explicit的构造函数拷贝一个实参
    f(vector<int>(10)) ;	//正确：从一个int直接构造一个临时vector
    ```
    * 直接初始化vl是合法的，但看起来与之等价的拷贝初始化v2则是错误的，因为vector 的接受单一大小参数的构造函数是explicit的。出于同样的原因，当传递一个实参或 从函数返回一个值时，我们不能隐式使用一个explicit构造函数。如果我们希望使用 一个explicit构造函数，就必须显式地使用，像此代码中最后一行那样。

* **编译器可以绕过拷贝构造函数**

  * 在拷贝初始化过程中，编译器可以（但不是必须）跳过拷贝/移动构造函数，直接创建 对象。即，编译器被允许将下面的代码 `string null_book = "9-999-99999-9"; // 拷贝初始化`改写为 `string null_book （"9-999-99999-9"） ; // 编译器略过了拷贝构造函数`但是，即使编译器略过了拷贝/移动构造函数，但在这个程序点上，拷贝/移动构造函数必须是存在且可访问的

##### 拷贝赋值运算符

* 与类控制其对象如何初始化一样，类也可以**控制其对象如何赋值**。与拷贝构造函数一样，如果类未定义自己的拷贝赋值运算符，编译器会为它合成一个。

  ```
  Sales_data trans, accum;
  trans = accum; //使用Sales_data的拷贝赋值运算符
  ```

* 重载赋值运算符

  * **重载运算符本质上是函数**，其名字由operator关键字后接表示要定义的运算符的符号组成。
  * 赋值运算符就是一个名为 `operator=` 函数。
  * 类似于任何其他函数， 运算符函数**也有一个返回类型和一个参数列表**。
  * **重载运算符的参数表示运算符的运算对象。**
    * **某些运算符，必须定义为成员函数。**
    * **如果一个运算符是一个成员函数，其左侧运算对象就绑定到隐式的this参 数**
    * **对于一个二元运算符，其右侧运算对象作为显式参数传递。**

* 拷贝赋值运算符接受一个与其所在类相同类型的参数。为了与内置类型的赋值保持一致，**赋值运算符通常返回一个指向其左侧运算对象的引用**。另外值得注意的是，标准库通常要求保存在容器中的类型要具 有赋值运算符，且其返回值是左侧运算对象的引用。

  ```c++
  class Foo {
  public:
      Foo() {}
      Foo(const Foo&, int a = 10) {}
      Foo& operator=(const Foo&);	// 拷贝赋值运算符
  };
  ```

* 合成拷贝赋值运算符
  * 与处理拷贝构造函数一样，如果一个类未定义自己的拷贝赋值运算符，编译器会为它 生成一个合成拷贝赋值运算符（synthesized copy-assignment operator）
  * 类似拷贝构造函数， 对于某些类，合成拷贝赋值运算符用来禁止该类型对象的赋值。 如果拷贝赋值运算符并非出于此目的，**它会将右侧运算对象的每个非static成员赋予左侧运算对象的对应成员，这一工作是通过成员类型的拷贝赋值运算符来完成的**。对于数组类型的成员，逐个赋值数组元素。合成拷贝赋值运算符返回一个指向其左侧运算对象的引用。

##### 析构函数

* 析构函数执行与构造函数相反的操作：构造函数初始化对象的非static数据成员， 还可能做一些其他工作; **析构函数释放对象使用的资源，并销毁对象的非static数据成员**。
* 析构函数是类的一个成员函数，名字由波浪号接类名构成。它没有返回值，也不接受参数
* 由于析构函数不接受参数，因此它不能被重载。**对一个给定类，只会有唯一一个析构函数**。
* 析构函数完成什么工作
  * 如同构造函数有一个初始化部分和一个函数体，析构函数也有一个函数体和一个析构部分。在一个构造函数中，成员的初始化是在函数体执行之前完成的，且按照它们在类中出现的顺序进行初始化。**在一个析构函数中，首先执行函数体，然后销毁成员。成员按初始化顺序的逆序销毁。**
  * 在对象最后一次使用之后，析构函数的函数体可执行类设计者希望执行的任何收尾工作。通常，**析构函数释放对象在生存期分配的所有资源。**
  * **在一个析构函数中，不存在类似构造函数中初始化列表的东西来控制成员如何销毁， 析构部分是隐式的。成员销毁时发生什么完全依赖于成员的类型。销毁类类型的成员需要执行成员自己的析构函数。内置类型没有析构函数，因此销毁内置类型成员什么也不需要做。**
  * **隐式销毁一个内置指针类型的成员不会delete它所指向的对象。**
  * 与普通指针不同，**智能指针是类类型，所以具有析构函数**。 因此，与普通指针不同，智能指针成员在析构阶段会被自动销毁。
* 什么时候会调用析构函数
  * 无论何时**一个对象被销毁**，就会自动调用其析构函数
  * **变量在离开其作用域时被销毁**
  * 当一个**对象被销毁时，其成员被销毁**
  * **容器（无论是标准库容器还是数组）被销毁时，其元素被销毁**
  * **对于动态分配的对象，当对指向它的指针应用delete运算符时被销毁**
  * **对于临时对象，当创建它的完整表达式结束时被销毁**
* 由于析构函数自动运行，我们的程序可以按需要分配资源，而（通常）无须担心何时释放这些资源
* **指向一个对象的引用或指针离开作用域时，析构函数不会执行**
* 合成析构函数
  * 当一个类未定义自己的析构函数时，编译器会为它定义一个合成析构函数(synthesized destructor)。类似拷贝构造函数和拷贝赋值运算符，对于某些类，合成析构函数被用来阻止该类型的对象被销毁。如果不是这种情况，合成析构函数的函数体就为空。
* **在(空)析构函数体执行完毕后，成员会被自动销毁**。
* 认识到析构函数体自身并不直接销毁成员是非常重要的。成员是在析构函数体之后隐含的析构阶段中被销毁的。**在整个对象销毁过程中，析构函数体是作为成员销毁步骤之外的另一部分而进行的**。

##### 三/五法则

* 需要析构函数的类也需要拷贝和赋值操作
  * 当我们决定一个类是否要定义它自己版本的拷贝控制成员时，一个基本原则是首先确 定这个类是否需要一个析构函数。
  * 通常，对析构函数的需求要比对拷贝构造函数或赋值运算符的需求更为明显。**如果这个类需要一个析构函数，我们几乎可以肯定它也需要一个拷贝构造函数和一个拷贝赋值运算符**。
* **需要拷贝操作的类也需要赋值操作，反之亦然**
  * 虽然很多类需要定义所有(或是不需要定义任何)拷贝控制成员，但某些类所要完成的工作，只需要拷贝或赋值操作，不需要析构函数。
  * 如果一个类需要一个拷贝构造函数，几乎可以肯定它也需要一个拷贝赋值运算符。反之亦然一一如果一个类需要一个拷贝赋值运算符，几乎 可以肯定它也需要一个拷贝构造函数。然而，无论是需要拷贝构造函数还是需要拷贝赋值 运算符都不必然意味着也需要析构函数。

##### 使用=default

* 我们可以通过将拷贝控制成员定义为=default来显式地要求编译器生成合成的版本
* 当我们在类内用=default修饰成员的声明时，合成的函数将隐式地声明为内联的（就像任何其他类内声明的成员函数一样）。
* 如果我们不希望合成的成员是内联函数，应该只对成员的类外定义使用=default。
* 只能对具有合成版本的成员函数使用 =default （即，默认构造函数或拷贝控制成员）

##### 阻止拷贝

* 大多数类应该定义默认构造函数、拷贝构造函数和拷贝赋值运算符，无论是隐式地还是显式地。
* 虽然大多数类应该定义（而且通常也的确定义了）拷贝构造函数和拷贝赋值运算符， 但对某些类来说，这些操作没有合理的意义。在此情况下，定义类时必须**釆用某种机制阻止拷贝或赋值**。
  
  * 例如，iostream类阻止了拷贝，以避免多个对象写入或读取相同的IO 缓冲。
* 为了阻止拷贝，看起来可能应该不定义拷贝控制成员。但是，这种策略是无效的： 如果我们的类未定义这些操作，编译器为它生成合成的版本。

* 定义删除的函数

  * 在新标准下，我们可以通过将拷贝构造函数和拷贝赋值运算符定义为**删除的函数（deleted function）**来阻止拷贝。删除的函数是这样一种函数：**我们虽然声明了它们，但不能以任何方式使用它们**。在函数的参数列表后面加上`=delete`来指出我们希望将它定义为删除的
  * 与=default不同，**=delete必须出现在函数第一次声明的时候**，这个差异与这些声明的含义在逻辑上是吻合的。一个默认的成员只影响为这个成员而生成的代码，因此 =default直到编译器生成代码时才需要。而另一方面，编译器需要知道一个函数是删除的，以便禁止试图使用它的操作。
  * 与=default的另一个不同之处是，我们**可以对任何函数指定=delete** （我们只能对编译器可以合成的默认构造函数或拷贝控制成员使用=default）。虽然删除函数的主要用途是禁止拷贝控制成员，但**当我们希望引导函数匹配过程时，删除函数有时也是有用的**。

* **析构函数不能是删除的成员**

  * 值得注意的是，我们不能删除析构函数。如果析构函数被删除，就无法销毁此类型的对象了。对于一个删除了析构函数的类型，编译器将不允许定义该类型的变量或创建该类的临时对象。而且，如果一个类有某个成员的类型删除了析构函数，我们也不能定义该类的变量或临时对象。因为如果一个成员的析构函数是删除的，则该成员无法被销毁。而如 果一个成员无法被销毁，则对象整体也就无法被销毁了。

  * 对于删除了析构函数的类型，虽然我们不能定义这种类型的变量或成员，但可以动态分配这种类型的对象。但是，不能释放这些对象

    ```c++
    struct NoDtor {
        NoDtor()=default;
        ~NoDtor()=delete;
    };
    ```

  * **对于析构函数已删除的类型，不能定义该类型的变量或释放指向该类型动态分配配对象的指针。**

* 合成的拷贝控制成员可能是删除的

  * 如前所述，如果我们未定义拷贝控制成员，编译器会为我们定义合成的版本。类似的， 如果一个类未定义构造函数，编译器会为其合成一个默认构造函数。**对某些类来说，编译器将这些合成的成员定义为删除的函数**
  * 如果类的某个成员的析构函数是删除的或不可访问的（例如，是private的）， 则类的合成析构函数被定义为删除的。
  * 如果类的某成员的拷贝构造函数是删除的或不可访问的，则类的合成拷贝构造函数被定义为删除的。如果类的某个成员的析构函数是删除的或不可访问的，则类合成的拷贝构造函数也被定义为删除的.
  * 如果类的某个成员的拷贝赋值运算符是删除的或不可访问的,或是类有一个const 的或引用成员，则类的合成拷贝赋值运算符被定义为删除的。
  * 如果类的某个成员的析构函数是删除的或不可访问的，或是类有一个引用成员，它没有类内初始化器，或是类有一个const成员，它没有类内初始化器且其类型未显式定义默认构造函数，则该类的默认构造函数被定义为删除的。
  * 本质上，这些规则的含义是：**如果一个类有数据成员不能默认构造、拷贝、复制或销毁，则对应的成员函数将被定义为删除的。**
    * 一个成员有删除的或不可访问的析构函数会导致合成的默认和拷贝构造函数被定义为删除的。其原因是，**如果没有这条规则，我们可能会创建出无法销毁的对象**。
    * 对于具有引用成员或无法默认构造的const成员的类，编译器不会为其合成默认构造函数
    * 如果一个类有const成员，则它不能使用合成的拷贝赋值运算符。毕竟，此运算符试图赋值所有成员，而将一个新值赋予一 个const对象是不可能的。
    * **虽然我们可以将一个新值赋予一个引用成员，但这样做改变的是引用指向的对象的值，而不是引用本身。如果为这样的类合成拷贝赋值运算符，则赋值后，左侧运算对象仍 然指向与赋值前一样的对象，而不会与右侧运算对象指向相同的对象。由于这种行为看起 来并不是我们所期望的，因此对于有引用成员的类，合成拷贝赋值运算符被定义为删除的。**

* private拷贝控制
  * 在新标准发布之前，类是通过将其拷贝构造函数和拷贝赋值运算符声明为private 的来阻止拷贝
  * 友元和成员函数仍旧可以拷贝对象。**为了阻止友元和成员函数进行拷贝，我们将这些拷贝控制成员声明为private的，但并不定义它们。**
  * 试图访问一个未定义的成员将导致一个链接时错误。通过声明（但不定义）private 的拷贝构造函数，我们可以预先阻止任何拷贝该类型对象的企图：试图拷贝对象的**用户代码将在编译阶段被标记为错误；成员函数或友元函数中的拷贝操作将会导致链接时错误。**
* **声明但不定义一个成员函数是合法的**
* 希望阻止拷贝的类应该使用 =delete 来定义它们自己的拷贝构造函数和拷贝赋值运算符，而不应该将它们声明为private的

#### 拷贝控制和资源管理

* 通常，**管理类外资源的类必须定义拷贝控制成员**。这种类需要通过析构函数来释放对象所分配的资源。一旦一个类需要析构函数，那 么它几乎肯定也需要一个拷贝构造函数和一个拷贝赋值运算符。
* 为了定义这些成员，我们首先必须确定此类型对象的拷贝语义。一般来说，有两种选择：可以定义拷贝操作，使类的行为看起来**像一个值**或者**像一个指针**。
  * 类的行为像一个值，意味着它应该也**有自己的状态**。当我们拷贝一个像值的对象时， 副本和原对象是完全独立的。改变副本不会对原对象有任何影响，反之亦然。
  * 行为像指针的类则共享状态。当我们拷贝一个这种类的对象时，**副本和原对象使用相同的底层数据**。改变副本也会改变原对象，反之亦然。
* 在我们使用过的标准库类中，标准库容器和string类的行为像一个值。而不出意外的，shared_ptr 类提供类似指针的行为，IO类型和unique_ptr不允许拷贝或赋值，因此它们的行为既不像值也不像指针。
* **通常，类直接拷贝内置类型（不包括指针）成员；这些成员本身就是值，因此通常应该让它们的行为像值一 样。我们如何拷贝指针成员决定了类是具有类值行为还是类指针行为。**

##### 行为像值的类

* 为了提供类值的行为，对于类管理的资源，每个对象都应该拥有一份自己的拷贝

  ```c++
  class HasPtr {
  public:
      HasPtr(const string&s = string()) : ps(new string(s)), i(0) {}
      HasPtr(const HasPtr &p): ps(new string(*p.ps)), i(p.i) {}
      HasPtr& operator=(const HasPtr &o);
      ~HasPtr() { delete ps; }
  private:
      string *ps;
      int i;
  };
  ```
  * 为了实现类值 行为，HasPtr需要
    * 定义一个拷贝构造函数，完成string的拷贝，而不是拷贝指针
    * 定义一个析构函数来释放string
    * 定义一个拷贝赋值运算符来释放对象当前的string,并从右侧运算对象拷贝 string

* 类值拷贝赋值运算符

  * **赋值运算符通常组合了析构函数和构造函数的操作**。

    * 类似析构函数，赋值操作会**销毁左侧运算对象的资源**。
    * 类似拷贝构造函数，赋值操作**会从右侧运算对象拷贝数据**。

  * 但是， 非常重要的一点是，这些操作是以正确的顺序执行的，即使将一个对象赋予它自身，也保 证正确。而且，如果可能，我们编写的赋值运算符还应该是**异常安全的**——当异常发生时能将左侧运算对象置于一个有意义的状态

    ```
    HasPtr& HasPtr::operator=(const HasPtr &rhs)
    {
        auto newp = new string (*rhs.ps) ; // 拷贝底层 
        string delete ps;	//释放旧内存
        ps = newp;	//从右侧运算对象拷贝数据到本对象
        i = rhs.i;
        return *this;	//返回本对象
    }
    ```

    * 在这个赋值运算符中，非常清楚，我们首先进行了构造函数的工作：newp的初始化器等 价于HasPtr的拷贝构造函数中ps的初始化器。接下来与析构函数一样，我们delete 当前ps指向的string,,然后就只剩下拷贝指向新分配的string的指针，以及从rhs 拷贝int值到木对象了。

* 关键概念：赋值运算符； 当你编写赋值运算符时，有两点需要记住：

  * **如果将一个对象赋予它自身赋值运算符必须能正确工作**
  * **大多教赋值运算符组合了析构函数和拷贝构造函数的工作**
  * 当你编写一个赋值运算符时，**一个好的模式是先将右侧运算对象拷贝到一个局部临时对象中。当拷贝完成后，销毁左侧运算对象的现有成员就是安全的了。一旦左侧运算对象的资源被销毁，就只剩下将数据从临时对象拷贝到左侧运算对象的成员中了。**

* 为了说明防范自赋值操作的重要性，考虑如果赋值运算符如下编写将会发生什么

  ```c++
  //这样编写赋值运算符是错误的！
  HasPtr& HasPtr::operator=(const HasPtr &rhs)
  {
      delete ps; //释放对象指向的string
      //如果rhs和*this是同一个对象，我们就将从已释放的内存中拷贝数据！ 
      ps = new string (* (rhs.ps));
      i = rhs.i;
      return *this;
  }
  ```

##### 定义行为像指针的类

* 对于行为类似指针的类，我们需要为其定义拷贝构造函数和拷贝赋值运算符，来拷贝指针成员本身而不是它指向的string

* 我们的类仍然需要自己的析构函数来释放接受 string参数的构造函数分配的内存

* **令一个类展现类似指针的行为的最好方法是使用 shared_ptr 来管理类中的资源**。拷贝（或赋值）一个 shared_ptr 会拷贝（赋值）shared_ptr 所指向的指针。shared_ptr 类自己记录有多不用户共享它所指向的对象。当没有用户使用对象时， shared_ptr 类负责释放资源。

* 有时我们希望直接管理资源。在这种情况下，使用**引用计数（reference count） **就很有用了。为了说明引用计数如何工作，我们将重新定义 HasPtr, 令其行为像指针一样，但我们不使用shared_ptr,而是设计自己的引用计数。

* 引用计数的工作方式如下

  * 除了初始化对象外，**每个构造函数（拷贝构造函数除外）还要创建一个引用计数， 用来记录有多少对象与正在创建的对象共享状态**。当我们创建一个对象时，只有一 个对象共享状态，因此将计数器初始化为1。
  * 拷贝构造函数不分配新的计数器，而是拷贝给定对象的数据成员，包括计数器。**拷贝构造函数递增共享的计数器**，指出给定对象的状态又被一个新用户所共享。
  * **析构函数递减计数器**，指出共享状态的用户少了一个。如果计数器变为0,则析构函数释放状态。
  * **拷贝赋值运算符递增右侧运算对象的计数器，递减左侧运算对象的计数器**。如果左侧运算对象的计数器变为0,意味着它的共享状态没有用户了，拷贝赋值运算符就必须销毁状态。

* 在哪里存放引用计数

  * **将计数器保存在动态内存中**。当创建一个对象时，我们也分配一个新的计数器。当拷贝或赋值对象时，我们拷贝指向计数器的指针。使用这种方法， **副本和原对象都会指向相同的计数器**。

    ```c++
    class HasPtr {
    public:
        HasPtr(const string&s = string()) : ps(new string(s)), i(0), use(new std::size_t(1)) {}
        HasPtr(const HasPtr &p): ps(p.ps), i(p.i), use(p.use) { ++*use; }
        HasPtr& operator=(const HasPtr &o);
        ~HasPtr();
    private:
        string *ps;
        int i;
        size_t *use;
    };
    /*在此，我们添加了一个名为use的数据成员，它记录有多少对象共享相同的string.接 受string参数的构造函数分配新的计数器，并将其初始化为1,指出当前有一个用户使 用本对象的string成员。
    当拷贝或赋值一个HasPtr对象时，我们希望副本和原对象都指向相同的stringo 即，当拷贝一个HasPtr时，我们将拷贝ps本身，而不是ps指向的stringo当我们 进行拷贝时，还会递增该string关联的计数器。
    */
    ```

* 析构函数不能无条件地`delete ps;`—可能还有其他对象指向这块内存。析构函数应该递减引用计数，指出共享 string 的对象少了一个。如果计数器变为0, 则析构函数释放ps和use指向的内存

  ```c++
  HasPtr::~HasPtr() {
      if (--*use == 0) {
           delete ps;
           delete use;
      }
  }
  ```

* 拷贝赋值运算符与往常一样**执行类似拷贝构造函数和析构函数的工作**。即，它必须递增右侧运算对象的引用计数(即，拷贝构造函数的工作)，并递减左侧运算对象的引用计数，在必要时释放使用的内存(即，析构函数的工作)。而且与往常一样，赋值运算符**必须处理自赋值**。我们通过先递增rhs中的计数然后 再递减左侧运算对象中的计数来实现这一点。通过这种方法，**当两个对象相同时，在我们检查ps (及use)是否应该释放之前，计数器就已经被递增过了**

  ````c++
  HasPtr & HasPtr::operator=(const HasPtr &o) {
      ++*o.use;	// 先递增引用，确保自赋值的正确性
      if (--*use == 0) {
          delete ps;
          delete use;
      }
      ps = o.ps;
      i = o.i;
      use = o.use;
      return *this;
  }
  ````

#### 交换操作

* 了定义拷贝控制成员，管理资源的类通常还定义一个名为swap的函数。对于那些与重排元素顺序的算法一起使用 的类，定义swap是非常重要的。这类算法在需要交换两个元素时会调用swap。

#### 动态内存管理类

* 某些类需要在运行时分配可变大小的内存空间。这种类通常可以（并且如果它们确实 可以的话，一般应该）使用标准库容器来保存它们的数据。
* 这一策略并不是对每个类都适用；某些类需要自己进行内存分配。这些类一般来说必须定义自己的拷贝控制成员来管理所分配的内存。

##### StrVec类的设计

* 回忆一下，vector类将其元素保存在连续内存中。为了获得可接受的性能，vector 预先分配足够的内存来保存可能需要的更多元素。
* vector的每个添加元素的成员函数会检查是否有空间容纳更多的元素。如果有，成员函数会在下一个 可用位置构造一个对象。如果没有可用空间，vector 就会重新分配空间：它获得新的空间，将已有元素移动到新空间中，释放旧空间，并添加新元素。
* 我们在StrVec类中使用类似的策略。我们将使用一个allocator来获得原始内存 。由于allocator分配的内存是未构造的，我们将在需要添加新元素时用allocator的construct成员在原始内存中创建对象。类似的，当我们 需要删除一个元素时，我们将使用destroy成员来销毁元素。
* 每个StrVec有三个指针成员指向其元素所使用的内存：
  * elements,指向分配的内存中的首元素
  * first_free,指向最后一个实际元素之后的位置
  * cap, 指向分配的内存末尾之后的位置
* 除了这些指针之外，StrVec还有一个名为alloc的静态成员，其类型为 allocator\<string\>.  alloc成员会分配StrVec使用的内存。我们的类还有4个工 具函数：
  * alloc_n_copy会分配内存，并拷贝一个给定范围中的元素。
  * free会车膏毁构造的元素并释放内存。
  * chk_n_alloc保证StrVec至少有容纳一个新元素的空间。如果没有空间添加新 元素，chk_n_alloc会调用reallocate来分配更多内存。
  * reallocate在内存用完时为StrVec分配新内存。

##### StrVec类定义

```c++
// "StrVec.h"
class StrVec {
public:
    StrVec():elements(nullptr), firstFree(nullptr), cap(nullptr) {}
    StrVec(const StrVec&);
    ~StrVec();
    StrVec &operator=(const StrVec&);
    void pushBack(const std::string&);
    size_t size() const;
    size_t capacity() const;
    std::string *begin() const ;
    std::string *end() const;

private:
    static std::allocator<std::string> alloc;
    void checkNAlloc() { if (size() == capacity()) reallocate(); }
    std::pair<std::string *, std::string*>  allocNCopy(const std::string*, const std::string*);
    void free();
    void reallocate();
    std::string *elements;
    std::string *firstFree;
    std::string *cap;
};

// "StrVec.cpp"
void StrVec::pushBack(const std::string &s) {
    checkNAlloc();
    alloc.construct(firstFree++, s);
}


std::pair<std::string *, std::string *> StrVec::allocNCopy(const std::string *b, const std::string *e) {
    auto data = alloc.allocate(e-b);
    return {data, uninitialized_copy(b, e, data)};
}


void StrVec::free() {
    if (elements) {
        for(auto p = firstFree; p != elements; )
            alloc.destroy(--p);
        alloc.deallocate(elements, cap - elements);
    }
}

StrVec::StrVec(const StrVec &s) {
    auto newdata = allocNCopy(s.begin(), s.end());
    elements = newdata.first;
    firstFree = cap = newdata.second;
}

StrVec::~StrVec() {
    free();
}

StrVec & StrVec::operator=(const StrVec &rhs) {
    auto data = allocNCopy(rhs.begin(), rhs.end());
    free();
    elements = data.first;
    firstFree = cap = data.second;
    return *this;
}

void StrVec::reallocate() {
    auto newcapacity = size() ? 2 * size() : 1;
    auto newdata = alloc.allocate(newcapacity);
    auto dest = newdata;
    auto elem = elements;
    for (size_t i = 0; i != size(); ++i)
        alloc.construct(dest++, std::move(*elem++));
    free();
    elements = newdata;
    firstFree = dest;
    cap = elements + newcapacity;
}
```

##### 移动构造函数和std::move

* 为一个StrVec重新分配内存空间会引起从旧内 存空间到新内存空间逐个拷贝string.虽然我们不知道string的实现细节，但我们知道**string具有类值行为**。当拷贝一个string时，新string和原string是相互独立的。改变原string不会影响到副本，反之亦然。
* 由于string的行为类似值，我们可以得出结论，每个string对构成它的所有字符都会保存自己的一份副本。拷贝一个string必须为这些字符分配内存空间，而销毁一个 string必须释放所占用的内存。
* 拷贝一个string就必须真的拷贝数据，因为通常情况下，在我们拷贝了一个string之后，它就会有两个用户。但是，如果是reallocate拷贝StrVec中的string,则在拷贝之后，每个string只有唯一的用户。一旦将元素从旧空间拷贝到了新空间，我们就会立即销毁原string。
* 因此，拷贝这些string中的数据是多余的。在重新分配内存空间时，如果我们能**避免分配和释放string的额外开销**，StrVec的性能会好得多。
* 通过使用新标准库引入的两种机制，我们就可以避免string的拷贝。首先，有一些用标准库类，包括string,都定义了所谓的"移动构造函数”。关于string的移动构造函数如何工作的细节，以及有关实现的任何其他细节，目前都尚未公开。但是，我们知道，移动构造函数通常是将资源从给定对象“移动”而不是拷贝到正在创建的对象。而且我们知道**标准库保证“移后源”(moved-fiom) string仍然保持一个有效的、可析构的状态**。 对于string,我们可以想象每个string都有一个指向char数组的指针。可以假定 string的移动构造函数进行了指针的拷贝，而不是为字符分配内存空间然后拷贝字符。

#### 交换操作

* 除了定义拷贝控制成员，管理资源的类通常还定义一个名为swap的函数。对于那些与重排元素顺序的算法一起使用的类，定义swap是非常重要的。这类算法在需要交换两个元素时会调用swap。

* 如果一个类定义了自己的swap,那么算法将使用类自定义版本。否则，算法将使用标准库定义的swap。虽然与往常一样我们不知道swap是如何实现的，但理论上很容易理解，**为了交换两个对象我们需要进行一次拷贝和两次赋值**。

* **理论上，很多内存分配都是不必要的。我们更希望swap交换指针，而不是分配对象的新副本。**

* 与拷贝控制成员不同，swap并不是必要的。但是，**对于分配了资源的类，定 义swap可能是一种很重要的优化手段。**

* swap函数应该调用swap, 而不是std::swap

  * 如果一个类的成员有自己类型特定的swap函数，调用std: :swap就是错误的了
  * 每个swap调用应该都是未加限定的。即，每个调用都应该是swap,而不是std: : swap。 如果存在类型特定的swap版本，其匹配程度会优于std中定义的版本
  * 因此，如果存在类型特定的swap版本，swap调用会与之匹配。如果不存在类型特定的版本，则会使用std中的版本

* 在赋值运算符中使用swap

  * 定义swap的类通常用swap来定义它们的赋值运算符。这些运算符使用了一种名为**拷贝并交换(copy and swap)**的技术。这种技术将左侧运算对象与右侧运算对象的一个副本进行交换

    ```c++
    HasPtr & HasPtr::operator=(HasPtr rhs) {
        swap(*this, rhs);
        return *this;
    }
    ```

    * 在这个版本的赋值运算符中，参数并不是一个引用，我们将右侧运算对象以传值方式传递给了赋值运算符。因此，rhs是右侧运算对象的一个副本。参数传递时拷贝HasPtr的操作会分配该对象的一个新副本。
    * 在赋值运算符的函数体中，我们调用swap来交换rhs和\*this中的数据成员。这个调用将左侧运算对象中原来保存的指针存入rhs中，并将rhs中原来的指针存入\*this 中。因此，在swap调用之后，\*this中的指针成员将指向新分配的string——右侧运算对象中string的一个副本。
    * 当赋值运算符结束时，rhs被销毁，HasPtr的析构函数将执行。此析构函数delete rhs现在指向的内存，即，释放掉左侧运算对象中原来的内存。

  * 这个技术的有趣之处是它**自动处理了自赋值情况且天然就是异常安全的**。它通过在改变左侧运算对象之前拷贝右侧运算对象保证了自赋值的正确，这与我们在原来的赋值运算符中使用的方法是一致的。它保证异常安全的方法也与原来的赋值运算符实现一样。代码中唯一可能抛出异常的是拷贝构造函数中的new表达式。 如果真发生了异常，它也会在我们改变左侧运算对象之前发生。

  * 使用拷贝和交换的赋值运算符自动就是异常安全的，且能正确处理自赋值

#### 拷贝控制示例

* 虽然通常来说分配资源的类更需要拷贝控制，但资源管理并不是一个类需要定义自己 的拷贝控制成员的唯一原因。一些类也需要拷贝控制成员的帮助来进行簿记工作或其他操作。

* 拷贝赋值运算符通常执行拷贝构造函数和析构函数中也要做的工作。这种情况下，公共的工作应该放在private的工具函数中完成

  ```c++
  class Folder;
  class Message {
      friend class Folder;
  
  public:
      explicit Message(const std::string &str = ""):contents(str) {}
      Message(const Message &);
      ~Message();
      Message &operator=(const Message&);
      void save(Folder&);
      void remove(Folder&);
      void print();
  private:
      std::string contents;
      std::set<Folder*> folders;
      void addToFolders(const Message &);
      void removeFromFolders();
  };
  
  class Folder {
  public:
      void addMessage(Message*);
      void remMessage(Message*);
      void printMessage();
  private:
      std::set<Message*> messages;
  };
  
  void Folder::addMessage(Message *m) {
      messages.insert(m);
  }
  void Folder::remMessage(Message *m) {
      messages.erase(m);
  }
  void Folder::printMessage() {
      for(auto m: messages)
          m->print();
  }
  
  
  
  void Message::save(Folder &f) {
      folders.insert(&f);
      f.addMessage(this);
  }
  
  void Message::remove(Folder &f) {
      folders.erase(&f);
      f.remMessage(this);
  }
  
  void Message::addToFolders(const Message &m) {
      for(auto f: folders)
          f->addMessage(this);
  }
  
  Message::Message(const Message &m):contents(m.contents), folders(m.folders) {
      addToFolders(m);
  }
  
  void Message::removeFromFolders() {
      for(auto f: folders)
          f->remMessage(this);
  }
  
  Message::~Message() {
      removeFromFolders();
  }
  
  Message & Message::operator=(const Message &m) {
      removeFromFolders();
      contents = m.contents;
      folders = m.folders;
      addToFolders(*this);
      return *this;
  }
  void Message::print() {
      cout << "[The Message]: " << contents << endl;
  }
  ```

#### 对象移动

* 新标准的一个最主要的特性是可以移动而非拷贝对象的能力。**很多情况下都会发生对象拷贝。在其中某些情况下，对象拷贝后就立即被销毁了。在这些情况下，移动而非拷贝对象会大幅度提升性能。**
* 如我们已经看到的，我们的StrVec类是这种不必要的拷贝的一个很好的例子。在重新分配内存的过程中，从旧内存将元素拷贝到新内存是不必要的，更好的方式是移动元素。 使用移动而不是拷贝的另一个原因源于IO类或unique_ptr这样的类。这些类都包含**不能被共享的资源（如指针或IO缓冲）**。因此，这些类型前对象不能拷贝但可以移动。
* 在旧C++标准中，没有直接的方法移动对象。因此，即使不必拷贝对象的情况下，我们也不得不拷贝。如果对象较大，或者是对象本身要求分配内存空间（如string）,进行不必要的拷贝代价非常高。类似的，在旧版本的标准库中，容器中所保存的类必须是可拷贝的。但**在新标准中，我们可以用容器保存不可拷贝的类型，只要它们能被移动即可。**
* 标准库容器、string和shared_ptr类既支持移动也支持拷贝。IO类和unique_ptr类可以移动但不能拷贝

##### 右值引用

* 为了支持移动操作，新标准引入了一种新的引用类型， **右值引用(rvaluereference)**。

  * 所谓**右值引用就是必须绑定到右值的引用**。我们通过&&而不是&来获得右值引用。
  * 右值引用有一个重要的性质库， **只能绑定到一个将要销毁的对象**。因此，我们可以自由地将一个右值引用的资源“移动”到另一个对象中。

* 回忆一下，左值和右值是表达式的属性。一些表达式生成或要求左值，而另外一些则生成或要求右值。一般而言，**一个左值表达式表示的是一个对象的身份，而一个右值表达式表示的是对象的值**。

* 类似任何引用，一个右值引用也不过是某个对象的另一个名字而已。如我们所知，对 于常规引用(为了与右值引用区分开来，我们可以称之为左值引用(lvalue reference)), 我们不能将其绑定到要求转换的表达式、字面常量或是返回右值的表达式(参见2.3.1节, 第46页)。右值引用有着完全相反的绑定特性：我们可以将一个右值引用绑定到这类表达 式上，但不能将一个右值引用直接绑定到一个左值上

  ```c++
      int i = 10;
      int &r1 = i;
  
      //int &r2 = 10;   // error: non-const lvalue reference to type 'int' cannot bind to a temporary of type 'int'
      const int &r3 = 10;
      int &&r4 = 10;
  
      //int &r5 = i * 20;   // error: non-const lvalue reference to type 'int' cannot bind to a temporary of type 'int'
       int &&r6 = i * 20;
  ```

  返回左值引用的函数，连同赋值、下标、解引用和前置递增/递减运算符，都是返回左值的表达式的例子。我们可以将一个左值引用绑定到这类表达式的结果上。返回非引用类型的函数，连同算术、关系、位以及后置递增/递减运算符，都生成右值。 我们不能将一个左值引用绑定到这类表达式上，但我们可以将一个const的左值引用或者一个右值引用绑定到这类表达式上。

* **左值持久；右值短暂**

  * 考察左值和右值表达式的列表，两者相互区别之处就很明显了：
    * **左值有持久的状态, 而右值要么是字面常量，要么是在表达式求值过程中创建的临时对象。**
  * 由于右值引用只能绑定到临时对象，我们得知
    * **所引用的对象将要被销毁**
    * **该对象没有其他用户**
  * 这两个特性意味着：**使用右值引用的代码可以自由地接管所引用的对象的资源**。

* **右值引用指向将要被销毁的对象，因此，我们可以从绑定到右值引用的对象“窃取”状态.**

* 变量是左值

* 变量可以看作只有一个运算对象而没有运算符的表达式，虽然我们很少这样看待变
  量。类似其他任何表达式，变量表达式也有左值/右值属性。变量表达式都是左值。带来的结果就是，我们不能将一个右值引用绑定到一个右值引用类型的变量上，这有些令人惊讶：

  ```c++
  int isrrl = 42; //正确：字面常量是右值
  int &&rr2 = rrl; //错误：表达式rrl是左值！
  ```

  其实有了右值表示临时对象这一观察结果，变量是左值这一特性并不令人惊讶。毕竟，**变量是持久的，直至离开作用域时才被销毁。变量是左值**，因此我们不能将一个右值引用直接绑定到一个变量上，即使这个变量是右值引用类型也不行。

* 标准库move函数

  * 虽然不能将一个右值引用直接绑定到一个左值上，但我们可以**显式地将一个左值转换为对应的右值引用类型**。我们还可以通过调用一个名为move的新标准库函数来获得绑定到左值上的右值引用，此函数定义在头文件utility中。 `int &&rr3 = std::move(rrl); // ok`
  * **move调用告诉编译器：我们有一个左值，但我们希望像一个右值一样处理它**。我们必须认识到，**调用move就意味着承诺**：除了对rrl赋值或销毁它外，我们将不再使用它。在 调用move之后，**我们不能对移后源对象的值做任何假设**。
  * 我们可以销毁一个移后源对象，也可以赋予它新值，但不能使用一个移后源对象的值。
  * 如前所述，与大多数标准库名字的使用不同，对move 我们不提供using声明。我们直接调用std: :move而不是move。
  * 使用move的代码应该使用std: :move而不是move。这样做可以避免潜在的名字冲突。

* 移动构造函数和移动赋值运算符

  * 类似string类(及其他标准库类)，如果我们自己的类也同时支持移动和拷贝，那 么也能从中受益。为了让我们自己的类型支持移动操作，需要为其定义移动构造函数和移动赋值运算符。这两个成员类似对应的拷贝操作，但它们从给定对象"窃取”资源而不是拷贝资源。
  * **类似拷贝构造函数，移动构造函数的第一个参数是该类类型的一个引用。不同于拷贝构造函数的是，这个引用参数在移动构造函数中是一个右值引用。与拷贝构造函数一样， 任何额外的参数都必须有默认实参。**
  * 除了完成资源移动，**移动构造函数还必须确保移后源对象处于这样一个状态: 销毁它是无害的。特别是，一旦资源完成移动，源对象必须不再指向被移动的资源——这些资源的所有权已经归属新创建的对象。**

* 我们为StrVec类定义移动构造函数，实现从一个StrVec到另一个StrVec的元素移动而非拷贝：

  ```
  StrVec: :StrVec (StrVec &&s) noexcept //移动操作不应抛出任何异常
  //成员初始化器接管s中的资源
  : elements(s.elements), first_free(s.first_free), cap(s.cap)
  {
    //令s进入这样的状态——对其运行析构函数是安全的
    s.elements = s.first_f ree = s.cap = nullptr;
  }
  ```

  **与拷贝构造函数不同，移动构造函数不分配任何新内存**；它接管给定的StrVec中的内存。**在接管内存之后，它将给定对象中的指针都置为nullptro这样就完成了从给定对象的移动操作，此对象将继续存在**。最终，移后源对象会被销毁，意味着将在其上运行 析构函数。StrVec的析构函数在first_free上调用deallocate. 如果我们忘记了改变s .first_free,则销毁移后源对象就会释放掉我们刚刚移动的内存。

* 移动操作、标准库容器和异常

  * **由于移动操作"窃取”资源，它通常不分配任何资源。因此，移动操作通常不会抛出任何异常。当编写一个不抛出异常的移动操作时，我们应该将此事通知标准库**。我们将看到, 除非标准库知道我们的移动构造函数不会抛出异常，否则它会认为移动我们的类对象时可能会抛出异常，并且为了处理这种可能性而做一些额外的工作。
  * —种通知标准库的方法是在我们的构造函数中指明noexcepto， noexcept是新标准引入的。目前重要的是要知道,**noexcept是我们承诺一个函数不抛出异常的一种方法**。我们在一个函数的参数列表后指定 noexcept。在一个构造函数中，noexcept出现在参数列表和初始化列表开始的冒号之间 `className(parameter list) noexcept: initlist {}`
  * 我们**必须在类头文件的声明中和定义中(如果定义在类外的话)都指定noexcept**。
  * 不抛出异常的移动构造函数和移动赋值运算符必须标记为noexcept
  * 搞清楚为什么需要noexcept能帮助我们深入理解标准库是如何与我们自定义的类型交互的。我们需要指出一个移动操作不抛出异常，这是因为两个相互关联的事实：**首先， 虽然移动操作通常不抛出异常，但抛出异常也是允许的；其次，标准库容器能对异常发生时其自身的行为提供保障。**
  * 例如，vector保证，如果我们调用push_back时发生异常， vector自身不会发生改变。现在让我们思考push_back内部发生了什么。对一个vector调用push_back可能要求为vector重新分配内存空 间。当重新分配vector的内存时，vector将元素从旧空间移动到新内存中。
    * 如我们刚刚看到的那样，移动一个对象通常会改变它的值。如果重新分配过程使用了移动构造函数，且在移动了部分而不是全部元素后抛出了一个异常，就会产生问题。旧空间中的移动源元素已经被改变了，而新空间中未构造的元素可能尚不存在。在此情况下， vector将不能满足自身保持不变的要求。
    * 另一方面，如果vector使用了拷贝构造函数且发生了异常，它可以很容易地满足要求。在此情况下，当在新内存中构造元素时，旧元素保持不变。如果此时发生了异常， vector可以释放新分配的(但还未成功构造的)内存并返回。vector原有的元素仍然存在。
  * 为了避免这种潜在问题，**除非vector知道元素类型的移动构造函数不会抛岀异常， 否则在重新分配内存的过程中，它就必须使用拷贝构造函数而不是移动构造函数**。如果希望在vector重新分配内存这类情况下对我们自定义类型的对象进行移动而不是拷贝，就必须显式地告诉标准库我们的移动构造函数可以安全使用。我们通过将移动构造函数(及移动赋值运算符)标记为noexcept来做到这一点。

* 移动赋值运算符

  * 移动赋值运算符执行与析构函数和移动构造函数相同的工作。与移动构造函数一样， 如果我们的移动赋值运算符不抛出任何异常，我们就应该将它标记为noexcepto类似拷贝赋值运算符，**移动赋值运算符必须正确处理自赋值**

    ```c++
    StrVec &StrVec::operator=(StrVec &&rhs) noexcept
    {
      //直接检测自赋值
      if (this != &rhs) (
        free () ;	//释放已有元素
        elements = rhs.elements; // 从 rhs 接管资源 first free = rhs.first free;
        cap = rhs.cap;
        //将rhs置于可析构状态
        rhs.elements = rhs.first_free = rhs.cap = nullptr; )
        return *this;
    	}
    }
    ```

  在此例中，我们直接检查this指针与rhs的地址是否相同。如果相同，右侧和左侧运算对象指向相同的对象，我们不需要做任何事情。否则，我们释放左侧运算对象所使用的内存，并接管给定对象的内存。与移动构造函数一样，我们将rhs中的指针置为nullptr。

* 我们费心地去检查自赋值情况看起来有些奇怪。毕竟，移动赋值运算符需要右侧运算对象的一个右值。我们进行检查的原因是此右值可能是move调用的返回结果。**与其他任何赋值运算符一样，关键点是我们不能在使用右侧运算对象的资源之前就释放左侧运算对象的资源（可能是相同的资源）**。

* 移后源对象必须可析构

  * 从一个对象移动数据并不会销毁此对象，但有时在移动操作完成后，源对象会被销毁。 因此，**当我们编写一个移动操作时，必须确保移后源对象进入一个可析构的状态**。我们的 StrVec 的移动操作满足这一要求，这是通过将移后源对象的指针成员置为nullptr来实现的。
  * 除了将移后源对象置为析构安全的状态之外，移动操作还必须**保证对象仍然是有效的**。一般来说，对象有效就是指可以安全地为其赋予新值或者可以安全地使用而不依赖其当前值。另一方面，**移动操作对移后源对象中留下的值没有任何要求**。因此，我们的程序不应该依赖于移后源对象中的数据。
    * 例如，当我们从一个标准库string或容器对象移动数据时，我们知道移后源对象仍然保持有效。因此，我们可以对它执行诸如empty或size这些操作。但是，我们不知道将会得到什么结果。我们可能期望一个移后源对象是空的，但这并没有保证。可能表现出完全不同的行为。
    * 我们的StrVec类的移动操作将移后源对象置于与默认初始化的对象相同的状态。因 此，我们可以继续对移后源对象执行所有的StrVec操作，与任何其他默认初始化的对象一样。而其他内部结构更为复杂的类，会体现出更为复杂的行为

* **在移动操作之后，移后源对象必须保持有效的、可析构的状态，但是用户不能对其值进行任何假设**

* 合成的移动操作

  * 与处理拷贝构造函数和拷贝赋值运算符一样，编译器也会合成移动构造函数和移动赋值运算符。但是，合成移动操作的条件与合成拷贝操作的条件大不相同。

  * 回忆一下，如果我们不声明自己的拷贝构造函数或拷贝赋值运算符，编译器总会为我们合成这些操作。拷贝操作要么被定义为逐成员拷贝，要么被定义为对象赋值，要么被定义为删除的函数。

  * 与拷贝操作不同，编译器根本不会为某些类合成移动操作。特别是，**如果一个类定义了自己的拷贝构造函数、拷贝赋值运算符或者析构函数，编译器就不会为它合成移动构造函数和移动赋值运算符了**。因此，某些类就没有移动构造函数或移动赋值运算符。如果一个类没有移动操作，通过正常的函数匹配，类会使用对应的拷贝操作来代替移动操作。

  * **只有当一个类没有定义任何自己版本的拷贝控制成员，且类的每个非static数据成员都可以移动时，编译器才会为它合成移动构造函数或移动赋值运算符**。编译器可以移动内置类型的成员。如果一个成员是类类型，且该类有对应的移动操作，编译器也能移动这个成员：

    ```c++
    //编译器会为X和hasX合成移动操作
    struct X (
      int i;	//内置类型可以移动
      std: : string s;	// string定义了自己的移动操作
    ｝；
    struct hasX (
      X mem; // X有合成的移动操作
    ｝；
    X x, x2 = std: :move (x) ;	//使用合成的移动构造函数
    hasX hx, hx2 = std: :move (hx) ;	//使用合成的移动构造函数
    ```

  * 只有当一个类没有定义任何自己版本的拷贝控制成员，且它的所有数据成员都能移动构造或移动赋值时，编译器才会为它合成移动构造函数或移动赋值运算符。

  * 与拷贝操作不同，移动操作永远不会隐式定义为删除的函数。但是，**如果我们显式地要求编译器生成=default的移动操作，且编译器不能移动所有成员，则编译器会将移动操作定义为删除的函数**。除了一个重要例外，什么时候将合成的移动操作定义为删除的函数遵循与定义删除的合成拷贝操作类似的原则

  * 与拷贝构造函数不同，**移动构造函数被定义为删除的函数的条件是：有类成员定义了自己的拷贝构造函数且未定义移动构造函数，或者是有类成员未定义自己的拷贝构造函数且编译器不能为其合成移动构造函数**。移动赋值运算符的情况类似。

    * 如果**有类成员的移动构造函数或移动赋值运算符被定义为删除的或是不可访问的**， 则类的移动构造函数或移动赋值运算符被定义为删除的。
    * 类似拷贝构造函数，如果**类的析构函数被定义为删除的或不可访问的**，则类的移动构造函数被定义为删除的。
    * 类似拷贝赋值运算符，如果**有类成员是const的或是引用**，则类的移动赋值运算符被定义为删除的。

  * 例如，假定Y是一个类，它定义了自己的拷贝构造函数但未定义自己的移动构造函数：

    ```c++
    //假定Y是一个类，它定义了自己的拷贝构造函数但未定义自己的移动构造函数 
    struct hasY (
      hasY () = default;
      hasY(hasY&&) = default;
      Y mem; // hasY将有一个删除的移动构造函数
    ｝；
    hasY hy, hy2 = std: :move (hy) ; //错误：移动构造函数是删除的
    ```

    编译器可以拷贝类型为Y的对象，但不能移动它们。类hasY显式地要求一个移动构造函数，但编译器无法为其生成。因此，hasY会有一个删除的移动构造函数。如果hasY忽略了移动构造函数的声明，则编译器根本不能为它合成一个。如果移动操作可能被定义为删除的函数，编译器就不会合成它们。

* 移动操作和合成的拷贝控制成员间还有最后一个相互作用关系：一个类是否定义了自己的移动操作对拷贝操作如何合成有影响。

  * **如果类定义了一个移动构造函数和/或一个移动赋值运算符，则该类的合成拷贝构造函数和拷贝赋值运算符会被定义为删除的。**
  * **定义了一个移动构造函数或移动赋值运算符的类必须也定义自己的拷贝操作。 否则，这些成员默认地被定义为删除的**

* 移动右值，拷贝左值

  * 如果一个类既有移动构造函数，也有拷贝构造函数，编译器使用普通的函数匹配规则来确定使用哪个构造函数。赋值操作的情况类似。
    * 例如，在我们的StrVec类中，拷贝构造函数接受一个const StrVec的引用。因此，它可以用于任何可以转换为StrVec的类型。而移动构造函数接受一个StrVec&&,因此只能用于实参 是(非static)右值的情形：

* 如果没有移动构造函数，右值也被拷贝

  * 如果一个类有一个拷贝构造函数但未定义移动构造函数，会发生什么呢？在此情况 下，编译器不会合成移动构造函数，这意味着此类将有拷贝构造函数但不会有移动构造函数。如果一个类没有移动构造函数，函数匹配规则保证该类型的对象会被拷贝，即使我们试图通过调用move来移动它们时也是如此：

    ```c++
    class Foo {
    public:
      Foo() = default;
      Foo (const Foo&) ; //拷贝构造函数
      //其他成员定义，但Foo未定义移动构造函数
    }；
    
    Foo X；
    Foo y (x) ;	//拷贝构造函数；x是一个左值
    Foo z (std: :move (x)) ; //拷贝构造函数，因为未定义移动构造函数
    ```

    * 在对z进行初始化时，我们调用了 move (x),它返回一个绑定到x的Foo&&。Foo的拷贝构造函数是可行的，因为我们可以将一个Foo&&转换为一个const Foo&. 因此，z的初始化将使用Foo的拷贝构造函数。

  * 值得注意的是，**用拷贝构造函数代替移动构造函数几乎肯定是安全的(赋值运算符的情况类似)**。一般情况下，拷贝构造函数满足对应的移动构造函数的要求：它会拷贝给定对象，并将原对象置于有效状态。实际上，拷贝构造函数甚至都不会改变原对象的值。

  * 如果一个类有一个可用的拷贝构造函数而没有移动构造函数，则其对象是通过拷贝构造函数来“移动”的。拷贝赋值运算符和移动赋值运算符的情况类似

* 拷贝并交换赋值运算符和移动操作

  * 我们的HasPtr版本定义了一个拷贝并交换赋值运算符， 它是函数匹配和移动操作间相互关系的一个很好的示例。如果我们为此类添加一个移动构造函数，它实际上也会获得一个移动赋值运算符：

    ```c++
    class HasPtr {
    public:
      //添加的移动构造函数
      HasPtr(HasPtr &&p) noexcept : ps(p.ps), i(p.i) {p.ps = 0;}
      //赋值运算符既是移动赋值运算符，也是拷贝赋值运算符 
      HasPtr& operator=(HasPtr rhs) { swap(*this, rhs); return *this; }
      //其他成员的定义，同13.2.1节(第453页)
    }；
    ```

* 建议：更新三/五法则

  * 所有五个拷贝控制成员应该看作一个整体：**一般来说，如果一个类定义了任何一个拷贝操作，它就应该定义所有五个操作**。如前所述，某些类必须定义拷贝构造函教、拷贝赋值运算符和析构函数才能正确工作。**这些类通常拥有 一个资源，而拷贝成员必须拷贝此资源**。一般来说，拷贝一个资源会导致一些额外开销。 在这种拷贝并非必要的情况下，定义了移动构造函数和移动赋值运算符的类就可以避免此问题

* 定义了自己的拷贝构造函数和拷贝赋值运算符的类通常也会从移动操作受益。

  ```c++
  Message(Message&&);
  Message &operator=(Message&&);
  void moveFolders(Message*);
  Message::Message(Message &&m):contents(std::move(m.contents)) {
      moveFolders(&m);
  }
  void Message::moveFolders(Message *m) {
      folders = std::move(m->folders);
      for(auto f: folders) {
          f->remMessage(m);
          f->addMessage(this);
      }
      m->folders.clear();
  }
  Message & Message::operator=(Message &&rhs) {
      if (&rhs == this) return *this;
  
      removeFromFolders();
      contents = std::move(rhs.contents);
      moveFolders(&rhs);
  }
  ```

* 与任何赋值运算符一样，移动赋值运算符必须销毁左侧运算对象的旧状态。

* 移动迭代器

  * 新标准库中定义了一种移动迭代器(move iterator)适配器。 一个移动迭代器通过改变给定迭代器的解引用运算符的行为来适配此迭代器。**一般来说， 一个迭代器的解引用运算符返回一个指向元素的左值。与其他迭代器不同，移动迭代器的解引用运算符生成一个右值引用。**
  * 我们通过调用标准库的make_move_iterator函数将一个普通迭代器转换为一个移动迭代器。此函数接受一个迭代器参数，返回一个移动迭代器。
  * 原迭代器的所有其他操作在移动迭代器中都照常工作。由于移动迭代器支持正常的迭代器操作，我们可以将一对移动迭代器传递给算法。特别是，可以将移动迭代器传递给 uninitialized_copy
  * **uninitialized_copy对输入序列中的每个元素调用construct来将元素"拷贝"到 目的位置**。此算法**使用迭代器的解引用运算符从输入序列中提取元素**。由于我们传递给它的是移动迭代器，因此解引用运算符生成的是一个右值引用，这意味着construct将使用移动构造函数来构造元素。
  * 值得注意的是，标准库不保证哪些算法适用移动迭代器，哪些不适用。由于移动一个对象可能销毁掉原对象，因此你**只有在确信算法在为一个元素赋值或将其传递给一个用户定义的函数后不再访问它时，才能将移动迭代器传递给算法**。

* **由于一个移后源对象具有不确定的状态，对其调用std: :move是危险的。当我们 调用move时，必须绝对确认移后源对象没有其他用户。**

* 通过在类代码中小心地使用move,可以大幅度提升性能。而如果随意在普通用户代码（与类实现代码相对）中使用移动操作，很可能导致莫名其妙的、难以查找的错误， 而难以提升应用程序性能。

* 在移动构造函数和移动赋值运算符这些类实现代码之外的地方，只有**当你确信需要进行移动操作且移动操作是安全的，才可以使用std:: move**；

##### 右值引用和成员函数

* **除了构造函数和赋值运算符之外，如果一个成员函数同时提供拷贝和移动版本，它也能从中受益。这种允许移动的成员函数通常使用与拷贝/移动构造函数和赋值运算符相同的参数模式。 一个版本接受一个指向const的左值引用，第二个版本接受一个指向非const的右值引用。**

  * 例如，定义了 push_back的标准库容器提供两个版本：一个版本有一个右值引用参 数，而另一个版本有一个const左值引用。假定X是元素类型，那么这些容器就会定义以下两个push_back版本：

    ```c++
    void push_back (const X&) ;	//拷贝：绑定到任意类型的X
    void push_back (X&&) ;	//移动：只能绑定到类型X的可修改的右值
    ```

    我们可以将能转换为类型X的任何对象传递给第一个版本的push_back。此版本从其参数拷贝数据。对于第二个版本，我们只可以传递给它非const的右值。此版本对于非 const的右值是精确匹配(也是更好的匹配)的，因此当我们传递一个可修改的右值时，编译器会选择运行这个版本。此版本会从其参数窃取数据。

* **一般来说，我们不需要为函数操作定义接受一个const X&&或是一个(普通的)X& 参数的版本**。当我们希望从实参''窃取”数据时，通常传递一个右值引用。为了达到这一目的，实参不能是const的。类似的，从一个对象进行拷贝的操作不应该改变该对象。 因此，通常不需要定义一个接受一个(普通的)X&参数的版本。

* 区分移动和拷贝的重载函数通常有一个版本接受一个const T&,而另一个版本接受一个T&&

* 右值和左值引用成员函数

  * 通常，我们在一个对象上调用成员函数，而不管该对象是一个左值还是一个右值。例如：

    ```c++
    string si = "na value", s2 = "another";
    auto n = (si + s2).find('a');
    ```

    此例中，我们在一个string右值上调用find成员，该 string 右值是通过连接两个string而得到的。有时，右值的使用方式可能令人惊讶：

    ```c++
    sl + s2 = "wow!";
    ```

    此处我们对两个string的连接结果个右值，进行了赋值。在旧标准中，我们没有办法阻止这种使用方式。为了维持向后兼容性，新标准库类仍然允许向右值赋值。但是，我们可能希望在自己的类中阻止这种用法。在此情况下，我们希望**强制左侧运算对象(即，this指向的对象)是一个左值**。

  * 我们指出**this的左值/右值属性**的方式与定义const成员函数相同，即，在参数列表后放置一个**引用限定符(reference qualifier)**：

    ```c++
    class Foo {
    public:
    Foo &operator= (const Foo&) &; //只能向可修改的左值赋值
    
    // Foo 的其他参数
    };
    
    Foo &Foo::operator=(const Foo &rhs) &{
        //执行将rhs赋予本对象所需的工作
        return *this;
    }
    ```

  * **引用限定符可以是&或&&,分别指出this可以指向一个左值或右值。类似const限定符， 引用限定符只能用于(非static)成员函数，且必须同时出现在函数的声明和定义中。**

  * 一个函数可以同时用 const 和引用限定。在此情况下，引用限定符必须跟随在 const 限定符之后

* 重载和引用函数

  * 就像一个成员函数可以根据是否有const来区分其重载版本一样，引用限定符也可以区分重载版本。而且，我们可以综合引用限定符和const来区分一个成员函数的重载版本。

    ```c++
    class Foo {
    public:
        Foo sorted () &&;	    //可用于可改变的右值
        Foo sorted () const &;	//可用于任何类型的F
    
    // Foo的其他成员的定义
    private:
        vector<int> data;
    };
    
    //本对象为右值，因此可以原址排序
    Foo Foo::sorted() &&
    {
        sort(data.begin(), data.end());
        return *this;
    }
    
    //本对象是const或是一个左值，哪种情况我们都不能对其进行原址排序
    Foo Foo::sorted() const & {
        Foo ret (*this) ;	// 拷贝一个副本
        sort (ret .data .begin () , ret.data .end () ) ;	// 排序副本
        return ret;	//返回畐寸本
    }
    
    // 当我们对一个右值执行sorted时，它可以安全地直接对data成员进行排序。对象是一个右值，意味着没有其他用户，因此我们可以改变对象。当对一个const右值或一个左值执行sorted时，我们不能改变对象，因此就需要在排序前拷贝data。
    // 编译器会根据调用sorted的对象的左值/右值属性来确定使用哪个sorted版本：
    ```

  * 当我们定义const成员函数时，可以定义两个版本，唯一的差别是一个版本有const 限定而另一个没有。引用限定的函数则不一样。如果我们定义两个或两个以上具有相同名字和相同参数列表的成员函数，就必须对所有函数都加上引用限定符，或者所有都不加：

    ```c++
    class Foo {
    public:
      Foo sorted() &&;
      Foo sorted () const; //错误：必须加上引用限定符 
      
      // Comp是函数类型的类型别名
      //此函数类型可以用来比较int值
      using Comp = bool(const int&, const int&);
      Foo sorted (Comp*) ;	//正确：不同的参数列表
      Foo sorted (Comp*) const; //正确：两个版本都没有引用限定符 
    }
    ```

* **如果一个成员函数有引用限定符，则具有相同参数列表的所有版本都必须有引用限定符。**

#### 小结

* **每个类都会控制该类型对象拷贝、移动、赋值以及销毁时发生什么**。特殊的成员函数: 拷贝构造函数、移动构造函数、拷贝赋值运算符、移动赋值运算符和析构函数定义了这些操作。**移动构造函数和移动赋值运算符接受一个(通常是非const的)右值引用；而拷贝版本则接受一个(通常是const的)普通左值引用。**

* 如果一个类未声明这些操作，编译器会自动为其生成。如果这些操作未定义成删除的， 它们会逐成员初始化、移动、赋值或销毁对象：合成的操作依次处理每个非static数据 成员，根据成员类型确定如何移动、拷贝、赋值或销毁它。

* **分配了内存或其他资源的类几乎总是需要定义拷贝控制成员来管理分配的资源**。如果一个类需要析构函数，则它几乎肯定也需要定义移动和拷贝构造函数及移动和拷贝赋值运算符。

  

